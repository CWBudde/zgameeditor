
Listing
-------
0 errors and 46 warnings
*****  Warning: LL1 warning in ZcFuncBody:"vec2" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"mat4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec3" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"const" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"xptr" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"int" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"float" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"byte" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"model" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"string" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"if" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"@" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"reinterpret_cast" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"null" is start & successor of deletable structure
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
*****  Warning: LL1 warning in Zc: contents of [...] or {...} must not be deletable
*****  Warning: LL1 warning in ZcFuncBody:"return" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"while" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"switch" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"for" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"continue" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"break" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lbrace is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:inc is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lpar is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:not is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:minus is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:realCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:intCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:stringCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:dec is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:ident is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:scolon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Font" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Camera" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sample" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Component" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"File" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sound" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Material" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Shader" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Mesh" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Bitmap" is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      ReturnType : TZcDataType;
   11      AllowFunctions : boolean;
   12      GlobalNames : TObjectList;
   13      TempCounter : integer;
   14      ZApp : TZApplication;
   15      destructor Destroy; override;
   16      procedure CheckHomograph(var sym: Integer); override;
   17  .)
   18  private = (.
   19      IsInIdent,IsInInvokeArg : boolean;
   20      CurrentFunction : TZcOpFunctionUserDefined;
   21      procedure CleanUp;
   22      procedure ZError(const S : string);
   23      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      function IsConst : boolean;
   26      .)
   27  precreate = (.
   28      ZFunctions := TObjectList.Create(False);
   29      Self.OnError := OnParserError;
   30  
   31  .)
   32  
   33  semErrors = (.
   34      200 : Result := 'Not a floating point value';
   35      201 : Result := 'Name already defined in this scope';
   36      202 : Result := 'Return value expected';
   37      203 : Result := 'Function should not return a value';
   38      204 : Result := 'Only function definitions are allowed here';
   39      205 : Result := 'Syntax not supported';
   40  .)
   41  
   42  implementation = (.
   43  
   44  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   45  begin
   46    ZError(Msg + ' ' + Data);
   47  end;
   48  
   49  procedure TZc.CheckHomograph(var sym: Integer);
   50  begin
   51    //Only Homographs are name of component datatypes
   52    //If inside identifier "x.y.z" then let it refer to identifier instead
   53    if IsInIdent or IsInInvokeArg then
   54      sym := identSym;
   55  end;
   56  
   57  destructor TZc.Destroy;
   58  begin
   59    inherited;
   60    CleanUp;
   61  end;
   62  
   63  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   64  begin
   65    if Op=nil then
   66    begin
   67      if SwitchOp.HasDefault then
   68        ZError('Only one default statement is allowed.');
   69      SwitchOp.HasDefault := True;
   70    end else
   71      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   72    SwitchOp.CaseOps.Last.Children.Add( Op );
   73    Op := nil;
   74  end;
   75  
   76  procedure TZc.CleanUp;
   77  begin
   78    Zc_Ops.FunctionCleanUps.Clear;
   79    ZFunctions.Free;
   80  end;
   81  
   82  procedure TZc.ZError(const S : string);
   83  var
   84    E : EParseError;
   85    P : TSymbolRec;
   86  begin
   87    E := EParseError.Create(S);
   88    E.Message := S;
   89    Scanner.GetPosition(P);
   90    E.Line := P.Line;
   91    E.Col := P.Col;
   92    if (E.Line<>0) or (E.Col<>0) then
   93      E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
   94    raise E;
   95  end;
   96  
   97  function TZc.IsConst : boolean;
   98  begin
   99    Result := (CurrentInputSymbol=constSym) or
  100      ((CurrentInputSymbol=privateSym) and (Symbols[2].Id=constSym));
  101  end;
  102  
  103  .)
  104  
  105  END
  106  
  107  
  108  CHARACTERS
  109  
  110          tab                = CHR(9). /*  9 = tabulator */
  111          eol                = CHR(10). /* 10 = line feed */
  112          cr                 = CHR(13). /* 13 = carriage return */
  113          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  114  
  115          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  116          digit              = "0123456789".
  117          hexDigit           = digit + "ABCDEFabcdef".
  118          notDigit           = ANY - digit.
  119  
  120          char               = ANY - "'" - '\' - newLine.
  121          verbatimStringChar = ANY - '"'.
  122          regularStringChar  = ANY - '"' - '\' - newLine.
  123          notNewLine         = ANY - newLine .
  124  
  125  
  126  TOKENS
  127  
  128    /*--------------------------------------------------------------------------------*/
  129          intCon =
  130                  ( digit {digit}
  131                  | ("0x" | "0X") hexDigit {hexDigit}
  132                  )
  133                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  134                  .
  135    /*--------------------------------------------------------------------------------*/
  136          realCon =
  137                  "." digit {digit}
  138                  [("e" | "E") ["+" | "-"] digit {digit}]
  139                  ["F" | "f" | "D" | "d" | "M" | "m"]
  140          | digit {digit}
  141                  ( "." digit {digit}
  142                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  143                          ["F" | "f" | "D" | "d" | "M" | "m"]
  144                  | ("e" | "E") ["+" | "-"] digit {digit}
  145                          ["F" | "f" | "D" | "d" | "M" | "m"]
  146                  | "F" | "f" | "D" | "d" | "M" | "m"
  147                  ).
  148    /*--------------------------------------------------------------------------------*/
  149          stringCon =
  150                  '"'    { regularStringChar
  151            | "\'" | '\"' | "\\" | "\n"
  152            }
  153                  '"'.
  154  
  155          ident = letter { letter | digit }.
  156  
  157  
  158          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  159          and    = "&".
  160          assgn  = "=".
  161          colon  = ":".
  162          comma  = ",".
  163          dec    = "--".
  164          div    = "/".
  165          dot    = ".".
  166          eq     = "==".
  167          gt     = ">".
  168          gte    = ">=".
  169          inc    = "++".
  170          lbrace = "{".
  171          lbrack = "[".
  172          lpar   = "(".
  173          lshift = "<<".
  174          lt     = "<".
  175          lte    = "<=".
  176          minus  = "-".
  177          mod    = "%".
  178          neq    = "!=".
  179          not    = "!".
  180          or     = "|".
  181          plus   = "+".
  182          rbrace = "}".
  183          rbrack = "]".
  184          rpar   = ")".
  185          rshift = ">>".
  186          scolon = ";".
  187          tilde  = "~".
  188          times  = "*".
  189          xor    = "^".
  190  
  191  
  192  
  193  COMMENTS FROM "/*" TO "*/"
  194  COMMENTS FROM "//" TO eol
  195  
  196  IGNORE eol + cr + tab
  197  
  198  HOMOGRAPHS
  199    "Material"
  200    "Sound"
  201    "Shader" 
  202    "Bitmap" 
  203    "Mesh"
  204    "Camera" 
  205    "Font"
  206    "Sample"
  207    "File"
  208    "Component"
  209  
  210  PRODUCTIONS
  211  
  212  /*------------------------------------------------------------------------*
  213   *--------------------------- Declarations -------------------------------*
  214   *------------------------------------------------------------------------*/
  215  
  216  ZcFuncRest<Typ : TZcDataType; const Name : string; IsPrivate,IsInline : boolean>
  217  (.
  218  var
  219    Func : TZcOpFunctionUserDefined;
  220  .)
  221  =
  222       (.
  223          if SymTab.Contains(Name) then
  224            ZError('Name already defined: ' + Name);
  225  
  226          if IsPrivate then
  227            Func := TZcOpFunctionUserDefined.Create(nil)
  228          else
  229            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  230          Func.Id := Name;
  231          Func.ReturnType := Typ;
  232          Func.IsInline := IsInline;
  233          if IsPrivate then
  234            SymTab.Add(Func.Id,Func)
  235          else
  236            SymTab.AddPrevious(Func.Id,Func);
  237          ZFunctions.Add(Func);
  238          Self.CurrentFunction := Func;
  239          SymTab.PushScope;
  240          try
  241       .)
  242      [ FormalParams ] ")" "{" ZcFuncBody "}"
  243          (.
  244            finally
  245              SymTab.PopScope;
  246            end;
  247          .)
  248  .
  249  
  250  
  251  Zc (. var
  252          Typ : TZcDataType;
  253          Func : TZcOpFunctionUserDefined;
  254          Name : string;
  255          IsPrivate,IsInline : boolean;
  256      .)
  257  =
  258    IF (. AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  259    {
  260      IF(. IsConst .)
  261        (. IsPrivate := False; .)
  262        [ "private" (. IsPrivate:= True; .) ]
  263        ConstantDeclarationList<IsPrivate>
  264      |
  265        (. IsPrivate := False; IsInline := False; .)
  266        [ "private" (. IsPrivate:= True; .) ]
  267        [ "inline" (. IsInline:= True; .) ]
  268        ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (. Name := LexString; .)
  269         /* Need to separate between global variable and method declarations */
  270         (
  271           "(" ZcFuncRest<Typ,Name,IsPrivate,IsInline>
  272           | GlobalVarDecl<Typ,Name,IsPrivate> ";"
  273         )
  274    }
  275    | IF (. not AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  276    {
  277  
  278    (.
  279         Func := TZcOpFunctionUserDefined.Create(nil);
  280         Func.ReturnType := Self.ReturnType;
  281         Self.CurrentFunction := Func;
  282         try
  283           SymTab.PushScope;
  284           try
  285             ZFunctions.Add(Func);
  286    .)
  287    /* A zc-expression is treated like the body of a nameless function
  288       to allow local var declarations  */
  289  
  290    ZcFuncBody
  291    (.
  292           finally
  293             SymTab.PopScope;
  294           end;
  295         except on E: Exception do
  296           ZError(E.Message);
  297         end;
  298    .)
  299    }
  300  
  301  .
  302  
  303  /*------------------------------------------------------------------------*/
  304  
  305  ZcFuncBody (. var Op : TZcOp; .)
  306  =  {  (. Op:=nil; .)
  307        Statement<Op>
  308        (. if Op<>nil then
  309             CurrentFunction.Statements.Add(Op);
  310           Op := nil;
  311        .)
  312     }
  313  .
  314  
  315  /*------------------------------------------------------------------------*/
  316  FormalParams
  317  = ( Par ["," FormalParams] )
  318  .
  319  /*------------------------------------------------------------------------*/
  320  Par (.
  321  var
  322    Typ : TZcDataType;
  323    Arg : TZcOpArgumentVar;
  324    IsPtr : boolean;
  325  .)
  326  =  (. IsPtr := False; .)
  327    ["ref" (. IsPtr := True; .) ]
  328    Type<Typ> ident
  329       (.
  330          Typ.IsPointer := IsPtr;
  331          if SymTab.ScopeContains(LexString) then
  332            SynError(201)
  333          else
  334          begin
  335            Arg := TZcOpArgumentVar.Create;
  336            Arg.Id := LexString;
  337            Arg.Typ := Typ;
  338            CurrentFunction.AddArgument(Arg);
  339            SymTab.Add(Arg.Id,Arg);
  340          end;
  341       .)
  342  .
  343  /*------------------------------------------------------------------------*/
  344  
  345  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  346  = (. OutOp := nil; .)
  347    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  348  .
  349  
  350  /*------------------------------------------------------------------------*/
  351  
  352  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  353  = ident
  354       (. 
  355          if SymTab.ScopeContains(LexString) then
  356            ZError('Name already defined: ' + LexString);
  357  
  358          Loc := TZcOpLocalVar.Create(nil);
  359          Loc.Id := LexString;
  360          Loc.Typ := Typ;
  361       .)
  362       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  363       (.
  364          SymTab.Add(Loc.Id,Loc);
  365          CurrentFunction.AddLocal(Loc);
  366  
  367          if Assigned(Loc.InitExpression) then
  368          begin
  369            //Generate tree for initial assignment
  370            if OutOp=nil then
  371              OutOp := MakeOp(zcBlock);
  372            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  373          end;
  374  
  375       .)
  376  .
  377  
  378  /*------------------------------------------------------------------------*/
  379  
  380  GlobalVarRest<Typ : TZcDataType; const Name : string; IsPrivate : boolean> (. var V : TDefineVariableBase; .)
  381  =
  382       (.
  383          if SymTab.ScopeContains(Name) then
  384            ZError('Name already defined: ' + Name);
  385  
  386          if Typ.Kind=zctArray then
  387          begin
  388            TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
  389            V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
  390            V._ReferenceClassId := Typ.ReferenceClassId;
  391            Self.ZApp.GlobalVars.AddComponent(V);
  392          end
  393          else
  394          begin
  395            V := TDefineVariable.Create(Self.ZApp.GlobalVars);
  396            V._Type := Typ.Kind;
  397            V._ReferenceClassId := Typ.ReferenceClassId;
  398          end;
  399  
  400          V.SetString('Name', AnsiString(Name));
  401          V.DesignerReset; //Needed to init managed variables
  402          if IsPrivate then
  403            SymTab.Add(Name,V)
  404          else
  405            SymTab.AddPrevious(Name,V);
  406       .)
  407  .
  408  
  409  
  410  GlobalVar<Typ : TZcDataType; IsPrivate : boolean>
  411  = ident GlobalVarRest<Typ,LexString,IsPrivate>
  412  .
  413  
  414  GlobalVarDecl<Typ : TZcDataType; const Name : string; IsPrivate : boolean>
  415  = GlobalVarRest<Typ,Name,IsPrivate> {"," GlobalVar<Typ,IsPrivate>}
  416  .
  417  
  418  /*------------------------------------------------------------------------*/
  419  
  420  Init<var OutOp : TZcOp>
  421  = Expr<OutOp>
  422  .
  423  
  424  /*------------------------------------------------------------------------*/
  425  Argument<var OutOp : TZcOp>
  426  = /* ["ref" | "out"] */
  427    (. OutOp := nil; .)
  428    Expr<OutOp>
  429    (. if OutOp=nil then ZError('Missing argument'); .)
  430  .
  431  
  432  /*------------------------------------------------------------------------*
  433   *-------------------------------- Types ---------------------------------*
  434   *------------------------------------------------------------------------*/
  435  
  436  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  437   * and for array creation expressions                                     */
  438  
  439  
  440  Type<var Typ : TZcDataType>
  441  (.
  442    var
  443      A : TDefineArray;
  444      SizeOp : TZcOp;
  445      I : integer;
  446  .)
  447  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  448    ( SimpleType<Typ> )
  449    {
  450      (
  451        "["       (.
  452                     A := TDefineArray.Create(nil);
  453                     GlobalNames.Add(A);
  454                     A._Type := Typ.Kind;
  455                     Typ.Kind := zctArray;
  456                     Typ.TheArray := A;
  457                  .)
  458  
  459           [ Expr<SizeOp> (.
  460              SizeOp := SizeOp.Optimize;
  461              if SizeOp.Kind<>zcConstLiteral then
  462                ZError('Array size must be a constant expression');
  463              A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
  464                           .)
  465           ]
  466  
  467           { ","  (. if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); .)
  468             [ Expr<SizeOp> (.
  469                  SizeOp := SizeOp.Optimize;
  470                  if SizeOp.Kind<>zcConstLiteral then
  471                    ZError('Array size must be a constant expression');
  472                 I := Trunc( (SizeOp as TZcOpLiteral).Value );
  473                 if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
  474             .) ]
  475           }
  476         "]"
  477      )
  478    }
  479  .
  480  
  481  /*------------------------------------------------------------------------*/
  482  
  483  SimpleType<var Typ : TZcDataType>
  484  (.
  485    var
  486      A : TDefineArray;
  487  .)
  488  /* = IntType | "float" | "double" | "decimal" | "bool" */
  489  = "float" (. Typ.Kind := zctFloat; .)
  490    | "int" (. Typ.Kind := zctInt; .)
  491    | "byte" (. Typ.Kind := zctByte; .)
  492    | "string" (. Typ.Kind := zctString; .)
  493    | "model" (. Typ.Kind := zctModel; .)
  494    | "xptr" (. Typ.Kind := zctXptr; .)
  495  
  496    | "mat4" (.
  497       A := Prototypes.Mat4Array;
  498       Typ.Kind := zctMat4;
  499       Typ.TheArray := A;
  500      .)
  501    | "vec2" (.
  502       A := Prototypes.Vec2Array;
  503       Typ.Kind := zctVec2;
  504       Typ.TheArray := A;
  505    .)
  506    | "vec3" (.
  507       A := Prototypes.Vec3Array;
  508       Typ.Kind := zctVec3;
  509       Typ.TheArray := A;
  510    .)
  511    | "vec4" (.
  512       A := Prototypes.Vec4Array;
  513       Typ.Kind := zctVec4;
  514       Typ.TheArray := A;
  515    .)
  516  
  517    /* Changes below also must be made in homographs-section */
  518    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  519    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  520    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  521    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  522    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  523    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  524    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  525    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  526    | "File" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; .)
  527  
  528    | "Component" (. Typ.Kind := zctReference; Typ.ReferenceClassId := AnyComponentClassId; .)
  529  .
  530  
  531  /*------------------------------------------------------------------------*/
  532  
  533  /* IntType
  534  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  535  . */
  536  
  537  
  538  ConstantDeclarationList<IsPrivate : boolean>
  539  (.
  540  var
  541    Typ : TZcDataType;
  542  .)
  543  = "const" Type<Typ> ConstantDeclaration<Typ,IsPrivate> {"," ConstantDeclaration<Typ,IsPrivate> }
  544    ";"
  545  .
  546  
  547  ConstantDeclaration<var Typ : TZcDataType; IsPrivate : boolean>
  548  (.
  549  var
  550    Cns : TDefineConstant;
  551    Op : TZcOp;
  552    Lit : TZcOpLiteral;
  553    CnsName : string;
  554  .)
  555  =
  556  ident (. CnsName := LexString; .) "=" Expr<Op>
  557    (.
  558     if not (Typ.Kind in [zctByte,zctInt,zctFloat,zctString]) then
  559       ZError('Only byte, int, float and string constants are allowed');
  560  
  561     Op := Op.Optimize;
  562     if not (Op is TZcOpLiteral) then
  563       ZError('Constant expression expected: ' + Op.ToString);
  564  
  565     Lit := Op as TZcOpLiteral;
  566  
  567     if (Lit.Typ.Kind<>Typ.Kind) and not ((Typ.Kind=zctByte) and (Lit.Typ.Kind=zctInt))then
  568       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  569  
  570     Cns := TDefineConstant.Create(nil);
  571     Cns.SetString('Name',AnsiString(CnsName));
  572     GlobalNames.Add(Cns);
  573  
  574     case Typ.Kind of
  575       zctByte:
  576         begin
  577           Cns._Type := zctByte;
  578           Cns.ByteValue := Round(Lit.Value);
  579         end;
  580       zctInt:
  581         begin
  582           Cns._Type := zctInt;
  583           Cns.IntValue := Round(Lit.Value);
  584         end;
  585       zctFloat:
  586         begin
  587           Cns._Type := zctFloat;
  588           Cns.Value := Lit.Value;
  589         end;
  590       zctString:
  591         begin
  592           Cns._Type := zctString;
  593           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  594         end;
  595       else
  596         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  597     end;
  598     if IsPrivate then
  599       SymTab.Add(CnsName,Cns)
  600     else
  601       SymTab.AddPrevious(CnsName,Cns)
  602    .)
  603  /* {"," ident "=" Expr<Op>} */
  604  .
  605  
  606  /*------------------------------------------------------------------------*
  607   *------------------------------ Statements ------------------------------*
  608   *------------------------------------------------------------------------*/
  609  
  610  Statement<var OutOp : TZcOp>
  611  = (. OutOp := nil; .)
  612  
  613  ConstantDeclarationList<false>
  614  
  615  /*IF IsLocalVarDecl THEN
  616  BEGIN
  617    LocalVarDecl ";"
  618  END
  619  |  EmbeddedStatement<OutOp> */
  620  
  621  | LocalVarDecl<OutOp> ";"
  622  | EmbeddedStatement<OutOp>
  623    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  624     * ident {"." ident} { "[" ...                           */
  625  .
  626  
  627  /*------------------------------------------------------------------------*/
  628  EmbeddedStatement<var OutOp : TZcOp>
  629    (. var
  630         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  631         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  632         WhileCondOp,WhileBodyOp : TZcOp;
  633         SwitchOp : TZcOpSwitch;
  634         Loc : TZcOpLocalVar;
  635    .)
  636  = Block<OutOp>
  637  | ";"   (. OutOp := MakeOp(zcNop); .)
  638  | StatementExpr<OutOp> ";"
  639  | "if" (. ElseOp := nil; .)
  640    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  641          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  642   | "switch" "(" Expr<SwitchValueOp> ")"
  643        (.
  644           Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
  645           SymTab.Add(Loc.Id,Loc);
  646           CurrentFunction.AddLocal(Loc);
  647  
  648           OutOp := MakeOp(zcBlock);
  649           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  650  
  651           SwitchOp := TZcOpSwitch.Create(nil);
  652           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  653           OutOp.Children.Add(SwitchOp);
  654        .)
  655     "{" {
  656       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  657       SwitchSection<SwitchOp>
  658     } "}"
  659   | "while"
  660       (. try
  661           SymTab.PushScope;
  662           WhileCondOp := nil; WhileBodyOp := nil; .)
  663     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  664     (.
  665           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  666         finally
  667           SymTab.PopScope;
  668         end;
  669     .)
  670   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  671   | "for"
  672      (. try
  673           SymTab.PushScope;
  674           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  675     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  676     (.
  677           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  678         finally
  679           SymTab.PopScope;
  680         end;
  681     .)
  682  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  683   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  684   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  685   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  686      (.
  687          if (Op=nil) then
  688          begin
  689            if CurrentFunction.ReturnType.Kind<>zctVoid then
  690              SynError(202)
  691            else
  692              OutOp := MakeOp(zcReturn);
  693          end else
  694          begin
  695            if CurrentFunction.ReturnType.Kind=zctVoid then
  696              SynError(203)
  697            else
  698              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  699          end;
  700          Inc(CurrentFunction.ReturnCount);
  701      .)
  702  .
  703  /*------------------------------------------------------------------------*/
  704  
  705  Block<var OutOp : TZcOp>
  706    (. var
  707         Op : TZcOp;
  708    .)
  709  = (. Op := nil;
  710       OutOp := MakeOp(zcBlock);
  711    .)
  712    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  713  
  714  /*------------------------------------------------------------------------*/
  715  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  716  = (. Op1 :=nil; Op2 := nil; .)
  717    Unary<Op1>
  718    ( AssignOp<Kind> Expr<Op2>
  719      (.
  720        if Op2<>nil then
  721          OutOp := MakeAssign(Kind,Op1,Op2);
  722      .)
  723    |                             (. OutOp := Op1; .)
  724    )
  725  .
  726  
  727  /*------------------------------------------------------------------------*/
  728  AssignOp<var Kind : TZcAssignType>
  729  = "="     (. Kind := atAssign; .)
  730    | "+="  (. Kind := atPlusAssign; .)
  731    | "-="  (. Kind := atMinusAssign; .)
  732    | "*="  (. Kind := atMulAssign; .)
  733    | "/="  (. Kind := atDivAssign; .)
  734  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  735  .
  736  
  737  /*------------------------------------------------------------------------*/
  738  
  739  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  740  = (. Op := nil; .)
  741    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  742    {
  743      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  744    }
  745    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  746    {
  747       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  748    }
  749  .
  750  
  751  /*------------------------------------------------------------------------*/
  752  
  753  SwitchLabel<var OutOp : TZcOp>
  754  = "case" Expr<OutOp> ":"
  755  | "default" ":"
  756  .
  757  
  758  /*------------------------------------------------------------------------*/
  759  
  760  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  761  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  762  (
  763  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  764  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  765    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  766  )
  767  .  
  768  
  769  /*------------------------------------------------------------------------*/
  770  
  771  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  772  = (. Op:=nil; 
  773       OutOp := MakeOp(zcBlock);
  774    .) 
  775  (
  776  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  777  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  778  )
  779  . 
  780  
  781  
  782  /*------------------------------------------------------------------------*
  783   *----------------------------- Expressions ------------------------------*
  784   *------------------------------------------------------------------------*/
  785  
  786  
  787  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  788  = (. Op1 :=nil; Op2 := nil; .)
  789    Unary<Op1>
  790    ( OrExpr<Op1,OutOp>
  791        ["?" Expr<Op1> ":" Expr<Op2>
  792           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  793                SynError(205)
  794              else
  795                OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
  796           .)
  797        ]
  798    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  799    )
  800  .
  801  /*------------------------------------------------------------------------*/
  802  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  803  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  804      {"||" Unary<Op> AndExpr<Op,R>
  805        (. OutOp := MakeOp(zcOr,[L,R]);
  806           L := OutOp; .)
  807      }
  808  .
  809  
  810  
  811  /*------------------------------------------------------------------------*/
  812  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  813  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  814      {"&&" Unary<Op> BitOrExpr<Op,R>
  815        (. OutOp := MakeOp(zcAnd,[L,R]);
  816           L := OutOp; .)
  817      }
  818  .
  819  /*------------------------------------------------------------------------*/
  820  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  821  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  822    {"|" Unary<Op> BitXorExpr<Op,R>
  823      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  824         L := OutOp; .)
  825    }
  826  .
  827  
  828  /*------------------------------------------------------------------------*/
  829  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  830  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  831    {"^" Unary<Op> BitAndExpr<Op,R>
  832      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  833         L := OutOp; .)
  834    }
  835  .
  836  
  837  /*------------------------------------------------------------------------*/
  838  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  839  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  840    {"&" Unary<Op> EqlExpr<Op,R>
  841      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  842         L := OutOp; .)
  843    }
  844  .
  845  
  846  /*------------------------------------------------------------------------*/
  847  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  848  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  849    {( "!="   (. Kind := zcCompNE; .)
  850     | "=="   (. Kind := zcCompEQ; .)
  851     )
  852     Unary<Op> RelExpr<Op,R>
  853           (. OutOp := MakeBinary(Kind, L,R);
  854              L := OutOp;
  855           .)
  856    }
  857  .
  858  /*------------------------------------------------------------------------*/
  859  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  860  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  861    { ( "<"       (. Kind := zcCompLT; .)
  862      | ">"       (. Kind := zcCompGT; .)
  863      | "<="      (. Kind := zcCompLE; .)
  864      | ">="      (. Kind := zcCompGE; .)
  865       )
  866      Unary<Op> ShiftExpr<Op,R>
  867           (. OutOp := MakeBinary(Kind, L,R );
  868              L := OutOp;
  869           .)
  870    }
  871  .
  872  /*------------------------------------------------------------------------*/
  873  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  874  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  875    { ("<<"  (. Kind := zcBinaryShiftL; .)
  876      | ">>" (. Kind := zcBinaryShiftR; .)
  877      )
  878      Unary<Op> AddExpr<Op,R>
  879      (. OutOp := MakeOp(Kind,[L,R]);
  880         L := OutOp; .)
  881    }
  882  .
  883  /*------------------------------------------------------------------------*/
  884  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  885  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
  886      {( "+"    (. Kind := zcPlus; .)
  887       | "-"    (. Kind := zcMinus; .)
  888       ) Unary<Op> MulExpr<Op,R>
  889           (. 
  890              if (L=nil) or (R=nil) then
  891                ZError('Invalid syntax');
  892              OutOp := MakeBinary(Kind,L,R);
  893              L := OutOp;
  894           .)
  895      }
  896  .
  897  /*------------------------------------------------------------------------*/
  898  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  899  = (. OutOp := InOp; Kind := zcNop; .)
  900    { ("*"      (. Kind := zcMul; .)
  901      | "/"     (. Kind := zcDiv; .)
  902      | "%"     (. Kind := zcMod; .)
  903      ) Unary<Tmp>
  904           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  905              InOp := OutOp;
  906           .)
  907      }
  908  .
  909  /*------------------------------------------------------------------------*/
  910  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  911  =       (. LastOp := nil; Kind := zcNop; .)
  912    {
  913      (
  914        /* "+" | */
  915        "-"   (. Kind := zcNegate; .) |
  916        "++"  (. Kind := zcPreInc; .) |    
  917        "--"  (. Kind := zcPreDec; .) |
  918        "!"   (. Kind := zcNot; .)
  919        /* | "~" | "*" */
  920      )
  921      (.
  922         if Kind in [zcNegate,zcNot] then
  923         begin
  924           Tmp := MakeOp(Kind);
  925           if LastOp<>nil then
  926             LastOp.Children.Add(Tmp);
  927           LastOp := Tmp;
  928         end else if Assigned(LastOp) then
  929           ZError('-- and ++ cannot be combined with other unary ops');
  930      .)
  931    }
  932    Primary<Tmp>
  933      (.
  934         if Kind in [zcNop,zcNegate,zcNot] then
  935         begin
  936           if LastOp<>nil then
  937           begin
  938             LastOp.Children.Add(Tmp);
  939             OutOp := LastOp;
  940           end else
  941             OutOp := Tmp;
  942         end else
  943         begin
  944           OutOp := MakePrePostIncDec(Kind,Tmp);
  945         end;
  946      .)
  947  .
  948  
  949  
  950  
  951  /*------------------------------------------------------------------------*/
  952  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  953  (.
  954    var
  955      Op : TZcOp;
  956      Prop : TZProperty;
  957  .)
  958  = (. OutOp := nil; Op := nil; .)
  959    ident (.
  960      Prop := Ci.GetProperties.GetByName(LexString);
  961      if Prop=nil then
  962        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
  963      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
  964        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
  965      OutOp := MakeOp(zcIdentifier);
  966      OutOp.Id := LexString;
  967    .)
  968    ":" Expr<Op>
  969    (. if Op=nil then
  970         ZError('Missing argument');
  971       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
  972       OutOp.Children.Add(Op);
  973    .)
  974  .
  975  
  976  
  977  /*------------------------------------------------------------------------*/
  978  ReinterpretCast<var OutOp : TZcOp>
  979  (.
  980  var
  981    Op : TZcOp;
  982    Typ : TZcDataType;
  983  .)
  984  = "reinterpret_cast" "<" SimpleType<Typ> ">"
  985    "(" Expr<Op> ")"
  986    (.
  987       OutOp := TZcOpReinterpretCast.Create(nil);
  988       OutOp.Children.Add(Op);
  989       (OutOp as TZcOpReinterpretCast).Typ := Typ;
  990    .)
  991  .
  992  
  993  /*------------------------------------------------------------------------*/
  994  InlineComponent<var OutOp : TZcOp>
  995  (. var Op : TZcOp;
  996       Ci : TZComponentInfo;
  997  .)
  998  =  (. OutOp := nil;
  999        IsInInvokeArg := True;
 1000     .)
 1001     "@" ident (.
 1002         Ci := ComponentManager.GetInfoFromName(LexString);
 1003         OutOp := TZcOpInvokeComponent.Create(nil);
 1004         OutOp.Id := LexString;
 1005      .)
 1006      "("
 1007          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
 1008            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
 1009            }
 1010          ]
 1011      ")" (. IsInInvokeArg := False; .)
 1012  .
 1013  
 1014  /*------------------------------------------------------------------------*/
 1015  Primary<var OutOp : TZcOp>
 1016  (. var Op : TZcOp; S : string; V : double;
 1017       Typ : TZcDataType;
 1018  .)
 1019  =            (. OutOp := nil; .)
 1020    (
 1021      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
 1022    | InlineComponent<OutOp>
 1023    | Literal<Typ>  (.
 1024          if Typ.Kind in [zctString,zctNull] then
 1025            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
 1026          else
 1027          begin
 1028            try
 1029              S := LexString;
 1030              V := ZcStrToFloat(S);
 1031              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
 1032            except on EConvertError do
 1033              SynError(200);
 1034            end;
 1035          end;
 1036       .)
 1037    | "(" Expr<OutOp> ")"
 1038  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
 1039      | "float"  | "int"    | "long" | "object"  | "sbyte"
 1040      | "short"  | "string" | "uint" | "ulong"   | "ushort"
 1041      ) "." ident */
 1042    | ReinterpretCast<OutOp>
 1043    )
 1044  
 1045    {
 1046    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
 1047    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
 1048  
 1049  /*  | "->" ident */
 1050  
 1051    | "." (. IsInIdent := True; .) ident (.
 1052  
 1053        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
 1054          ZError('Invalid use of "."');
 1055  
 1056        Op := MakeOp(zcSelect,LexString);
 1057        Op.Children.Add(OutOp);
 1058  
 1059        OutOp := CheckPrimary(Op);
 1060  
 1061        IsInIdent := False;
 1062  
 1063      .)
 1064  
 1065    | "(" (.
 1066             if (OutOp=nil) or (OutOp.Kind<>zcIdentifier) then
 1067               ZError('Unexpected "("');
 1068             OutOp.Kind:=zcFuncCall;
 1069             if OutOp.Ref=CurrentFunction then
 1070               CurrentFunction.IsRecursive := True;
 1071           .)
 1072          [Argument<Op> (. OutOp.Children.Add(Op); .)
 1073            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
 1074            }
 1075          ]
 1076          (.
 1077             if not VerifyFunctionCall(OutOp,S,CurrentFunction) then
 1078               ZError(S);
 1079          .)
 1080      ")"
 1081  
 1082    | "[" (.
 1083             if (OutOp=nil) or (not (OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall])) then
 1084               ZError('Unexpected "["');
 1085             Op := MakeArrayAccess(OutOp);
 1086             OutOp := Op;
 1087           .)
 1088  
 1089          Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
 1090            {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
 1091          "]"
 1092    }
 1093  .
 1094  /*------------------------------------------------------------------------*/
 1095  Literal<var Typ : TZcDataType>
 1096  = intCon (. Typ.Kind :=zctInt; .) |
 1097    realCon (. Typ.Kind := zctFloat; .) |
 1098    stringCon (. Typ.Kind := zctString; .)
 1099    | "null" (. Typ.Kind := zctNull; .)
 1100    /* | "true" | "false"  */
 1101  .
 1102  
 1103  END Zc.



