
Listing
-------
0 errors and 46 warnings
*****  Warning: LL1 warning in ZcFuncBody:"vec2" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"mat4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec3" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"const" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"vec4" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"xptr" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"int" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"float" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"byte" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"model" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"string" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"if" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"@" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"reinterpret_cast" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"null" is start & successor of deletable structure
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
*****  Warning: LL1 warning in Zc: contents of [...] or {...} must not be deletable
*****  Warning: LL1 warning in ZcFuncBody:"return" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"while" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"switch" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"for" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"continue" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"break" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lbrace is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:inc is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:lpar is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:not is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:minus is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:realCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:intCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:stringCon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:dec is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:ident is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:scolon is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Font" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Camera" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sample" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Component" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"File" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Sound" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Material" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Shader" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Mesh" is start & successor of deletable structure
*****  Warning: LL1 warning in ZcFuncBody:"Bitmap" is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      ReturnType : TZcDataType;
   11      AllowFunctions : boolean;
   12      GlobalNames : TObjectList;
   13      TempCounter : integer;
   14      ZApp : TZApplication;
   15      destructor Destroy; override;
   16      procedure CheckHomograph(var sym: Integer); override;
   17  .)
   18  private = (.
   19      IsInIdent,IsInInvokeArg : boolean;
   20      CurrentFunction : TZcOpFunctionUserDefined;
   21      procedure CleanUp;
   22      procedure ZError(const S : string);
   23      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      function IsConst : boolean;
   26      .)
   27  precreate = (.
   28      ZFunctions := TObjectList.Create(False);
   29      Self.OnError := OnParserError;
   30  
   31  .)
   32  
   33  semErrors = (.
   34      200 : Result := 'Not a floating point value';
   35      201 : Result := 'Name already defined in this scope';
   36      202 : Result := 'Return value expected';
   37      203 : Result := 'Function should not return a value';
   38      204 : Result := 'Only function definitions are allowed here';
   39      205 : Result := 'Syntax not supported';
   40  .)
   41  
   42  implementation = (.
   43  
   44  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   45  begin
   46    ZError(Msg + ' ' + Data);
   47  end;
   48  
   49  procedure TZc.CheckHomograph(var sym: Integer);
   50  begin
   51    //Only Homographs are name of component datatypes
   52    //If inside identifier "x.y.z" then let it refer to identifier instead
   53    if IsInIdent or IsInInvokeArg then
   54      sym := identSym;
   55  end;
   56  
   57  destructor TZc.Destroy;
   58  begin
   59    inherited;
   60    CleanUp;
   61  end;
   62  
   63  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   64  begin
   65    if Op=nil then
   66    begin
   67      if SwitchOp.HasDefault then
   68        ZError('Only one default statement is allowed.');
   69      SwitchOp.HasDefault := True;
   70    end else
   71      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   72    SwitchOp.CaseOps.Last.Children.Add( Op );
   73    Op := nil;
   74  end;
   75  
   76  procedure TZc.CleanUp;
   77  begin
   78    ZFunctions.Free;
   79  end;
   80  
   81  procedure TZc.ZError(const S : string);
   82  var
   83    E : EParseError;
   84    P : TSymbolRec;
   85  begin
   86    E := EParseError.Create(S);
   87    E.Message := S;
   88    Scanner.GetPosition(P);
   89    E.Line := P.Line;
   90    E.Col := P.Col;
   91    if (E.Line<>0) or (E.Col<>0) then
   92      E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
   93    raise E;
   94  end;
   95  
   96  function TZc.IsConst : boolean;
   97  begin
   98    Result := (CurrentInputSymbol=constSym) or
   99      ((CurrentInputSymbol=privateSym) and (Symbols[2].Id=constSym));
  100  end;
  101  
  102  .)
  103  
  104  END
  105  
  106  
  107  CHARACTERS
  108  
  109          tab                = CHR(9). /*  9 = tabulator */
  110          eol                = CHR(10). /* 10 = line feed */
  111          cr                 = CHR(13). /* 13 = carriage return */
  112          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  113  
  114          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  115          digit              = "0123456789".
  116          hexDigit           = digit + "ABCDEFabcdef".
  117          notDigit           = ANY - digit.
  118  
  119          char               = ANY - "'" - '\' - newLine.
  120          verbatimStringChar = ANY - '"'.
  121          regularStringChar  = ANY - '"' - '\' - newLine.
  122          notNewLine         = ANY - newLine .
  123  
  124  
  125  TOKENS
  126  
  127    /*--------------------------------------------------------------------------------*/
  128          intCon =
  129                  ( digit {digit}
  130                  | ("0x" | "0X") hexDigit {hexDigit}
  131                  )
  132                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  133                  .
  134    /*--------------------------------------------------------------------------------*/
  135          realCon =
  136                  "." digit {digit}
  137                  [("e" | "E") ["+" | "-"] digit {digit}]
  138                  ["F" | "f" | "D" | "d" | "M" | "m"]
  139          | digit {digit}
  140                  ( "." digit {digit}
  141                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  142                          ["F" | "f" | "D" | "d" | "M" | "m"]
  143                  | ("e" | "E") ["+" | "-"] digit {digit}
  144                          ["F" | "f" | "D" | "d" | "M" | "m"]
  145                  | "F" | "f" | "D" | "d" | "M" | "m"
  146                  ).
  147    /*--------------------------------------------------------------------------------*/
  148          stringCon =
  149                  '"'    { regularStringChar
  150            | "\'" | '\"' | "\\" | "\n"
  151            }
  152                  '"'.
  153  
  154          ident = letter { letter | digit }.
  155  
  156  
  157          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  158          and    = "&".
  159          assgn  = "=".
  160          colon  = ":".
  161          comma  = ",".
  162          dec    = "--".
  163          div    = "/".
  164          dot    = ".".
  165          eq     = "==".
  166          gt     = ">".
  167          gte    = ">=".
  168          inc    = "++".
  169          lbrace = "{".
  170          lbrack = "[".
  171          lpar   = "(".
  172          lshift = "<<".
  173          lt     = "<".
  174          lte    = "<=".
  175          minus  = "-".
  176          mod    = "%".
  177          neq    = "!=".
  178          not    = "!".
  179          or     = "|".
  180          plus   = "+".
  181          rbrace = "}".
  182          rbrack = "]".
  183          rpar   = ")".
  184          rshift = ">>".
  185          scolon = ";".
  186          tilde  = "~".
  187          times  = "*".
  188          xor    = "^".
  189  
  190  
  191  
  192  COMMENTS FROM "/*" TO "*/"
  193  COMMENTS FROM "//" TO eol
  194  
  195  IGNORE eol + cr + tab
  196  
  197  HOMOGRAPHS
  198    "Material"
  199    "Sound"
  200    "Shader" 
  201    "Bitmap" 
  202    "Mesh"
  203    "Camera" 
  204    "Font"
  205    "Sample"
  206    "File"
  207    "Component"
  208  
  209  PRODUCTIONS
  210  
  211  /*------------------------------------------------------------------------*
  212   *--------------------------- Declarations -------------------------------*
  213   *------------------------------------------------------------------------*/
  214  
  215  ZcFuncRest<Typ : TZcDataType; const Name : string; IsPrivate,IsInline : boolean>
  216  (.
  217  var
  218    Func : TZcOpFunctionUserDefined;
  219  .)
  220  =
  221       (.
  222          if SymTab.Contains(Name) then
  223            ZError('Name already defined: ' + Name);
  224  
  225          if IsPrivate then
  226            Func := TZcOpFunctionUserDefined.Create(nil)
  227          else
  228            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  229          Func.Id := Name;
  230          Func.ReturnType := Typ;
  231          Func.IsInline := IsInline;
  232          Self.CurrentFunction := Func;
  233          SymTab.PushScope;
  234          try
  235       .)
  236      [ FormalParams ] ")"
  237        (.
  238          Func.MangledName := MangleFunc(Name,CurrentFunction.Arguments.Count);
  239          if SymTab.Contains(Func.MangledName) then
  240            ZError('Name already defined: ' + Name);
  241          if IsPrivate then
  242            SymTab.AddPrevious(Func.MangledName,Func)
  243          else
  244            SymTab.AddPrevious(Func.MangledName,Func,2);
  245          ZFunctions.Add(Func);
  246        .)
  247      "{" ZcFuncBody "}"
  248          (.
  249            finally
  250              SymTab.PopScope;
  251            end;
  252          .)
  253  .
  254  
  255  
  256  Zc (. var
  257          Typ : TZcDataType;
  258          Func : TZcOpFunctionUserDefined;
  259          Name : string;
  260          IsPrivate,IsInline : boolean;
  261      .)
  262  =
  263    IF (. AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  264    {
  265      IF(. IsConst .)
  266        (. IsPrivate := False; .)
  267        [ "private" (. IsPrivate:= True; .) ]
  268        ConstantDeclarationList<IsPrivate>
  269      |
  270        (. IsPrivate := False; IsInline := False; .)
  271        [ "private" (. IsPrivate:= True; .) ]
  272        [ "inline" (. IsInline:= True; .) ]
  273        ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (. Name := LexString; .)
  274         /* Need to separate between global variable and method declarations */
  275         (
  276           "(" ZcFuncRest<Typ,Name,IsPrivate,IsInline>
  277           | GlobalVarDecl<Typ,Name,IsPrivate> ";"
  278         )
  279    }
  280    | IF (. not AllowFunctions .)
***** ^ Warning: Misplaced resolver: no LL(1) conflict
  281    {
  282  
  283    (.
  284         Func := TZcOpFunctionUserDefined.Create(nil);
  285         Func.ReturnType := Self.ReturnType;
  286         Self.CurrentFunction := Func;
  287         try
  288           SymTab.PushScope;
  289           try
  290             ZFunctions.Add(Func);
  291    .)
  292    /* A zc-expression is treated like the body of a nameless function
  293       to allow local var declarations  */
  294  
  295    ZcFuncBody
  296    (.
  297           finally
  298             SymTab.PopScope;
  299           end;
  300         except on E: Exception do
  301           ZError(E.Message);
  302         end;
  303    .)
  304    }
  305  
  306  .
  307  
  308  /*------------------------------------------------------------------------*/
  309  
  310  ZcFuncBody (. var Op : TZcOp; .)
  311  =  {  (. Op:=nil; .)
  312        Statement<Op>
  313        (. if Op<>nil then
  314             CurrentFunction.Statements.Add(Op);
  315           Op := nil;
  316        .)
  317     }
  318  .
  319  
  320  /*------------------------------------------------------------------------*/
  321  FormalParams
  322  = ( Par ["," FormalParams] )
  323  .
  324  /*------------------------------------------------------------------------*/
  325  Par (.
  326  var
  327    Typ : TZcDataType;
  328    Arg : TZcOpArgumentVar;
  329    IsPtr : boolean;
  330  .)
  331  =  (. IsPtr := False; .)
  332    ["ref" (. IsPtr := True; .) ]
  333    Type<Typ> ident
  334       (.
  335          Typ.IsPointer := IsPtr;
  336          if SymTab.ScopeContains(LexString) then
  337            SynError(201)
  338          else
  339          begin
  340            Arg := TZcOpArgumentVar.Create;
  341            Arg.Id := LexString;
  342            Arg.Typ := Typ;
  343            CurrentFunction.AddArgument(Arg);
  344            SymTab.Add(Arg.Id,Arg);
  345          end;
  346       .)
  347  .
  348  /*------------------------------------------------------------------------*/
  349  
  350  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  351  = (. OutOp := nil; .)
  352    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  353  .
  354  
  355  /*------------------------------------------------------------------------*/
  356  
  357  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  358  = ident
  359       (. 
  360          if SymTab.ScopeContains(LexString) then
  361            ZError('Name already defined: ' + LexString);
  362  
  363          Loc := TZcOpLocalVar.Create(nil);
  364          Loc.Id := LexString;
  365          Loc.Typ := Typ;
  366       .)
  367       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  368       (.
  369          SymTab.Add(Loc.Id,Loc);
  370          CurrentFunction.AddLocal(Loc);
  371  
  372          if Assigned(Loc.InitExpression) then
  373          begin
  374            //Generate tree for initial assignment
  375            if OutOp=nil then
  376              OutOp := MakeOp(zcBlock);
  377            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  378          end;
  379  
  380       .)
  381  .
  382  
  383  /*------------------------------------------------------------------------*/
  384  
  385  GlobalVarRest<Typ : TZcDataType; const Name : string; IsPrivate : boolean> (. var V : TDefineVariableBase; .)
  386  =
  387       (.
  388          if SymTab.ScopeContains(Name) then
  389            ZError('Name already defined: ' + Name);
  390  
  391          if Typ.Kind=zctArray then
  392          begin
  393            TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
  394            V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
  395            V._ReferenceClassId := Typ.ReferenceClassId;
  396            Self.ZApp.GlobalVars.AddComponent(V);
  397          end
  398          else
  399          begin
  400            V := TDefineVariable.Create(Self.ZApp.GlobalVars);
  401            V._Type := Typ.Kind;
  402            V._ReferenceClassId := Typ.ReferenceClassId;
  403          end;
  404  
  405          V.SetString('Name', AnsiString(Name));
  406          V.DesignerReset; //Needed to init managed variables
  407          if IsPrivate then
  408            SymTab.Add(Name,V)
  409          else
  410            SymTab.AddPrevious(Name,V);
  411       .)
  412  .
  413  
  414  
  415  GlobalVar<Typ : TZcDataType; IsPrivate : boolean>
  416  = ident GlobalVarRest<Typ,LexString,IsPrivate>
  417  .
  418  
  419  GlobalVarDecl<Typ : TZcDataType; const Name : string; IsPrivate : boolean>
  420  = GlobalVarRest<Typ,Name,IsPrivate> {"," GlobalVar<Typ,IsPrivate>}
  421  .
  422  
  423  /*------------------------------------------------------------------------*/
  424  
  425  Init<var OutOp : TZcOp>
  426  = Expr<OutOp>
  427  .
  428  
  429  /*------------------------------------------------------------------------*/
  430  Argument<var OutOp : TZcOp>
  431  = /* ["ref" | "out"] */
  432    (. OutOp := nil; .)
  433    Expr<OutOp>
  434    (. if OutOp=nil then ZError('Missing argument'); .)
  435  .
  436  
  437  /*------------------------------------------------------------------------*
  438   *-------------------------------- Types ---------------------------------*
  439   *------------------------------------------------------------------------*/
  440  
  441  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  442   * and for array creation expressions                                     */
  443  
  444  
  445  Type<var Typ : TZcDataType>
  446  (.
  447    var
  448      A : TDefineArray;
  449      SizeOp : TZcOp;
  450      I : integer;
  451  .)
  452  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  453    ( SimpleType<Typ> )
  454    {
  455      (
  456        "["       (.
  457                     A := TDefineArray.Create(nil);
  458                     GlobalNames.Add(A);
  459                     A._Type := Typ.Kind;
  460                     Typ.Kind := zctArray;
  461                     Typ.TheArray := A;
  462                  .)
  463  
  464           [ Expr<SizeOp> (.
  465              SizeOp := SizeOp.Optimize;
  466              if SizeOp.Kind<>zcConstLiteral then
  467                ZError('Array size must be a constant expression');
  468              A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
  469                           .)
  470           ]
  471  
  472           { ","  (. if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); .)
  473             [ Expr<SizeOp> (.
  474                  SizeOp := SizeOp.Optimize;
  475                  if SizeOp.Kind<>zcConstLiteral then
  476                    ZError('Array size must be a constant expression');
  477                 I := Trunc( (SizeOp as TZcOpLiteral).Value );
  478                 if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
  479             .) ]
  480           }
  481         "]"
  482      )
  483    }
  484  .
  485  
  486  /*------------------------------------------------------------------------*/
  487  
  488  SimpleType<var Typ : TZcDataType>
  489  (.
  490    var
  491      A : TDefineArray;
  492  .)
  493  /* = IntType | "float" | "double" | "decimal" | "bool" */
  494  = "float" (. Typ.Kind := zctFloat; .)
  495    | "int" (. Typ.Kind := zctInt; .)
  496    | "byte" (. Typ.Kind := zctByte; .)
  497    | "string" (. Typ.Kind := zctString; .)
  498    | "model" (. Typ.Kind := zctModel; .)
  499    | "xptr" (. Typ.Kind := zctXptr; .)
  500  
  501    | "mat4" (.
  502       A := Prototypes.Mat4Array;
  503       Typ.Kind := zctMat4;
  504       Typ.TheArray := A;
  505      .)
  506    | "vec2" (.
  507       A := Prototypes.Vec2Array;
  508       Typ.Kind := zctVec2;
  509       Typ.TheArray := A;
  510    .)
  511    | "vec3" (.
  512       A := Prototypes.Vec3Array;
  513       Typ.Kind := zctVec3;
  514       Typ.TheArray := A;
  515    .)
  516    | "vec4" (.
  517       A := Prototypes.Vec4Array;
  518       Typ.Kind := zctVec4;
  519       Typ.TheArray := A;
  520    .)
  521  
  522    /* Changes below also must be made in homographs-section */
  523    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  524    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  525    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  526    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  527    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  528    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  529    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  530    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  531    | "File" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; .)
  532  
  533    | "Component" (. Typ.Kind := zctReference; Typ.ReferenceClassId := AnyComponentClassId; .)
  534  .
  535  
  536  /*------------------------------------------------------------------------*/
  537  
  538  /* IntType
  539  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  540  . */
  541  
  542  
  543  ConstantDeclarationList<IsPrivate : boolean>
  544  (.
  545  var
  546    Typ : TZcDataType;
  547  .)
  548  = "const" Type<Typ> ConstantDeclaration<Typ,IsPrivate> {"," ConstantDeclaration<Typ,IsPrivate> }
  549    ";"
  550  .
  551  
  552  ConstantDeclaration<var Typ : TZcDataType; IsPrivate : boolean>
  553  (.
  554  var
  555    Cns : TDefineConstant;
  556    Op : TZcOp;
  557    Lit : TZcOpLiteral;
  558    CnsName : string;
  559  .)
  560  =
  561  ident (. CnsName := LexString; .) "=" Expr<Op>
  562    (.
  563     if not (Typ.Kind in [zctByte,zctInt,zctFloat,zctString]) then
  564       ZError('Only byte, int, float and string constants are allowed');
  565  
  566     Op := Op.Optimize;
  567     if not (Op is TZcOpLiteral) then
  568       ZError('Constant expression expected: ' + Op.ToString);
  569  
  570     Lit := Op as TZcOpLiteral;
  571  
  572     if (Lit.Typ.Kind<>Typ.Kind) and not ((Typ.Kind=zctByte) and (Lit.Typ.Kind=zctInt))then
  573       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  574  
  575     Cns := TDefineConstant.Create(nil);
  576     Cns.SetString('Name',AnsiString(CnsName));
  577     GlobalNames.Add(Cns);
  578  
  579     case Typ.Kind of
  580       zctByte:
  581         begin
  582           Cns._Type := zctByte;
  583           Cns.ByteValue := Round(Lit.Value);
  584         end;
  585       zctInt:
  586         begin
  587           Cns._Type := zctInt;
  588           Cns.IntValue := Round(Lit.Value);
  589         end;
  590       zctFloat:
  591         begin
  592           Cns._Type := zctFloat;
  593           Cns.Value := Lit.Value;
  594         end;
  595       zctString:
  596         begin
  597           Cns._Type := zctString;
  598           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  599         end;
  600       else
  601         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  602     end;
  603     if IsPrivate then
  604       SymTab.Add(CnsName,Cns)
  605     else
  606       SymTab.AddPrevious(CnsName,Cns)
  607    .)
  608  /* {"," ident "=" Expr<Op>} */
  609  .
  610  
  611  /*------------------------------------------------------------------------*
  612   *------------------------------ Statements ------------------------------*
  613   *------------------------------------------------------------------------*/
  614  
  615  Statement<var OutOp : TZcOp>
  616  = (. OutOp := nil; .)
  617  
  618  ConstantDeclarationList<false>
  619  
  620  /*IF IsLocalVarDecl THEN
  621  BEGIN
  622    LocalVarDecl ";"
  623  END
  624  |  EmbeddedStatement<OutOp> */
  625  
  626  | LocalVarDecl<OutOp> ";"
  627  | EmbeddedStatement<OutOp>
  628    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  629     * ident {"." ident} { "[" ...                           */
  630  .
  631  
  632  /*------------------------------------------------------------------------*/
  633  EmbeddedStatement<var OutOp : TZcOp>
  634    (. var
  635         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  636         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  637         WhileCondOp,WhileBodyOp : TZcOp;
  638         SwitchOp : TZcOpSwitch;
  639         Loc : TZcOpLocalVar;
  640    .)
  641  = Block<OutOp>
  642  | ";"   (. OutOp := MakeOp(zcNop); .)
  643  | StatementExpr<OutOp> ";"
  644  | "if" (. ElseOp := nil; .)
  645    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  646          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  647   | "switch" "(" Expr<SwitchValueOp> ")"
  648        (.
  649           OutOp := MakeOp(zcBlock);
  650  
  651           SwitchOp := TZcOpSwitch.Create(nil);
  652  
  653           if (SwitchValueOp.Ref is TZcOpVariableBase) or (SwitchValueOp.Kind=zcConstLiteral) then
  654             SwitchOp.ValueOp := SwitchValueOp
  655           else
  656           begin
  657             Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
  658             SymTab.Add(Loc.Id,Loc);
  659             CurrentFunction.AddLocal(Loc);
  660             OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  661             SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  662           end;
  663  
  664           OutOp.Children.Add(SwitchOp);
  665        .)
  666     "{" {
  667       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  668       SwitchSection<SwitchOp>
  669     } "}"
  670   | "while"
  671       (. try
  672           SymTab.PushScope;
  673           WhileCondOp := nil; WhileBodyOp := nil; .)
  674     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  675     (.
  676           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  677         finally
  678           SymTab.PopScope;
  679         end;
  680     .)
  681   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  682   | "for"
  683      (. try
  684           SymTab.PushScope;
  685           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  686     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  687     (.
  688           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  689         finally
  690           SymTab.PopScope;
  691         end;
  692     .)
  693  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  694   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  695   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  696   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  697      (.
  698          if (Op=nil) then
  699          begin
  700            if CurrentFunction.ReturnType.Kind<>zctVoid then
  701              SynError(202)
  702            else
  703              OutOp := MakeOp(zcReturn);
  704          end else
  705          begin
  706            if CurrentFunction.ReturnType.Kind=zctVoid then
  707              SynError(203)
  708            else
  709              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  710          end;
  711          Inc(CurrentFunction.ReturnCount);
  712      .)
  713  .
  714  /*------------------------------------------------------------------------*/
  715  
  716  Block<var OutOp : TZcOp>
  717    (. var
  718         Op : TZcOp;
  719    .)
  720  = (. Op := nil;
  721       OutOp := MakeOp(zcBlock);
  722    .)
  723    "{" {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) } "}".
  724  
  725  /*------------------------------------------------------------------------*/
  726  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  727  = (. Op1 :=nil; Op2 := nil; .)
  728    Unary<Op1>
  729    ( AssignOp<Kind> Expr<Op2>
  730      (.
  731        if Op2<>nil then
  732          OutOp := MakeAssign(Kind,Op1,Op2);
  733      .)
  734    |                             (. OutOp := Op1; .)
  735    )
  736  .
  737  
  738  /*------------------------------------------------------------------------*/
  739  AssignOp<var Kind : TZcAssignType>
  740  = "="     (. Kind := atAssign; .)
  741    | "+="  (. Kind := atPlusAssign; .)
  742    | "-="  (. Kind := atMinusAssign; .)
  743    | "*="  (. Kind := atMulAssign; .)
  744    | "/="  (. Kind := atDivAssign; .)
  745  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  746  .
  747  
  748  /*------------------------------------------------------------------------*/
  749  
  750  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  751  = (. Op := nil; .)
  752    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  753    {
  754      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  755    }
  756    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  757    {
  758       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  759    }
  760  .
  761  
  762  /*------------------------------------------------------------------------*/
  763  
  764  SwitchLabel<var OutOp : TZcOp>
  765  = "case" Expr<OutOp> ":"
  766  | "default" ":"
  767  .
  768  
  769  /*------------------------------------------------------------------------*/
  770  
  771  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  772  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  773  (
  774  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  775  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  776    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  777  )
  778  .  
  779  
  780  /*------------------------------------------------------------------------*/
  781  
  782  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  783  = (. Op:=nil; 
  784       OutOp := MakeOp(zcBlock);
  785    .) 
  786  (
  787  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  788  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  789  )
  790  . 
  791  
  792  
  793  /*------------------------------------------------------------------------*
  794   *----------------------------- Expressions ------------------------------*
  795   *------------------------------------------------------------------------*/
  796  
  797  
  798  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  799  = (. Op1 :=nil; Op2 := nil; .)
  800    Unary<Op1>
  801    ( OrExpr<Op1,OutOp>
  802        ["?" Expr<Op1> ":" Expr<Op2>
  803           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  804                SynError(205)
  805              else
  806                OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
  807           .)
  808        ]
  809    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  810    )
  811  .
  812  /*------------------------------------------------------------------------*/
  813  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  814  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  815      {"||" Unary<Op> AndExpr<Op,R>
  816        (. OutOp := MakeOp(zcOr,[L,R]);
  817           L := OutOp; .)
  818      }
  819  .
  820  
  821  
  822  /*------------------------------------------------------------------------*/
  823  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  824  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  825      {"&&" Unary<Op> BitOrExpr<Op,R>
  826        (. OutOp := MakeOp(zcAnd,[L,R]);
  827           L := OutOp; .)
  828      }
  829  .
  830  /*------------------------------------------------------------------------*/
  831  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  832  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  833    {"|" Unary<Op> BitXorExpr<Op,R>
  834      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  835         L := OutOp; .)
  836    }
  837  .
  838  
  839  /*------------------------------------------------------------------------*/
  840  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  841  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  842    {"^" Unary<Op> BitAndExpr<Op,R>
  843      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  844         L := OutOp; .)
  845    }
  846  .
  847  
  848  /*------------------------------------------------------------------------*/
  849  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  850  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  851    {"&" Unary<Op> EqlExpr<Op,R>
  852      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  853         L := OutOp; .)
  854    }
  855  .
  856  
  857  /*------------------------------------------------------------------------*/
  858  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  859  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  860    {( "!="   (. Kind := zcCompNE; .)
  861     | "=="   (. Kind := zcCompEQ; .)
  862     )
  863     Unary<Op> RelExpr<Op,R>
  864           (. OutOp := MakeBinary(Kind, L,R);
  865              L := OutOp;
  866           .)
  867    }
  868  .
  869  /*------------------------------------------------------------------------*/
  870  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  871  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  872    { ( "<"       (. Kind := zcCompLT; .)
  873      | ">"       (. Kind := zcCompGT; .)
  874      | "<="      (. Kind := zcCompLE; .)
  875      | ">="      (. Kind := zcCompGE; .)
  876       )
  877      Unary<Op> ShiftExpr<Op,R>
  878           (. OutOp := MakeBinary(Kind, L,R );
  879              L := OutOp;
  880           .)
  881    }
  882  .
  883  /*------------------------------------------------------------------------*/
  884  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  885  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  886    { ("<<"  (. Kind := zcBinaryShiftL; .)
  887      | ">>" (. Kind := zcBinaryShiftR; .)
  888      )
  889      Unary<Op> AddExpr<Op,R>
  890      (. OutOp := MakeOp(Kind,[L,R]);
  891         L := OutOp; .)
  892    }
  893  .
  894  /*------------------------------------------------------------------------*/
  895  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  896  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
  897      {( "+"    (. Kind := zcPlus; .)
  898       | "-"    (. Kind := zcMinus; .)
  899       ) Unary<Op> MulExpr<Op,R>
  900           (. 
  901              if (L=nil) or (R=nil) then
  902                ZError('Invalid syntax');
  903              OutOp := MakeBinary(Kind,L,R);
  904              L := OutOp;
  905           .)
  906      }
  907  .
  908  /*------------------------------------------------------------------------*/
  909  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  910  = (. OutOp := InOp; Kind := zcNop; .)
  911    { ("*"      (. Kind := zcMul; .)
  912      | "/"     (. Kind := zcDiv; .)
  913      | "%"     (. Kind := zcMod; .)
  914      ) Unary<Tmp>
  915           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  916              InOp := OutOp;
  917           .)
  918      }
  919  .
  920  /*------------------------------------------------------------------------*/
  921  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  922  =       (. LastOp := nil; Kind := zcNop; .)
  923    {
  924      (
  925        /* "+" | */
  926        "-"   (. Kind := zcNegate; .) |
  927        "++"  (. Kind := zcPreInc; .) |    
  928        "--"  (. Kind := zcPreDec; .) |
  929        "!"   (. Kind := zcNot; .)
  930        /* | "~" | "*" */
  931      )
  932      (.
  933         if Kind in [zcNegate,zcNot] then
  934         begin
  935           Tmp := MakeOp(Kind);
  936           if LastOp<>nil then
  937             LastOp.Children.Add(Tmp);
  938           LastOp := Tmp;
  939         end else if Assigned(LastOp) then
  940           ZError('-- and ++ cannot be combined with other unary ops');
  941      .)
  942    }
  943    Primary<Tmp>
  944      (.
  945         if Kind in [zcNop,zcNegate,zcNot] then
  946         begin
  947           if LastOp<>nil then
  948           begin
  949             LastOp.Children.Add(Tmp);
  950             OutOp := LastOp;
  951           end else
  952             OutOp := Tmp;
  953         end else
  954         begin
  955           OutOp := MakePrePostIncDec(Kind,Tmp);
  956         end;
  957      .)
  958  .
  959  
  960  
  961  
  962  /*------------------------------------------------------------------------*/
  963  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  964  (.
  965    var
  966      Op : TZcOp;
  967      Prop : TZProperty;
  968  .)
  969  = (. OutOp := nil; Op := nil; .)
  970    ident (.
  971      Prop := Ci.GetProperties.GetByName(LexString);
  972      if Prop=nil then
  973        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
  974      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
  975        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
  976      OutOp := MakeOp(zcIdentifier);
  977      OutOp.Id := LexString;
  978    .)
  979    ":" Expr<Op>
  980    (. if Op=nil then
  981         ZError('Missing argument');
  982       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
  983       OutOp.Children.Add(Op);
  984    .)
  985  .
  986  
  987  
  988  /*------------------------------------------------------------------------*/
  989  ReinterpretCast<var OutOp : TZcOp>
  990  (.
  991  var
  992    Op : TZcOp;
  993    Typ : TZcDataType;
  994  .)
  995  = "reinterpret_cast" "<" SimpleType<Typ> ">"
  996    "(" Expr<Op> ")"
  997    (.
  998       OutOp := TZcOpReinterpretCast.Create(nil);
  999       OutOp.Children.Add(Op);
 1000       (OutOp as TZcOpReinterpretCast).Typ := Typ;
 1001    .)
 1002  .
 1003  
 1004  /*------------------------------------------------------------------------*/
 1005  InlineComponent<var OutOp : TZcOp>
 1006  (. var Op : TZcOp;
 1007       Ci : TZComponentInfo;
 1008  .)
 1009  =  (. OutOp := nil;
 1010        IsInInvokeArg := True;
 1011     .)
 1012     "@" ident (.
 1013         Ci := ComponentManager.GetInfoFromName(LexString);
 1014         OutOp := TZcOpInvokeComponent.Create(nil);
 1015         OutOp.Id := LexString;
 1016      .)
 1017      "("
 1018          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
 1019            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
 1020            }
 1021          ]
 1022      ")" (. IsInInvokeArg := False; .)
 1023  .
 1024  
 1025  /*------------------------------------------------------------------------*/
 1026  Primary<var OutOp : TZcOp>
 1027  (. var Op : TZcOp; S : string; V : double;
 1028       Typ : TZcDataType;
 1029  .)
 1030  =            (. OutOp := nil; .)
 1031    (
 1032      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
 1033    | InlineComponent<OutOp>
 1034    | Literal<Typ>  (.
 1035          if Typ.Kind in [zctString,zctNull] then
 1036            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
 1037          else
 1038          begin
 1039            try
 1040              S := LexString;
 1041              V := ZcStrToFloat(S);
 1042              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
 1043            except on EConvertError do
 1044              SynError(200);
 1045            end;
 1046          end;
 1047       .)
 1048    | "(" Expr<OutOp> ")"
 1049  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
 1050      | "float"  | "int"    | "long" | "object"  | "sbyte"
 1051      | "short"  | "string" | "uint" | "ulong"   | "ushort"
 1052      ) "." ident */
 1053    | ReinterpretCast<OutOp>
 1054    )
 1055  
 1056    {
 1057    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
 1058    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
 1059  
 1060  /*  | "->" ident */
 1061  
 1062    | "." (. IsInIdent := True; .) ident (.
 1063  
 1064        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
 1065          ZError('Invalid use of "."');
 1066  
 1067        Op := MakeOp(zcSelect,LexString);
 1068        Op.Children.Add(OutOp);
 1069  
 1070        OutOp := CheckPrimary(Op);
 1071  
 1072        IsInIdent := False;
 1073  
 1074      .)
 1075  
 1076    | "(" (.
 1077             if (OutOp=nil) or (OutOp.Kind<>zcIdentifier) then
 1078               ZError('Unexpected "("');
 1079             OutOp.Kind:=zcFuncCall;
 1080           .)
 1081          [Argument<Op> (. OutOp.Children.Add(Op); .)
 1082            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
 1083            }
 1084          ]
 1085          (.
 1086             if not VerifyFunctionCall(OutOp,S,CurrentFunction) then
 1087               ZError(S);
 1088          .)
 1089      ")"
 1090  
 1091    | "[" (.
 1092             if (OutOp=nil) or (not (OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall])) then
 1093               ZError('Unexpected "["');
 1094             Op := MakeArrayAccess(OutOp);
 1095             OutOp := Op;
 1096           .)
 1097  
 1098          Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
 1099            {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
 1100          "]"
 1101    }
 1102  .
 1103  /*------------------------------------------------------------------------*/
 1104  Literal<var Typ : TZcDataType>
 1105  = intCon (. Typ.Kind :=zctInt; .) |
 1106    realCon (. Typ.Kind := zctFloat; .) |
 1107    stringCon (. Typ.Kind := zctString; .)
 1108    | "null" (. Typ.Kind := zctNull; .)
 1109    /* | "true" | "false"  */
 1110  .
 1111  
 1112  END Zc.



