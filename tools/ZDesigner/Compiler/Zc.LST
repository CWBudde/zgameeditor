
Listing
-------
0 errors and 1 warnings
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      AllowInitializer : boolean;
   11      GlobalNames : TObjectList;
   12      TempCounter : integer;
   13      ZApp : TZApplication;
   14      InitializerFunction : TZcOpFunctionUserDefined;
   15      destructor Destroy; override;
   16      procedure CheckHomograph(var sym: Integer); override;
   17  .)
   18  private = (.
   19      IsInIdent,IsInInvokeArg : boolean;
   20      CurrentFunction : TZcOpFunctionUserDefined;
   21      procedure CleanUp;
   22      procedure ZError(const S : string);
   23      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      function IsConst : boolean;
   26      function GetInitializer : TZcOpFunctionUserDefined;
   27      .)
   28  precreate = (.
   29      ZFunctions := TObjectList.Create(False);
   30      Self.OnError := OnParserError;
   31  
   32  .)
   33  
   34  semErrors = (.
   35      200 : Result := 'Not a floating point value';
   36      201 : Result := 'Name already defined in this scope';
   37      202 : Result := 'Return value expected';
   38      203 : Result := 'Function should not return a value';
   39      204 : Result := 'Only function definitions are allowed here';
   40      205 : Result := 'Syntax not supported';
   41  .)
   42  
   43  implementation = (.
   44  
   45  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   46  begin
   47    ZError(Msg + ' ' + Data);
   48  end;
   49  
   50  procedure TZc.CheckHomograph(var sym: Integer);
   51  begin
   52    //Only Homographs are name of component datatypes
   53    //If inside identifier "x.y.z" then let it refer to identifier instead
   54    if IsInIdent or IsInInvokeArg then
   55      sym := identSym;
   56  end;
   57  
   58  destructor TZc.Destroy;
   59  begin
   60    inherited;
   61    CleanUp;
   62  end;
   63  
   64  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   65  begin
   66    if Op=nil then
   67    begin
   68      if SwitchOp.HasDefault then
   69        ZError('Only one default statement is allowed.');
   70      SwitchOp.HasDefault := True;
   71    end else
   72      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   73    SwitchOp.CaseOps.Last.Children.Add( Op );
   74    Op := nil;
   75  end;
   76  
   77  procedure TZc.CleanUp;
   78  begin
   79    ZFunctions.Free;
   80  end;
   81  
   82  procedure TZc.ZError(const S : string);
   83  var
   84    E : EParseError;
   85    P : TSymbolRec;
   86  begin
   87    E := EParseError.Create(S);
   88    E.Message := S;
   89    Scanner.GetPosition(P);
   90    E.Line := P.Line;
   91    E.Col := P.Col;
   92    if (E.Line<>0) or (E.Col<>0) then
   93      E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
   94    raise E;
   95  end;
   96  
   97  function TZc.IsConst : boolean;
   98  begin
   99    Result := (CurrentInputSymbol=constSym) or
  100      ((CurrentInputSymbol=privateSym) and (Symbols[2].Id=constSym));
  101  end;
  102  
  103  function TZc.GetInitializer : TZcOpFunctionUserDefined;
  104  begin
  105    if not Self.AllowInitializer then
  106      ZError('Initializers only allowed in ZLibrary components located in App.OnLoaded');
  107    if not Assigned(InitializerFunction) then
  108    begin
  109      Self.InitializerFunction := TZcOpFunctionUserDefined.Create(nil);
  110      Self.ZFunctions.Insert(0,Self.InitializerFunction);
  111    end;
  112    Result := Self.InitializerFunction;
  113  end;
  114  
  115  .)
  116  
  117  END
  118  
  119  
  120  CHARACTERS
  121  
  122          tab                = CHR(9). /*  9 = tabulator */
  123          eol                = CHR(10). /* 10 = line feed */
  124          cr                 = CHR(13). /* 13 = carriage return */
  125          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  126  
  127          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  128          digit              = "0123456789".
  129          hexDigit           = digit + "ABCDEFabcdef".
  130          notDigit           = ANY - digit.
  131  
  132          char               = ANY - "'" - '\' - newLine.
  133          verbatimStringChar = ANY - '"'.
  134          regularStringChar  = ANY - '"' - '\' - newLine.
  135          notNewLine         = ANY - newLine .
  136  
  137  
  138  TOKENS
  139  
  140    /*--------------------------------------------------------------------------------*/
  141          intCon =
  142                  ( digit {digit}
  143                  | ("0x" | "0X") hexDigit {hexDigit}
  144                  )
  145                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  146                  .
  147    /*--------------------------------------------------------------------------------*/
  148          realCon =
  149                  "." digit {digit}
  150                  [("e" | "E") ["+" | "-"] digit {digit}]
  151                  ["F" | "f" | "D" | "d" | "M" | "m"]
  152          | digit {digit}
  153                  ( "." digit {digit}
  154                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  155                          ["F" | "f" | "D" | "d" | "M" | "m"]
  156                  | ("e" | "E") ["+" | "-"] digit {digit}
  157                          ["F" | "f" | "D" | "d" | "M" | "m"]
  158                  | "F" | "f" | "D" | "d" | "M" | "m"
  159                  ).
  160    /*--------------------------------------------------------------------------------*/
  161          stringCon =
  162                  '"'    { regularStringChar
  163            | "\'" | '\"' | "\\" | "\n"
  164            }
  165                  '"'.
  166  
  167          ident = letter { letter | digit }.
  168  
  169  
  170          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  171          and    = "&".
  172          assgn  = "=".
  173          colon  = ":".
  174          comma  = ",".
  175          dec    = "--".
  176          div    = "/".
  177          dot    = ".".
  178          eq     = "==".
  179          gt     = ">".
  180          gte    = ">=".
  181          inc    = "++".
  182          lbrace = "{".
  183          lbrack = "[".
  184          lpar   = "(".
  185          lshift = "<<".
  186          lt     = "<".
  187          lte    = "<=".
  188          minus  = "-".
  189          mod    = "%".
  190          neq    = "!=".
  191          not    = "!".
  192          or     = "|".
  193          plus   = "+".
  194          rbrace = "}".
  195          rbrack = "]".
  196          rpar   = ")".
  197          rshift = ">>".
  198          scolon = ";".
  199          tilde  = "~".
  200          times  = "*".
  201          xor    = "^".
  202  
  203  
  204  
  205  COMMENTS FROM "/*" TO "*/"
  206  COMMENTS FROM "//" TO eol
  207  
  208  IGNORE eol + cr + tab
  209  
  210  HOMOGRAPHS
  211    "Material"
  212    "Sound"
  213    "Shader" 
  214    "Bitmap" 
  215    "Mesh"
  216    "Camera" 
  217    "Font"
  218    "Sample"
  219    "File"
  220    "Component"
  221  
  222  PRODUCTIONS
  223  
  224  /*------------------------------------------------------------------------*
  225   *--------------------------- Declarations -------------------------------*
  226   *------------------------------------------------------------------------*/
  227  
  228  ZcFuncRest<Typ : TZcDataType; const Name : string; IsPrivate,IsInline : boolean>
  229  (.
  230  var
  231    Func : TZcOpFunctionUserDefined;
  232  .)
  233  =
  234       (.
  235          if SymTab.Contains(Name) then
  236            ZError('Name already defined: ' + Name);
  237  
  238          if IsPrivate then
  239            Func := TZcOpFunctionUserDefined.Create(nil)
  240          else
  241            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  242          Func.Id := Name;
  243          Func.ReturnType := Typ;
  244          Func.IsInline := IsInline;
  245          Self.CurrentFunction := Func;
  246          SymTab.PushScope;
  247          try
  248       .)
  249      [ FormalParams ] ")"
  250        (.
  251          Func.MangledName := MangleFunc(Name,CurrentFunction.Arguments.Count);
  252          if SymTab.Contains(Func.MangledName) then
  253            ZError('Name already defined: ' + Name);
  254          if IsPrivate then
  255            SymTab.AddPrevious(Func.MangledName,Func)
  256          else
  257            SymTab.AddPrevious(Func.MangledName,Func,2);
  258          ZFunctions.Add(Func);
  259        .)
  260      "{" ZcFuncBody "}"
  261          (.
  262            finally
  263              SymTab.PopScope;
  264            end;
  265          .)
  266  .
  267  
  268  
  269  Zc (. var
  270          Typ : TZcDataType;
  271          Name : string;
  272          IsPrivate,IsInline : boolean;
  273          Op : TZcOp;
  274      .)
  275  =
  276    {
  277      IF(. IsConst .)
  278        (. IsPrivate := False; .)
  279        [ "private" (. IsPrivate:= True; .) ]
  280        ConstantDeclarationList<IsPrivate>
  281      |
  282        (. IsPrivate := False; IsInline := False; .)
  283        [ "private" (. IsPrivate:= True; .) ]
  284        [ "inline" (. IsInline:= True; .) ]
  285        ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (. Name := LexString; .)
  286         /* Need to separate between global variable and method declarations */
  287         (
  288           "(" ZcFuncRest<Typ,Name,IsPrivate,IsInline>
  289           | GlobalVarDecl<Typ,Name,IsPrivate> ";"
  290         )
  291      |
  292        (. CurrentFunction := GetInitializer; .)
  293        Block<Op>
  294        (. GetInitializer.Statements.Add(Op); CurrentFunction := nil; .)
  295    }
  296  
  297  .
  298  
  299  /*------------------------------------------------------------------------*/
  300  
  301  ZcFuncBody (. var Op : TZcOp; .)
  302  =  {  (. Op:=nil; .)
  303        Statement<Op>
  304        (. if Op<>nil then
  305             CurrentFunction.Statements.Add(Op);
  306           Op := nil;
  307        .)
  308     }
  309  .
  310  
  311  /*------------------------------------------------------------------------*/
  312  FormalParams
  313  = ( Par ["," FormalParams] )
  314  .
  315  /*------------------------------------------------------------------------*/
  316  Par (.
  317  var
  318    Typ : TZcDataType;
  319    Arg : TZcOpArgumentVar;
  320    IsPtr : boolean;
  321  .)
  322  =  (. IsPtr := False; .)
  323    ["ref" (. IsPtr := True; .) ]
  324    Type<Typ> ident
  325       (.
  326          Typ.IsPointer := IsPtr;
  327          if SymTab.ScopeContains(LexString) then
  328            SynError(201)
  329          else
  330          begin
  331            Arg := TZcOpArgumentVar.Create;
  332            Arg.Id := LexString;
  333            Arg.Typ := Typ;
  334            CurrentFunction.AddArgument(Arg);
  335            SymTab.Add(Arg.Id,Arg);
  336          end;
  337       .)
  338  .
  339  /*------------------------------------------------------------------------*/
  340  
  341  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  342  = (. OutOp := nil; .)
  343    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  344  .
  345  
  346  /*------------------------------------------------------------------------*/
  347  
  348  LocalVar<Typ : TZcDataType; var OutOp : TZcOp> (. var Loc : TZcOpLocalVar; InitOp : TZcOp; .)
  349  = ident
  350       (. 
  351          if SymTab.ScopeContains(LexString) then
  352            ZError('Name already defined: ' + LexString);
  353  
  354          Loc := TZcOpLocalVar.Create(nil);
  355          Loc.Id := LexString;
  356          Loc.Typ := Typ;
  357       .)
  358       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  359       (.
  360          SymTab.Add(Loc.Id,Loc);
  361          CurrentFunction.AddLocal(Loc);
  362  
  363          if Assigned(Loc.InitExpression) then
  364          begin
  365            //Generate tree for initial assignment
  366            if OutOp=nil then
  367              OutOp := MakeOp(zcBlock);
  368            OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),Loc.InitExpression) );
  369          end;
  370  
  371       .)
  372  .
  373  
  374  /*------------------------------------------------------------------------*/
  375  
  376  GlobalVarRest<Typ : TZcDataType; const Name : string; IsPrivate : boolean>
  377  (. var V : TDefineVariableBase; InitOp : TZcOp; .)
  378  =
  379       (.
  380          if SymTab.ScopeContains(Name) then
  381            ZError('Name already defined: ' + Name);
  382  
  383          if Typ.Kind=zctArray then
  384          begin
  385            TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
  386            V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
  387            V._ReferenceClassId := Typ.ReferenceClassId;
  388            Self.ZApp.GlobalVars.AddComponent(V);
  389          end
  390          else
  391          begin
  392            V := TDefineVariable.Create(Self.ZApp.GlobalVars);
  393            V._Type := Typ.Kind;
  394            V._ReferenceClassId := Typ.ReferenceClassId;
  395          end;
  396  
  397          V.SetString('Name', AnsiString(Name));
  398          V.DesignerReset; //Needed to init managed variables
  399          if IsPrivate then
  400            SymTab.Add(Name,V)
  401          else
  402            SymTab.AddPrevious(Name,V);
  403       .)
  404       [ "=" Init<InitOp> (.
  405         GetInitializer.Statements.Add( MakeAssign(atAssign, CheckPrimary( MakeIdentifier(Name) ),InitOp) );
  406         .)
  407       ]
  408  .
  409  
  410  
  411  GlobalVar<Typ : TZcDataType; IsPrivate : boolean>
  412  =
  413    ident GlobalVarRest<Typ,LexString,IsPrivate>
  414  .
  415  
  416  GlobalVarDecl<Typ : TZcDataType; const Name : string; IsPrivate : boolean>
  417  = GlobalVarRest<Typ,Name,IsPrivate> {"," GlobalVar<Typ,IsPrivate>}
  418  .
  419  
  420  /*------------------------------------------------------------------------*/
  421  
  422  Init<var OutOp : TZcOp>
  423  = Expr<OutOp>
  424  .
  425  
  426  /*------------------------------------------------------------------------*/
  427  Argument<var OutOp : TZcOp>
  428  = /* ["ref" | "out"] */
  429    (. OutOp := nil; .)
  430    Expr<OutOp>
  431    (. if OutOp=nil then ZError('Missing argument'); .)
  432  .
  433  
  434  /*------------------------------------------------------------------------*
  435   *-------------------------------- Types ---------------------------------*
  436   *------------------------------------------------------------------------*/
  437  
  438  /* Attribute "type" is needed for error messages in EmbeddedStatement     *
  439   * and for array creation expressions                                     */
  440  
  441  
  442  Type<var Typ : TZcDataType>
  443  (.
  444    var
  445      A : TDefineArray;
  446      SizeOp : TZcOp;
  447      I : integer;
  448  .)
  449  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  450    ( SimpleType<Typ> )
  451    {
  452      (
  453        "["       (.
  454                     A := TDefineArray.Create(nil);
  455                     GlobalNames.Add(A);
  456                     A._Type := Typ.Kind;
  457                     Typ.Kind := zctArray;
  458                     Typ.TheArray := A;
  459                  .)
  460  
  461           [ Expr<SizeOp> (.
  462              SizeOp := SizeOp.Optimize;
  463              if SizeOp.Kind<>zcConstLiteral then
  464                ZError('Array size must be a constant expression');
  465              A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
  466                           .)
  467           ]
  468  
  469           { ","  (. if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); .)
  470             [ Expr<SizeOp> (.
  471                  SizeOp := SizeOp.Optimize;
  472                  if SizeOp.Kind<>zcConstLiteral then
  473                    ZError('Array size must be a constant expression');
  474                 I := Trunc( (SizeOp as TZcOpLiteral).Value );
  475                 if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
  476             .) ]
  477           }
  478         "]"
  479      )
  480    }
  481  .
  482  
  483  /*------------------------------------------------------------------------*/
  484  
  485  SimpleType<var Typ : TZcDataType>
  486  (.
  487    var
  488      A : TDefineArray;
  489  .)
  490  /* = IntType | "float" | "double" | "decimal" | "bool" */
  491  = "float" (. Typ.Kind := zctFloat; .)
  492    | "int" (. Typ.Kind := zctInt; .)
  493    | "byte" (. Typ.Kind := zctByte; .)
  494    | "string" (. Typ.Kind := zctString; .)
  495    | "model" (. Typ.Kind := zctModel; .)
  496    | "xptr" (. Typ.Kind := zctXptr; .)
  497  
  498    | "mat4" (.
  499       A := Prototypes.Mat4Array;
  500       Typ.Kind := zctMat4;
  501       Typ.TheArray := A;
  502      .)
  503    | "vec2" (.
  504       A := Prototypes.Vec2Array;
  505       Typ.Kind := zctVec2;
  506       Typ.TheArray := A;
  507    .)
  508    | "vec3" (.
  509       A := Prototypes.Vec3Array;
  510       Typ.Kind := zctVec3;
  511       Typ.TheArray := A;
  512    .)
  513    | "vec4" (.
  514       A := Prototypes.Vec4Array;
  515       Typ.Kind := zctVec4;
  516       Typ.TheArray := A;
  517    .)
  518  
  519    /* Changes below also must be made in homographs-section */
  520    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  521    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  522    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  523    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  524    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  525    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  526    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  527    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  528    | "File" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; .)
  529  
  530    | "Component" (. Typ.Kind := zctReference; Typ.ReferenceClassId := AnyComponentClassId; .)
  531  .
  532  
  533  /*------------------------------------------------------------------------*/
  534  
  535  /* IntType
  536  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  537  . */
  538  
  539  
  540  ConstantDeclarationList<IsPrivate : boolean>
  541  (.
  542  var
  543    Typ : TZcDataType;
  544  .)
  545  = "const" Type<Typ> ConstantDeclaration<Typ,IsPrivate> {"," ConstantDeclaration<Typ,IsPrivate> }
  546    ";"
  547  .
  548  
  549  ConstantDeclaration<var Typ : TZcDataType; IsPrivate : boolean>
  550  (.
  551  var
  552    Cns : TDefineConstant;
  553    Op : TZcOp;
  554    Lit : TZcOpLiteral;
  555    CnsName : string;
  556  .)
  557  =
  558  ident (. CnsName := LexString; .) "=" Expr<Op>
  559    (.
  560     if not (Typ.Kind in [zctByte,zctInt,zctFloat,zctString]) then
  561       ZError('Only byte, int, float and string constants are allowed');
  562  
  563     Op := Op.Optimize;
  564     if not (Op is TZcOpLiteral) then
  565       ZError('Constant expression expected: ' + Op.ToString);
  566  
  567     Lit := Op as TZcOpLiteral;
  568  
  569     if (Lit.Typ.Kind<>Typ.Kind)
  570       and not ((Typ.Kind=zctByte) and (Lit.Typ.Kind=zctInt))
  571       and not ((Typ.Kind=zctInt) and (Lit.Typ.Kind=zctFloat))
  572       then
  573       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  574  
  575     Cns := TDefineConstant.Create(nil);
  576     Cns.SetString('Name',AnsiString(CnsName));
  577     GlobalNames.Add(Cns);
  578  
  579     case Typ.Kind of
  580       zctByte:
  581         begin
  582           Cns._Type := zctByte;
  583           Cns.ByteValue := Round(Lit.Value);
  584         end;
  585       zctInt:
  586         begin
  587           Cns._Type := zctInt;
  588           Cns.IntValue := Round(Lit.Value);
  589         end;
  590       zctFloat:
  591         begin
  592           Cns._Type := zctFloat;
  593           Cns.Value := Lit.Value;
  594         end;
  595       zctString:
  596         begin
  597           Cns._Type := zctString;
  598           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  599         end;
  600       else
  601         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  602     end;
  603     if IsPrivate then
  604       SymTab.Add(CnsName,Cns)
  605     else
  606       SymTab.AddPrevious(CnsName,Cns)
  607    .)
  608  /* {"," ident "=" Expr<Op>} */
  609  .
  610  
  611  /*------------------------------------------------------------------------*
  612   *------------------------------ Statements ------------------------------*
  613   *------------------------------------------------------------------------*/
  614  
  615  Statement<var OutOp : TZcOp>
  616  = (. OutOp := nil; .)
  617  
  618  ConstantDeclarationList<false>
  619  
  620  /*IF IsLocalVarDecl THEN
  621  BEGIN
  622    LocalVarDecl ";"
  623  END
  624  |  EmbeddedStatement<OutOp> */
  625  
  626  | LocalVarDecl<OutOp> ";"
  627  | EmbeddedStatement<OutOp>
  628    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  629     * ident {"." ident} { "[" ...                           */
  630  .
  631  
  632  /*------------------------------------------------------------------------*/
  633  EmbeddedStatement<var OutOp : TZcOp>
  634    (. var
  635         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  636         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  637         WhileCondOp,WhileBodyOp : TZcOp;
  638         SwitchOp : TZcOpSwitch;
  639         Loc : TZcOpLocalVar;
  640    .)
  641  = Block<OutOp>
  642  | ";"   (. OutOp := MakeOp(zcNop); .)
  643  | StatementExpr<OutOp> ";"
  644  | "if" (. ElseOp := nil; .)
  645    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
  646          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
  647   | "switch" "(" Expr<SwitchValueOp> ")"
  648        (.
  649           OutOp := MakeOp(zcBlock);
  650  
  651           SwitchOp := TZcOpSwitch.Create(nil);
  652  
  653           if (SwitchValueOp.Ref is TZcOpVariableBase) or (SwitchValueOp.Kind=zcConstLiteral) then
  654             SwitchOp.ValueOp := SwitchValueOp
  655           else
  656           begin
  657             Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
  658             SymTab.Add(Loc.Id,Loc);
  659             CurrentFunction.AddLocal(Loc);
  660             OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
  661             SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
  662           end;
  663  
  664           OutOp.Children.Add(SwitchOp);
  665        .)
  666     "{" {
  667       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
  668       SwitchSection<SwitchOp>
  669     } "}"
  670   | "while"
  671       (. try
  672           SymTab.PushScope;
  673           WhileCondOp := nil; WhileBodyOp := nil; .)
  674     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
  675     (.
  676           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
  677         finally
  678           SymTab.PopScope;
  679         end;
  680     .)
  681  
  682   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
  683   | "do"
  684       (. try
  685           SymTab.PushScope;
  686           WhileCondOp := nil; WhileBodyOp := nil; .)
  687     EmbeddedStatement<WhileBodyOp>
  688     "while" "(" Expr<WhileCondOp> ")" ";"
  689     (.
  690           OutOp := MakeOp(zcDoWhile,[WhileCondOp,WhileBodyOp]);
  691         finally
  692           SymTab.PopScope;
  693         end;
  694     .)
  695  
  696   | "for"
  697      (. try
  698           SymTab.PushScope;
  699           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
  700     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
  701     (.
  702           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
  703         finally
  704           SymTab.PopScope;
  705         end;
  706     .)
  707  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
  708   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
  709   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
  710   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
  711      (.
  712          if (Op=nil) then
  713          begin
  714            if CurrentFunction.ReturnType.Kind<>zctVoid then
  715              SynError(202)
  716            else
  717              OutOp := MakeOp(zcReturn);
  718          end else
  719          begin
  720            if CurrentFunction.ReturnType.Kind=zctVoid then
  721              SynError(203)
  722            else
  723              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
  724          end;
  725          Inc(CurrentFunction.ReturnCount);
  726      .)
  727  .
  728  /*------------------------------------------------------------------------*/
  729  
  730  Block<var OutOp : TZcOp>
  731    (. var
  732         Op : TZcOp;
  733    .)
  734  = (. Op := nil;
  735       OutOp := MakeOp(zcBlock);
  736    .)
  737    "{" (. SymTab.PushScope;
  738           try .)
  739       {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  740    "}" (.
  741           finally
  742             SymTab.PopScope;
  743           end;
  744        .)
  745    .
  746  
  747  /*------------------------------------------------------------------------*/
  748  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  749  = (. Op1 :=nil; Op2 := nil; .)
  750    Unary<Op1>
  751    ( AssignOp<Kind> Expr<Op2>
  752      (.
  753        if Op2<>nil then
  754          OutOp := MakeAssign(Kind,Op1,Op2);
  755      .)
  756    |                             (. OutOp := Op1; .)
  757    )
  758  .
  759  
  760  /*------------------------------------------------------------------------*/
  761  AssignOp<var Kind : TZcAssignType>
  762  = "="     (. Kind := atAssign; .)
  763    | "+="  (. Kind := atPlusAssign; .)
  764    | "-="  (. Kind := atMinusAssign; .)
  765    | "*="  (. Kind := atMulAssign; .)
  766    | "/="  (. Kind := atDivAssign; .)
  767    | "|="  (. Kind := atOrAssign; .)
  768    | "<<="  (. Kind := atShiftLeftAssign; .)
  769    | ">>="  (. Kind := atShiftRightAssign; .)
  770    | "&="  (. Kind := atAndAssign; .)
  771  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
  772  .
  773  
  774  /*------------------------------------------------------------------------*/
  775  
  776  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
  777  = (. Op := nil; .)
  778    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
  779    {
  780      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
  781    }
  782    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  783    {
  784       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
  785    }
  786  .
  787  
  788  /*------------------------------------------------------------------------*/
  789  
  790  SwitchLabel<var OutOp : TZcOp>
  791  = "case" Expr<OutOp> ":"
  792  | "default" ":"
  793  .
  794  
  795  /*------------------------------------------------------------------------*/
  796  
  797  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
  798  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
  799  (
  800  LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  801  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
  802    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  803  )
  804  .  
  805  
  806  /*------------------------------------------------------------------------*/
  807  
  808  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
  809  = (. Op:=nil;
  810       OutOp := MakeOp(zcBlock);
  811    .) 
  812  (
  813  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
  814  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
  815  )
  816  . 
  817  
  818  
  819  /*------------------------------------------------------------------------*
  820   *----------------------------- Expressions ------------------------------*
  821   *------------------------------------------------------------------------*/
  822  
  823  
  824  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
  825  = (. Op1 :=nil; Op2 := nil; .)
  826    Unary<Op1>
  827    ( OrExpr<Op1,OutOp>
  828        ["?" Expr<Op1> ":" Expr<Op2>
  829           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
  830                SynError(205)
  831              else
  832                OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
  833           .)
  834        ]
  835    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
  836    )
  837  .
  838  /*------------------------------------------------------------------------*/
  839  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  840  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
  841      {"||" Unary<Op> AndExpr<Op,R>
  842        (. OutOp := MakeOp(zcOr,[L,R]);
  843           L := OutOp; .)
  844      }
  845  .
  846  
  847  
  848  /*------------------------------------------------------------------------*/
  849  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  850  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
  851      {"&&" Unary<Op> BitOrExpr<Op,R>
  852        (. OutOp := MakeOp(zcAnd,[L,R]);
  853           L := OutOp; .)
  854      }
  855  .
  856  /*------------------------------------------------------------------------*/
  857  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  858  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
  859    {"|" Unary<Op> BitXorExpr<Op,R>
  860      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
  861         L := OutOp; .)
  862    }
  863  .
  864  
  865  /*------------------------------------------------------------------------*/
  866  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  867  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
  868    {"^" Unary<Op> BitAndExpr<Op,R>
  869      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
  870         L := OutOp; .)
  871    }
  872  .
  873  
  874  /*------------------------------------------------------------------------*/
  875  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
  876  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
  877    {"&" Unary<Op> EqlExpr<Op,R>
  878      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
  879         L := OutOp; .)
  880    }
  881  .
  882  
  883  /*------------------------------------------------------------------------*/
  884  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  885  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  886    {( "!="   (. Kind := zcCompNE; .)
  887     | "=="   (. Kind := zcCompEQ; .)
  888     )
  889     Unary<Op> RelExpr<Op,R>
  890           (. OutOp := MakeBinary(Kind, L,R);
  891              L := OutOp;
  892           .)
  893    }
  894  .
  895  /*------------------------------------------------------------------------*/
  896  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
  897  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  898    { ( "<"       (. Kind := zcCompLT; .)
  899      | ">"       (. Kind := zcCompGT; .)
  900      | "<="      (. Kind := zcCompLE; .)
  901      | ">="      (. Kind := zcCompGE; .)
  902       )
  903      Unary<Op> ShiftExpr<Op,R>
  904           (. OutOp := MakeBinary(Kind, L,R );
  905              L := OutOp;
  906           .)
  907    }
  908  .
  909  /*------------------------------------------------------------------------*/
  910  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
  911  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
  912    { ("<<"  (. Kind := zcBinaryShiftL; .)
  913      | ">>" (. Kind := zcBinaryShiftR; .)
  914      )
  915      Unary<Op> AddExpr<Op,R>
  916      (. OutOp := MakeOp(Kind,[L,R]);
  917         L := OutOp; .)
  918    }
  919  .
  920  /*------------------------------------------------------------------------*/
  921  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
  922  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
  923      {( "+"    (. Kind := zcPlus; .)
  924       | "-"    (. Kind := zcMinus; .)
  925       ) Unary<Op> MulExpr<Op,R>
  926           (. 
  927              if (L=nil) or (R=nil) then
  928                ZError('Invalid syntax');
  929              OutOp := MakeBinary(Kind,L,R);
  930              L := OutOp;
  931           .)
  932      }
  933  .
  934  /*------------------------------------------------------------------------*/
  935  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
  936  = (. OutOp := InOp; Kind := zcNop; .)
  937    { ("*"      (. Kind := zcMul; .)
  938      | "/"     (. Kind := zcDiv; .)
  939      | "%"     (. Kind := zcMod; .)
  940      ) Unary<Tmp>
  941           (. OutOp := MakeBinary(Kind,InOp,Tmp);
  942              InOp := OutOp;
  943           .)
  944      }
  945  .
  946  /*------------------------------------------------------------------------*/
  947  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
  948  =       (. LastOp := nil; Kind := zcNop; .)
  949    {
  950      (
  951        /* "+" | */
  952        "-"   (. Kind := zcNegate; .) |
  953        "++"  (. Kind := zcPreInc; .) |
  954        "--"  (. Kind := zcPreDec; .) |
  955        "!"   (. Kind := zcNot; .)    |
  956        "~"   (. Kind := zcBinaryNot; .)
  957        /* | "~" | "*" */
  958      )
  959      (.
  960         if Kind in [zcNot,zcBinaryNot] then
  961         begin
  962           Tmp := MakeOp(Kind);
  963           if LastOp<>nil then
  964             LastOp.Children.Add(Tmp);
  965           LastOp := Tmp;
  966         end else if Assigned(LastOp) then
  967           ZError('- ,-- and ++ cannot be combined with other unary ops');
  968      .)
  969    }
  970    Primary<Tmp>
  971      (.
  972         if Kind=zcNegate then
  973           OutOp := MakeBinary(zcMinus, TZcOpLiteral.Create(Tmp.GetDataType.Kind,0), Tmp)
  974         else if Kind in [zcNop,zcNot,zcBinaryNot] then
  975         begin
  976           if LastOp<>nil then
  977           begin
  978             LastOp.Children.Add(Tmp);
  979             OutOp := LastOp;
  980           end else
  981             OutOp := Tmp;
  982         end else
  983         begin
  984           OutOp := MakePrePostIncDec(Kind,Tmp);
  985         end;
  986      .)
  987  .
  988  
  989  
  990  
  991  /*------------------------------------------------------------------------*/
  992  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
  993  (.
  994    var
  995      Op : TZcOp;
  996      Prop : TZProperty;
  997  .)
  998  = (. OutOp := nil; Op := nil; .)
  999    ident (.
 1000      Prop := Ci.GetProperties.GetByName(LexString);
 1001      if Prop=nil then
 1002        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
 1003      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
 1004        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
 1005      OutOp := MakeOp(zcIdentifier);
 1006      OutOp.Id := LexString;
 1007    .)
 1008    ":" Expr<Op>
 1009    (. if Op=nil then
 1010         ZError('Missing argument');
 1011       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
 1012       OutOp.Children.Add(Op);
 1013    .)
 1014  .
 1015  
 1016  
 1017  /*------------------------------------------------------------------------*/
 1018  ReinterpretCast<var OutOp : TZcOp>
 1019  (.
 1020  var
 1021    Op : TZcOp;
 1022    Typ : TZcDataType;
 1023  .)
 1024  = "reinterpret_cast" "<" SimpleType<Typ> ">"
 1025    "(" Expr<Op> ")"
 1026    (.
 1027       OutOp := TZcOpReinterpretCast.Create(nil);
 1028       OutOp.Children.Add(Op);
 1029       (OutOp as TZcOpReinterpretCast).Typ := Typ;
 1030    .)
 1031  .
 1032  
 1033  /*------------------------------------------------------------------------*/
 1034  InlineComponent<var OutOp : TZcOp>
 1035  (. var Op : TZcOp;
 1036       Ci : TZComponentInfo;
 1037  .)
 1038  =  (. OutOp := nil;
 1039        IsInInvokeArg := True;
 1040     .)
 1041     "@" ident (.
 1042         Ci := ComponentManager.GetInfoFromName(LexString);
 1043         OutOp := TZcOpInvokeComponent.Create(nil);
 1044         OutOp.Id := LexString;
 1045      .)
 1046      "("
 1047          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
 1048            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
 1049            }
 1050          ]
 1051      ")" (. IsInInvokeArg := False; .)
 1052  .
 1053  
 1054  /*------------------------------------------------------------------------*/
 1055  Primary<var OutOp : TZcOp>
 1056  (. var Op : TZcOp; S : string; V : double;
 1057       Typ : TZcDataType;
 1058  .)
 1059  =            (. OutOp := nil; .)
 1060    (
 1061      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
 1062    | InlineComponent<OutOp>
 1063    | Literal<Typ>  (.
 1064          if Typ.Kind in [zctString,zctNull] then
 1065            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
 1066          else
 1067          begin
 1068            try
 1069              S := LexString;
 1070              V := ZcStrToFloat(S);
 1071              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
 1072            except on EConvertError do
 1073              SynError(200);
 1074            end;
 1075          end;
 1076       .)
 1077    | "(" Expr<OutOp> ")"
 1078  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
 1079      | "float"  | "int"    | "long" | "object"  | "sbyte"
 1080      | "short"  | "string" | "uint" | "ulong"   | "ushort"
 1081      ) "." ident */
 1082    | ReinterpretCast<OutOp>
 1083    )
 1084  
 1085    {
 1086    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
 1087    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
 1088  
 1089  /*  | "->" ident */
 1090  
 1091    | "." (. IsInIdent := True; .) ident (.
 1092  
 1093        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
 1094          ZError('Invalid use of "."');
 1095  
 1096        Op := MakeOp(zcSelect,LexString);
 1097        Op.Children.Add(OutOp);
 1098  
 1099        OutOp := CheckPrimary(Op);
 1100  
 1101        IsInIdent := False;
 1102  
 1103      .)
 1104  
 1105    | "(" (.
 1106             if (OutOp=nil) or (OutOp.Kind<>zcIdentifier) then
 1107               ZError('Unexpected "("');
 1108             OutOp.Kind:=zcFuncCall;
 1109           .)
 1110          [Argument<Op> (. OutOp.Children.Add(Op); .)
 1111            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
 1112            }
 1113          ]
 1114          (.
 1115             if not VerifyFunctionCall(OutOp,S,CurrentFunction) then
 1116               ZError(S);
 1117          .)
 1118      ")"
 1119  
 1120    | "[" (.
 1121             if (OutOp=nil) or (not (OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall])) then
 1122               ZError('Unexpected "["');
 1123             Op := MakeArrayAccess(OutOp);
 1124             OutOp := Op;
 1125           .)
 1126  
 1127          Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
 1128            {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
 1129          "]"
 1130    }
 1131  .
 1132  /*------------------------------------------------------------------------*/
 1133  Literal<var Typ : TZcDataType>
 1134  = intCon (. Typ.Kind :=zctInt; .) |
 1135    realCon (. Typ.Kind := zctFloat; .) |
 1136    stringCon (. Typ.Kind := zctString; .)
 1137    | "null" (. Typ.Kind := zctNull; .)
 1138    /* | "true" | "false"  */
 1139  .
 1140  
 1141  END Zc.



