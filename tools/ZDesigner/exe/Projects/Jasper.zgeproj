<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="60" FileVersion="2">
  <OnLoaded>
    <ZExternalLibrary ModuleName="kernel32.dll">
      <Source>
<![CDATA[//Import a DLL-library by setting ModuleName to name of the DLL
//and then declaring the function headers here. For example:
//
//  int SetWindowLongA(int hWnd, int nIndex, int dwNewLong) { } 
//  int SetWindowTextA(int hWnd,string lpString) { }
int GetTickCount() { }]]>
      </Source>
    </ZExternalLibrary>
    <ZLibrary HasInitializer="1">
      <Source>
<![CDATA[//Based on https://github.com/begoon/jasper

  const int DEBUGTRACE = 0;
  const int PROFILE = 0;

  private const float clockSpeed = 3.5;
  private const int tstatesPerInterrupt = ((clockSpeed * 1e6) / 50);


  int Keys_B_SPC  = 0xff;
  int Keys_H_ENT  = 0xff;
  int Keys_Y_P    = 0xff;
  int Keys_6_0    = 0xff;
  int Keys_1_5    = 0xff;
  int Keys_Q_T    = 0xff;
  int Keys_A_G    = 0xff;
  int Keys_CAPS_V = 0xff;
  int JoyState = 0;

  const int IM0 = 0;
  const int IM1 = 1;
  const int IM2 = 2;

  private const int F_C  = 0x01;
  private const int F_N  = 0x02;
  private const int F_PV = 0x04;
  private const int F_3  = 0x08;
  private const int F_H  = 0x10;
  private const int F_5  = 0x20;
  private const int F_Z  = 0x40;
  private const int F_S  = 0x80;

  private const int PF = F_PV;
  private const int p_ = 0;

  private int[256] parity;

  private const int true = 1;
  private const int false = 0;

  int getSignedByte(int b) {
    if(b&0x80)
      return 0-((b^255) +1);
    else
      return b;
  }

  {
    for ( int i = 0; i < 256; i++ ) {
      int p = true;
      for ( int j = 0; j < 8; j++ ) {
        if ( (i & (1<<j)) != 0 ) {
          p = p ? false : true;
        }
      }
      parity[ i ] = p;
    }
  }

  /** Alternate registers */
   int        _AF_ = 0, _HL_ = 0, _BC_ = 0, _DE_ = 0;

  /** Index registers - ID used as temporary for ix/iy */
   int        _IX = 0, _IY = 0, _ID = 0;

  /** Stack Pointer and Program Counter */
   int        _SP = 0, _PC = 0;

  /** Interrupt and Refresh registers */
   int        _I = 0, _R = 0, _R7 = 0;

  /** Interrupt flip-flops */
   int    _IFF1 = true, _IFF2 = true;
   int        _IM = 2;

  /** Memory */
  byte[ 65536 ]  mem;

    /** Main registers */
   int        _A = 0, _HL = 0, _B = 0, _C = 0, _DE = 0;
   int    fS = false, fZ  = false, f5 = false, fH = false;
   int    f3 = false, fPV = false, fN = false, fC = false;

  /** Flag access */
    inline void setZ( int f ) { fZ = f; }
    inline void setC( int f ) { fC = f; }
    inline void setS( int f ) { fS = f; }
    inline void setH( int f ) { fH = f; }
    inline void setN( int f ) { fN = f; }
    inline void setPV( int f ) {fPV = f;}
    inline void set3( int f ) { f3 = f; }
    inline void set5( int f ) { f5 = f; }

    inline int Zset()  { return fZ; }
    inline int Cset()  { return fC; }
    inline int Sset()  { return fS; }
    inline int Hset()  { return fH; }
    inline int Nset()  { return fN; }
    inline int PVset() { return fPV; }


  /** 8 bit register access */
  inline int  A() { return _A; }

  inline void A( int bite ) {
    _A = bite;
  }

  inline int F() {
    return  (Sset()  ? F_S  : 0)  |
      (Zset()  ? F_Z  : 0)  |
      (f5      ? F_5  : 0)  |
      (Hset()  ? F_H  : 0)  |
      (f3      ? F_3  : 0)  |
      (PVset() ? F_PV : 0)  |
      (Nset()  ? F_N  : 0)  |
      (Cset()  ? F_C  : 0);
  }
  inline void F( int bite ) {
    fS  = (bite & F_S)  != 0;
    fZ  = (bite & F_Z)  != 0;
    f5  = (bite & F_5)  != 0;
    fH  = (bite & F_H)  != 0;
    f3  = (bite & F_3)  != 0;
    fPV = (bite & F_PV) != 0;
    fN  = (bite & F_N)  != 0;
    fC  = (bite & F_C)  != 0;
  }


  inline int  B() { return _B; }
  inline void B( int bite ) {
    _B = bite;
  }
  inline int  C() { return _C; }
  inline void C( int bite ) {
    _C = bite;
  }

  inline int D() { return (_DE >> 8); }
  inline void D( int bite ) {
    _DE = (bite << 8) | (_DE & 0x00ff);
  }
  inline int  E() { return (_DE & 0xff); }
  inline void E( int bite ) {
    _DE = (_DE & 0xff00) | bite;
  }

  inline int  H() { return (_HL >> 8); }

  inline void H( int bite ) {
    _HL = (bite << 8) | (_HL & 0x00ff);
  }

  inline int L() { return (_HL & 0xff); }
  inline void L( int bite ) {
    _HL = (_HL & 0xff00) | bite;
  }

  /** 16 bit register access */
  inline int AF() { return (A() << 8) | F(); }

  inline void AF( int word ) {
    A( word >> 8 );
    F( word & 0xff );
  }

  inline int BC() { return (B() << 8) | C(); }
  inline void BC( int word ) {
    B( word >> 8 );
    C( word & 0xff );
  }

  inline int  DE() { return _DE; }
  inline void DE( int word ) {
    _DE = word;
  }

  inline int  HL() { return _HL; }
  inline void HL( int word ) {
    _HL = word;
  }

  inline int PC() { return _PC; }

  inline void PC( int word ) {
    _PC = word;
  }

  inline int  SP() { return _SP; }
  inline void SP( int word ) {
    _SP = word;
  }

  inline int ID() { return _ID; }
  inline void ID( int word ) {
    _ID = word;
  }

  inline int IX() { return _IX; }
  inline void IX( int word ) {
    _IX = word;
  }

  inline int IY() { return _IY; }
  inline void IY( int word ) {
    _IY = word;
  }




  inline int  IDH() { return (_ID >> 8); }
  inline void IDH( int bite ) {
    _ID = (bite << 8) | (_ID & 0x00ff);
  }
  inline int  IDL() { return (_ID & 0xff); }
  inline void IDL( int bite ) {
    _ID = (_ID & 0xff00) | bite;
  }


  /** Memory refresh register */
  inline int  R7() { return _R7; }
  inline int  R() { return (_R & 0x7f) | _R7; }
  inline void R( int bite ) {
    _R  = bite;
    _R7 = bite & 0x80;
  }

  inline void REFRESH( int t ) {
    _R += t;
  }


  /** Interrupt modes/register */
  int  I() { return _I; }
  void I( int bite ) {
    _I = bite;
  }

  int IFF1() { return _IFF1; }
  void IFF1( int iff1 ) {
    _IFF1 = iff1;
  }

  int IFF2() { return _IFF2; }
  void IFF2( int iff2 ) {
    _IFF2 = iff2;
  }

  int IM() { return _IM; }
  void IM( int im ) {
    _IM = im;
  }



  /** Byte access */
  private inline int peekb( int addr ) {
    return mem[ addr ];
  }

  void pokeb( int addr, int newByte ) {
    if ( addr < 16384 ) {
      return;
    }

    mem[ addr ] = newByte;
  }


  /** Word access */
  void pokew( int addr, int word ) {
    pokeb( addr, word & 0xff );
    addr++;
    pokeb( addr & 0xffff, word >> 8 );
  }

  private  int peekw( int addr ) {
    int        t = peekb( addr );
    addr++;
    return t | (peekb( addr & 0xffff ) << 8);
  }


  /** Program access */
  private  int nxtpcb() {
    int pc = PC();
    int t = peekb( pc );
    PC( ++pc & 0xffff );
    return t;
  }
  private  int nxtpcw() {
    int pc = PC();
    int t = peekb( pc );
    t |= ( peekb( ++pc & 0xffff ) << 8 );
    PC( ++pc & 0xffff );
    return t;
  }

  /** Index register access */
  private  int ID_d() {
    return ((ID()+nxtpcb()) & 0xffff);
  }


  /** Stack access */
  void pushw( int word ) {
    int        sp = ((SP()-2) & 0xffff);
    SP( sp );
    pokew( sp, word );
  }

  int popw() {
    int sp = SP();
    int t  = peekb( sp );
      sp++;
      t |= (peekb( sp & 0xffff) << 8);
      SP( ++sp & 0xffff );
    return t;
  }


  /** Call stack */
  void pushpc() { pushw( PC() ); }
  void poppc()  { PC( popw() ); }





  /** IO ports */
  void outb( int port, int bite, int tstates ) {
  }

  int inb( int port ) {
    int res = 0xff;

    if((port & 31) == 31) {
      res=JoyState;
    } else if ( (port & 0x0001) == 0 ) {
      if ( (port & 0x0800) == 0 ) { res &= Keys_1_5;   }
      if ( (port & 0x1000) == 0 ) { res &= Keys_6_0;   }

      /*if ( (port & 0x8000) == 0 ) { res &= _B_SPC; }
      if ( (port & 0x4000) == 0 ) { res &= _H_ENT; }
      if ( (port & 0x2000) == 0 ) { res &= _Y_P;   }
      if ( (port & 0x1000) == 0 ) { res &= _6_0;   }
      if ( (port & 0x0800) == 0 ) { res &= _1_5;   }
      if ( (port & 0x0400) == 0 ) { res &= _Q_T;   }
      if ( (port & 0x0200) == 0 ) { res &= _A_G;   }
      if ( (port & 0x0100) == 0 ) { res &= _CAPS_V;}*/
    }

    return(res);
  }

  /** Interrupt handlers */
  private int interruptTriggered( int tstates ) {
    return (tstates >= 0);
  }

   int interrupt() {
    // If not a non-maskable interrupt
    if ( !IFF1() ) {
      return 0;
    }

    switch( IM() ) {
    case IM0:
    case IM1:
      pushpc();
      IFF1( false );
      IFF2( false );
      PC( 56 );
      return 13;
    case IM2:
      pushpc();
      IFF1( false );
      IFF2( false );
      int t = (I()<<8) | 0x00ff;
      PC( peekw(t) );
      return 19;
    }

    return 0;
  }

  /** EX AF,AF' */
  void ex_af_af() {
    int   t;
    t = AF(); AF( _AF_ ); _AF_ = t;
  }

  /** Quick Increment : no flags */
  private inline int inc16( int a ) { return (a + 1) & 0xffff; }
  private inline int qinc8( int a ) { return (a + 1) & 0xff; }

  /** Quick Decrement : no flags */
  private inline int dec16( int a ) { return (a - 1) & 0xffff; }
  private inline int qdec8( int a ) { return (a - 1) & 0xff; }

  /** Bit toggling */
  private inline int res( int bit, int val ) { return val & ~bit; }
  private inline int set( int bit, int val ) { return val |  bit; }

  private  int in_bc() {
    int        ans = inb( BC() );

    setZ( ans == 0 );
    setS( (ans & F_S)!=0 );
    set3( (ans & F_3)!=0 );
    set5( (ans & F_5)!=0 );
    setPV( parity[ ans ] );
    setN( false );
    setH( false );

    return ans;
  }

  /** Add with carry - alters all flags (CHECKED) */
  private  void
  adc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a + b + c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f) + c) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Add - alters all flags (CHECKED) */
  private  void
  add_a( int b )
  {
    int a    = A();
    int wans = a + b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f)) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Subtract with carry - alters all flags (CHECKED) */
  private  void
  sbc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a - b - c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f) - c) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Subtract - alters all flags (CHECKED) */
  private  void
  sub_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Rotate Left - alters H N C 3 5 flags (CHECKED) */
  private  void
  rlc_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right - alters H N C 3 5 flags (CHECKED) */
  private  void
  rrc_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Left through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rl_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }

    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rr_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Compare - alters all flags (CHECKED) */
  private  void
  cp_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (b & F_3)   != 0 );
    set5( (b & F_5)   != 0 );
    setN( true );
    setZ( ans == 0 );
    setC( (wans & 0x100)!=0 );
    setH( (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
  }

  /** Bitwise and - alters all flags (CHECKED) */
  private  void
  and_a( int b )
  {
    int ans = A() & b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise or - alters all flags (CHECKED) */
  private  void
  or_a( int b )
  {
    int ans = A() | b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise exclusive or - alters all flags (CHECKED) */
  private  void
  xor_a( int b )
  {
    int ans = (A() ^ b) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Negate (Two's complement) - alters all flags (CHECKED) */
  private  void
  neg_a()
  {
    int t = A();

    A( 0 );
    sub_a(t);
  }

  /** One's complement - alters N H 3 5 flags (CHECKED) */
  private  void
  cpl_a()
  {
    int ans = A() ^ 0xff;

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setN( true );

    A( ans );
  }

  /** Decimal Adjust Accumulator - alters all flags (CHECKED) */
  private  void
  daa_a()
  {
    int        ans = A();
    int        incr = 0;
    int    carry = Cset();

    if ((Hset()) || ((ans & 0x0f) > 0x09)) {
      incr |= 0x06;
    }
    if (carry || (ans > 0x9f) || ((ans > 0x8f) && ((ans & 0x0f) > 0x09))) {
      incr |= 0x60;
    }
    if (ans > 0x99) {
      carry = true;
    }
    if (Nset()) {
      sub_a(incr);
    } else {
      add_a(incr);
    }

    ans = A();

    setC( carry );
    setPV( parity[ ans ] );
  }

  /** Load a with i - (NOT CHECKED) */
  private  void
  ld_a_i()
  {
    int ans = I();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Load a with r - (NOT CHECKED) */
  private  void
  ld_a_r()
  {
    int ans = R();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate right through a and (hl) - (NOT CHECKED) */
  private  void
  rrd_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t >> 4) | (ans << 4);
    ans = (ans & 0xf0) | (q & 0x0f);
    pokeb( HL(), t );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate left through a and (hl) - (NOT CHECKED) */
  private  void
  rld_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t << 4) | (ans & 0x0f);
    ans = (ans & 0xf0) | (q >> 4);
    pokeb( HL(), (t & 0xff) );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Test bit - alters all but C flag (CHECKED) */
  private  void
  bit( int b, int r )
  {
    int    bitSet = ((r & b) != 0);

    setN( false );
    setH( true );
    set3( (r & F_3) != 0 );
    set5( (r & F_5) != 0 );
    setS( (b == F_S) ? bitSet : false );
    setZ(  !bitSet );
    setPV( !bitSet );
  }

  /** Set carry flag - alters N H 3 5 C flags (CHECKED) */
  private  void
  scf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setH( false );
    setC( true );
  }

  /** Complement carry flag - alters N 3 5 C flags (CHECKED) */
  private  void
  ccf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setC( Cset() ? false : true );
  }

  /** Rotate left - alters all flags (CHECKED) */
  private  int
  rlc( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right - alters all flags (CHECKED) */
  private  int
  rrc( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate left through carry - alters all flags (CHECKED) */
  private  int
  rl( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right through carry - alters all flags (CHECKED) */
  private  int
  rr( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left Arithmetically - alters all flags (CHECKED) */
  private  int
  sla( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = (ans << 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left and Set - alters all flags (CHECKED) */
  private  int
  sls( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = ((ans << 1) | 0x01) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Arithmetically - alters all flags (CHECKED) */
  private  int
  sra( int ans )
  {
    int c = (ans & 0x01) != 0;
    ans = (ans >> 1) | (ans & 0x80);

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Logically - alters all flags (CHECKED) */
  private  int srl( int ans ) {
    int c = (ans & 0x01) != 0;
    ans = ans >> 1;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Decrement - alters all but C flag (CHECKED) */
  private  int dec8( int ans ) {
    int    pv = (ans == 0x80);
    int    h  = (((ans & 0x0f) - 1) & F_H) != 0;
    ans = (ans - 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( true );

    return(ans);
  }

  /** Increment - alters all but C flag (CHECKED) */
  private  int inc8( int ans ) {
    int    pv = (ans == 0x7f);
    int    h  = (((ans & 0x0f) + 1) & F_H) != 0;
    ans = (ans + 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int adc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a + b + c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff) + c) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add - (NOT CHECKED) */
  private  int add16( int a, int b ) {
    int lans = a + b;
    int ans  = lans & 0xffff;

    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setC( (lans & 0x10000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff)) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int sbc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a - b - c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) - (b & 0x0fff) - c) & 0x1000)!=0 );
    setN( true );

    return(ans);
  }

  /** EXX */
  void exx() {
    int t;

    t = HL();
    HL( _HL_ );
    _HL_ = t;

    t = DE();
    DE( _DE_ );
    _DE_ = t;

    t = BC();
    BC( _BC_ );
    _BC_ = t;
  }

  private  int execute_ed( int local_tstates ) {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case 0:  /* NOP */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:

    case 164:
    case 165:
    case 166:
    case 167:

    case 172:
    case 173:
    case 174:
    case 175:

    case 180:
    case 181:
    case 182:
    case 183:
    {
      return ( 8 );
    }

    /* IN r,(c) */
    case 64:  /* IN B,(c) */
    { B( in_bc() ); return ( 12 ); }
    case 72:  /* IN C,(c) */
    { C( in_bc() ); return ( 12 ); }
    case 80:  /* IN D,(c) */
    { D( in_bc() ); return ( 12 ); }
    case 88:  /* IN E,(c) */
    { E( in_bc() ); return ( 12 ); }
    case 96:  /* IN H,(c) */
    { H( in_bc() ); return ( 12 ); }
    case 104:  /* IN L,(c) */
    { L( in_bc() ); return ( 12 ); }
    case 112:  /* IN (c) */
    { in_bc(); return ( 12 ); }
    case 120:  /* IN A,(c) */
    { A( in_bc() ); return ( 12 ); }

    /* OUT (c),r */
    case 65:  /* OUT (c),B */
    { outb( BC(), B(), local_tstates ); return ( 12 ); }
    case 73:  /* OUT (c),C */
    { outb( BC(), C(), local_tstates ); return ( 12 ); }
    case 81:  /* OUT (c),D */
    { outb( BC(), D(), local_tstates ); return ( 12 ); }
    case 89:  /* OUT (c),E */
    { outb( BC(), E(), local_tstates ); return ( 12 ); }
    case 97:  /* OUT (c),H */
    { outb( BC(), H(), local_tstates ); return ( 12 ); }
    case 105:  /* OUT (c),L */
    { outb( BC(), L(), local_tstates ); return ( 12 ); }
    case 113:  /* OUT (c),0 */
    { outb( BC(), 0, local_tstates ); return ( 12 ); }
    case 121:  /* OUT (c),A */
    { outb( BC(), A(), local_tstates ); return ( 12 ); }

    /* SBC/ADC HL,ss */
    case 66:  /* SBC HL,BC */
    { HL( sbc16( HL(), BC() ) ); return ( 15 ); }
    case 74:  /* ADC HL,BC */
    { HL( adc16( HL(), BC() ) ); return ( 15 ); }
    case 82:  /* SBC HL,DE */
    { HL( sbc16( HL(), DE() ) ); return ( 15 ); }
    case 90:  /* ADC HL,DE */
    { HL( adc16( HL(), DE() ) ); return ( 15 ); }
    case 98:  /* SBC HL,HL */
    {
      int hl = HL();
      HL( sbc16( hl, hl ) );
      return ( 15 );
    }
    case 106:  /* ADC HL,HL */
    {
      int hl = HL();
      HL( adc16( hl, hl ) );
      return ( 15 );
    }
    case 114:  /* SBC HL,SP */
    { HL( sbc16( HL(), SP() ) ); return ( 15 ); }
    case 122:  /* ADC HL,SP */
    { HL( adc16( HL(), SP() ) ); return ( 15 ); }

    /* LD (nn),ss, LD ss,(nn) */
    case 67:  /* LD (nn),BC */
    { pokew( nxtpcw(), BC() ); return ( 20 ); }
    case 75:  /* LD BC(),(nn) */
    { BC( peekw( nxtpcw() ) ); return ( 20 ); }
    case 83:  /* LD (nn),DE */
    { pokew( nxtpcw(), DE() ); return ( 20 ); }
    case 91:  /* LD DE,(nn) */
    { DE( peekw( nxtpcw() ) ); return ( 20 ); }
    case 99:  /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); return ( 20 ); }
    case 107:  /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); return ( 20 ); }
    case 115:  /* LD (nn),SP */
    { pokew( nxtpcw(), SP() ); return ( 20 ); }
    case 123:  /* LD SP,(nn) */
    { SP( peekw( nxtpcw() ) ); return ( 20 ); }

    /* NEG */
    case 68:  /* NEG */
    case 76:  /* NEG */
    case 84:  /* NEG */
    case 92:  /* NEG */
    case 100:  /* NEG */
    case 108:  /* NEG */
    case 116:  /* NEG */
    case 124:  /* NEG */
    { neg_a(); return ( 8 ); }

    /* RETn */
    case 69:  /* RETN */
    case 85:  /* RETN */
    case 101:  /* RETN */
    case 117:  /* RETN */
    {
      IFF1( IFF2() );
      poppc();
      return ( 14 );
    }
    case 77:  /* RETI */
    case 93:  /* RETI */
    case 109:  /* RETI */
    case 125:  /* RETI */
    {
      poppc();
      return ( 14 );
    }

    /* IM x */
    case 70:  /* IM 0 */
    case 78:  /* IM 0 */
    case 102:  /* IM 0 */
    case 110:  /* IM 0 */
    { IM( IM0 ); return ( 8 ); }
    case 86:  /* IM 1 */
    case 118:  /* IM 1 */
    { IM( IM1 ); return ( 8 ); }
    case 94:  /* IM 2 */
    case 126:  /* IM 2 */
    { IM( IM2 ); return ( 8 ); }

    /* LD A,s / LD s,A / RxD */
    case 71:  /* LD I,A */
    { I( A() ); return ( 9 ); }
    case 79:  /* LD R,A */
    { R( A() ); return ( 9 ); }
    case 87:  /* LD A,I */
    { ld_a_i(); return ( 9 ); }
    case 95:  /* LD A,R */
    { ld_a_r(); return ( 9 ); }
    case 103:  /* RRD */
    { rrd_a(); return ( 18 ); }
    case 111:  /* RLD */
    { rld_a(); return ( 18 ); }

    /* xxI */
    case 160:  /* LDI */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( inc16( DE() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 161:  /* CPI */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 162:  /* INI */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 163:  /* OUTI */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxD */
    case 168:  /* LDD */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( dec16( DE() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 169:  /* CPD */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 170:  /* IND */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 171:  /* OUTD */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxIR */
    case 176:  /* LDIR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH( -2 );
      do {
        pokeb(dest, peekb(from) );
        from  = inc16( from );
        dest  = inc16( dest );
        count = dec16( count );

        _local_tstates += ( 21 );
        REFRESH( 2 );
        if ( interruptTriggered( _local_tstates ) ) {
          break;
        }
      } while (count != 0);
      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 177:  /* CPIR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 178:  /* INIR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 179:  /* OTIR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    /* xxDR */
    case 184:  /* LDDR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH ( -2 );
      do {
        pokeb(dest, peekb(from));
        from  = dec16( from );
        dest  = dec16( dest );
        count = dec16( count );

        _local_tstates += ( 21 );
        REFRESH( 2 );
        if ( interruptTriggered( _local_tstates ) ) {
          break;
        }
      } while (count != 0);
      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 185:  /* CPDR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 186:  /* INDR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 187:  /* OTDR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    } // end switch

    // NOP
    return ( 8 );
  }

  private  int execute_cb() {
    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case   0: /* RLC B */
    { B( rlc( B() ) ); return ( 8 ); }
    case   1: /* RLC C */
    { C( rlc( C() ) ); return ( 8 ); }
    case   2: /* RLC D */
    { D( rlc( D() ) ); return ( 8 ); }
    case   3: /* RLC E */
    { E( rlc( E() ) ); return ( 8 ); }
    case   4: /* RLC H */
    { H( rlc( H() ) ); return ( 8 ); }
    case   5: /* RLC L */
    { L( rlc( L() ) ); return ( 8 ); }
    case   6: /* RLC (HL) */
    {
      int hl = HL();
      pokeb( hl, rlc( peekb( hl ) ) );
      return ( 15 );
    }
    case   7: /* RLC A */
    { A( rlc( A() ) ); return ( 8 ); }

    case   8: /* RRC B */
    { B( rrc( B() ) ); return ( 8 ); }
    case   9: /* RRC C */
    { C( rrc( C() ) ); return ( 8 ); }
    case  10: /* RRC D */
    { D( rrc( D() ) ); return ( 8 ); }
    case  11: /* RRC E */
    { E( rrc( E() ) ); return ( 8 ); }
    case  12: /* RRC H */
    { H( rrc( H() ) ); return ( 8 ); }
    case  13: /* RRC L */
    { L( rrc( L() ) ); return ( 8 ); }
    case  14: /* RRC (HL) */
    {
      int hl = HL();
      pokeb( hl, rrc( peekb( hl ) ) );
      return ( 15 );
    }
    case  15: /* RRC A */
    { A( rrc( A() ) ); return ( 8 ); }

    case  16: /* RL B */
    { B( rl( B() ) ); return ( 8 ); }
    case  17: /* RL C */
    { C( rl( C() ) ); return ( 8 ); }
    case  18: /* RL D */
    { D( rl( D() ) ); return ( 8 ); }
    case  19: /* RL E */
    { E( rl( E() ) ); return ( 8 ); }
    case  20: /* RL H */
    { H( rl( H() ) ); return ( 8 ); }
    case  21: /* RL L */
    { L( rl( L() ) ); return ( 8 ); }
    case  22: /* RL (HL) */
    {
      int hl = HL();
      pokeb( hl, rl( peekb( hl ) ) );
      return ( 15 );
    }
    case  23: /* RL A */
    { A( rl( A() ) ); return ( 8 ); }

    case  24: /* RR B */
    { B( rr( B() ) ); return ( 8 ); }
    case  25: /* RR C */
    { C( rr( C() ) ); return ( 8 ); }
    case  26: /* RR D */
    { D( rr( D() ) ); return ( 8 ); }
    case  27: /* RR E */
    { E( rr( E() ) ); return ( 8 ); }
    case  28: /* RR H */
    { H( rr( H() ) ); return ( 8 ); }
    case  29: /* RR L */
    { L( rr( L() ) ); return ( 8 ); }
    case  30: /* RR (HL) */
    {
      int hl = HL();
      pokeb( hl, rr( peekb( hl ) ) );
      return ( 15 );
    }
    case  31: /* RR A */
    { A( rr( A() ) ); return ( 8 ); }

    case  32: /* SLA B */
    { B( sla( B() ) ); return ( 8 ); }
    case  33: /* SLA C */
    { C( sla( C() ) ); return ( 8 ); }
    case  34: /* SLA D */
    { D( sla( D() ) ); return ( 8 ); }
    case  35: /* SLA E */
    { E( sla( E() ) ); return ( 8 ); }
    case  36: /* SLA H */
    { H( sla( H() ) ); return ( 8 ); }
    case  37: /* SLA L */
    { L( sla( L() ) ); return ( 8 ); }
    case  38: /* SLA (HL) */
    {
      int hl = HL();
      pokeb( hl, sla( peekb( hl ) ) );
      return ( 15 );
    }
    case  39: /* SLA A */
    { A( sla( A() ) ); return ( 8 ); }

    case  40: /* SRA B */
    { B( sra( B() ) ); return ( 8 ); }
    case  41: /* SRA C */
    { C( sra( C() ) ); return ( 8 ); }
    case  42: /* SRA D */
    { D( sra( D() ) ); return ( 8 ); }
    case  43: /* SRA E */
    { E( sra( E() ) ); return ( 8 ); }
    case  44: /* SRA H */
    { H( sra( H() ) ); return ( 8 ); }
    case  45: /* SRA L */
    { L( sra( L() ) ); return ( 8 ); }
    case  46: /* SRA (HL) */
    {
      int hl = HL();
      pokeb( hl, sra( peekb( hl ) ) );
      return ( 15 );
    }
    case  47: /* SRA A */
    { A( sra( A() ) ); return ( 8 ); }

    case  48: /* SLS B */
    { B( sls( B() ) ); return ( 8 ); }
    case  49: /* SLS C */
    { C( sls( C() ) ); return ( 8 ); }
    case  50: /* SLS D */
    { D( sls( D() ) ); return ( 8 ); }
    case  51: /* SLS E */
    { E( sls( E() ) ); return ( 8 ); }
    case  52: /* SLS H */
    { H( sls( H() ) ); return ( 8 ); }
    case  53: /* SLS L */
    { L( sls( L() ) ); return ( 8 ); }
    case  54: /* SLS (HL) */
    {
      int hl = HL();
      pokeb( hl, sls( peekb( hl ) ) );
      return ( 15 );
    }
    case  55: /* SLS A */
    { A( sls( A() ) ); return ( 8 ); }

    case  56: /* SRL B */
    { B( srl( B() ) ); return ( 8 ); }
    case  57: /* SRL C */
    { C( srl( C() ) ); return ( 8 ); }
    case  58: /* SRL D */
    { D( srl( D() ) ); return ( 8 ); }
    case  59: /* SRL E */
    { E( srl( E() ) ); return ( 8 ); }
    case  60: /* SRL H */
    { H( srl( H() ) ); return ( 8 ); }
    case  61: /* SRL L */
    { L( srl( L() ) ); return ( 8 ); }
    case  62: /* SRL (HL) */
    {
      int hl = HL();
      pokeb( hl, srl( peekb( hl ) ) );
      return ( 15 );
    }
    case  63: /* SRL A */
    { A( srl( A() ) ); return ( 8 ); }

    case  64: /* BIT 0,B */
    { bit( 0x01, B() ); return ( 8 ); }
    case  65: /* BIT 0,C */
    { bit( 0x01, C() ); return ( 8 ); }
    case  66: /* BIT 0,D */
    { bit( 0x01, D() ); return ( 8 ); }
    case  67: /* BIT 0,E */
    { bit( 0x01, E() ); return ( 8 ); }
    case  68: /* BIT 0,H */
    { bit( 0x01, H() ); return ( 8 ); }
    case  69: /* BIT 0,L */
    { bit( 0x01, L() ); return ( 8 ); }
    case  70: /* BIT 0,(HL) */
    { bit( 0x01, peekb( HL() ) ); return ( 12 ); }
    case  71: /* BIT 0,A */
    { bit( 0x01, A() ); return ( 8 ); }

    case  72: /* BIT 1,B */
    { bit( 0x02, B() ); return ( 8 ); }
    case  73: /* BIT 1,C */
    { bit( 0x02, C() ); return ( 8 ); }
    case  74: /* BIT 1,D */
    { bit( 0x02, D() ); return ( 8 ); }
    case  75: /* BIT 1,E */
    { bit( 0x02, E() ); return ( 8 ); }
    case  76: /* BIT 1,H */
    { bit( 0x02, H() ); return ( 8 ); }
    case  77: /* BIT 1,L */
    { bit( 0x02, L() ); return ( 8 ); }
    case  78: /* BIT 1,(HL) */
    { bit( 0x02, peekb( HL() ) ); return ( 12 ); }
    case  79: /* BIT 1,A */
    { bit( 0x02, A() ); return ( 8 ); }

    case  80: /* BIT 2,B */
    { bit( 0x04, B() ); return ( 8 ); }
    case  81: /* BIT 2,C */
    { bit( 0x04, C() ); return ( 8 ); }
    case  82: /* BIT 2,D */
    { bit( 0x04, D() ); return ( 8 ); }
    case  83: /* BIT 2,E */
    { bit( 0x04, E() ); return ( 8 ); }
    case  84: /* BIT 2,H */
    { bit( 0x04, H() ); return ( 8 ); }
    case  85: /* BIT 2,L */
    { bit( 0x04, L() ); return ( 8 ); }
    case  86: /* BIT 2,(HL) */
    { bit( 0x04, peekb( HL() ) ); return ( 12 ); }
    case  87: /* BIT 2,A */
    { bit( 0x04, A() ); return ( 8 ); }

    case  88: /* BIT 3,B */
    { bit( 0x08, B() ); return ( 8 ); }
    case  89: /* BIT 3,C */
    { bit( 0x08, C() ); return ( 8 ); }
    case  90: /* BIT 3,D */
    { bit( 0x08, D() ); return ( 8 ); }
    case  91: /* BIT 3,E */
    { bit( 0x08, E() ); return ( 8 ); }
    case  92: /* BIT 3,H */
    { bit( 0x08, H() ); return ( 8 ); }
    case  93: /* BIT 3,L */
    { bit( 0x08, L() ); return ( 8 ); }
    case  94: /* BIT 3,(HL) */
    { bit( 0x08, peekb( HL() ) ); return ( 12 ); }
    case  95: /* BIT 3,A */
    { bit( 0x08, A() ); return ( 8 ); }

    case  96: /* BIT 4,B */
    { bit( 0x10, B() ); return ( 8 ); }
    case  97: /* BIT 4,C */
    { bit( 0x10, C() ); return ( 8 ); }
    case  98: /* BIT 4,D */
    { bit( 0x10, D() ); return ( 8 ); }
    case  99: /* BIT 4,E */
    { bit( 0x10, E() ); return ( 8 ); }
    case 100: /* BIT 4,H */
    { bit( 0x10, H() ); return ( 8 ); }
    case 101: /* BIT 4,L */
    { bit( 0x10, L() ); return ( 8 ); }
    case 102: /* BIT 4,(HL) */
    { bit( 0x10, peekb( HL() ) ); return ( 12 ); }
    case 103: /* BIT 4,A */
    { bit( 0x10, A() ); return ( 8 ); }

    case 104: /* BIT 5,B */
    { bit( 0x20, B() ); return ( 8 ); }
    case 105: /* BIT 5,C */
    { bit( 0x20, C() ); return ( 8 ); }
    case 106: /* BIT 5,D */
    { bit( 0x20, D() ); return ( 8 ); }
    case 107: /* BIT 5,E */
    { bit( 0x20, E() ); return ( 8 ); }
    case 108: /* BIT 5,H */
    { bit( 0x20, H() ); return ( 8 ); }
    case 109: /* BIT 5,L */
    { bit( 0x20, L() ); return ( 8 ); }
    case 110: /* BIT 5,(HL) */
    { bit( 0x20, peekb( HL() ) ); return ( 12 ); }
    case 111: /* BIT 5,A */
    { bit( 0x20, A() ); return ( 8 ); }

    case 112: /* BIT 6,B */
    { bit( 0x40, B() ); return ( 8 ); }
    case 113: /* BIT 6,C */
    { bit( 0x40, C() ); return ( 8 ); }
    case 114: /* BIT 6,D */
    { bit( 0x40, D() ); return ( 8 ); }
    case 115: /* BIT 6,E */
    { bit( 0x40, E() ); return ( 8 ); }
    case 116: /* BIT 6,H */
    { bit( 0x40, H() ); return ( 8 ); }
    case 117: /* BIT 6,L */
    { bit( 0x40, L() ); return ( 8 ); }
    case 118: /* BIT 6,(HL) */
    { bit( 0x40, peekb( HL() ) ); return ( 12 ); }
    case 119: /* BIT 6,A */
    { bit( 0x40, A() ); return ( 8 ); }

    case 120: /* BIT 7,B */
    { bit( 0x80, B() ); return ( 8 ); }
    case 121: /* BIT 7,C */
    { bit( 0x80, C() ); return ( 8 ); }
    case 122: /* BIT 7,D */
    { bit( 0x80, D() ); return ( 8 ); }
    case 123: /* BIT 7,E */
    { bit( 0x80, E() ); return ( 8 ); }
    case 124: /* BIT 7,H */
    { bit( 0x80, H() ); return ( 8 ); }
    case 125: /* BIT 7,L */
    { bit( 0x80, L() ); return ( 8 ); }
    case 126: /* BIT 7,(HL) */
    { bit( 0x80, peekb( HL() ) ); return ( 12 ); }
    case 127: /* BIT 7,A */
    { bit( 0x80, A() ); return ( 8 ); }

    case 128: /* RES 0,B */
    { B( res( 0x01, B() ) ); return ( 8 ); }
    case 129: /* RES 0,C */
    { C( res( 0x01, C() ) ); return ( 8 ); }
    case 130: /* RES 0,D */
    { D( res( 0x01, D() ) ); return ( 8 ); }
    case 131: /* RES 0,E */
    { E( res( 0x01, E() ) ); return ( 8 ); }
    case 132: /* RES 0,H */
    { H( res( 0x01, H() ) ); return ( 8 ); }
    case 133: /* RES 0,L */
    { L( res( 0x01, L() ) ); return ( 8 ); }
    case 134: /* RES 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 135: /* RES 0,A */
    { A( res( 0x01, A() ) ); return ( 8 ); }

    case 136: /* RES 1,B */
    { B( res( 0x02, B() ) ); return ( 8 ); }
    case 137: /* RES 1,C */
    { C( res( 0x02, C() ) ); return ( 8 ); }
    case 138: /* RES 1,D */
    { D( res( 0x02, D() ) ); return ( 8 ); }
    case 139: /* RES 1,E */
    { E( res( 0x02, E() ) ); return ( 8 ); }
    case 140: /* RES 1,H */
    { H( res( 0x02, H() ) ); return ( 8 ); }
    case 141: /* RES 1,L */
    { L( res( 0x02, L() ) ); return ( 8 ); }
    case 142: /* RES 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 143: /* RES 1,A */
    { A( res( 0x02, A() ) ); return ( 8 ); }

    case 144: /* RES 2,B */
    { B( res( 0x04, B() ) ); return ( 8 ); }
    case 145: /* RES 2,C */
    { C( res( 0x04, C() ) ); return ( 8 ); }
    case 146: /* RES 2,D */
    { D( res( 0x04, D() ) ); return ( 8 ); }
    case 147: /* RES 2,E */
    { E( res( 0x04, E() ) ); return ( 8 ); }
    case 148: /* RES 2,H */
    { H( res( 0x04, H() ) ); return ( 8 ); }
    case 149: /* RES 2,L */
    { L( res( 0x04, L() ) ); return ( 8 ); }
    case 150: /* RES 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 151: /* RES 2,A */
    { A( res( 0x04, A() ) ); return ( 8 ); }

    case 152: /* RES 3,B */
    { B( res( 0x08, B() ) ); return ( 8 ); }
    case 153: /* RES 3,C */
    { C( res( 0x08, C() ) ); return ( 8 ); }
    case 154: /* RES 3,D */
    { D( res( 0x08, D() ) ); return ( 8 ); }
    case 155: /* RES 3,E */
    { E( res( 0x08, E() ) ); return ( 8 ); }
    case 156: /* RES 3,H */
    { H( res( 0x08, H() ) ); return ( 8 ); }
    case 157: /* RES 3,L */
    { L( res( 0x08, L() ) ); return ( 8 ); }
    case 158: /* RES 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 159: /* RES 3,A */
    { A( res( 0x08, A() ) ); return ( 8 ); }

    case 160: /* RES 4,B */
    { B( res( 0x10, B() ) ); return ( 8 ); }
    case 161: /* RES 4,C */
    { C( res( 0x10, C() ) ); return ( 8 ); }
    case 162: /* RES 4,D */
    { D( res( 0x10, D() ) ); return ( 8 ); }
    case 163: /* RES 4,E */
    { E( res( 0x10, E() ) ); return ( 8 ); }
    case 164: /* RES 4,H */
    { H( res( 0x10, H() ) ); return ( 8 ); }
    case 165: /* RES 4,L */
    { L( res( 0x10, L() ) ); return ( 8 ); }
    case 166: /* RES 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 167: /* RES 4,A */
    { A( res( 0x10, A() ) ); return ( 8 ); }

    case 168: /* RES 5,B */
    { B( res( 0x20, B() ) ); return ( 8 ); }
    case 169: /* RES 5,C */
    { C( res( 0x20, C() ) ); return ( 8 ); }
    case 170: /* RES 5,D */
    { D( res( 0x20, D() ) ); return ( 8 ); }
    case 171: /* RES 5,E */
    { E( res( 0x20, E() ) ); return ( 8 ); }
    case 172: /* RES 5,H */
    { H( res( 0x20, H() ) ); return ( 8 ); }
    case 173: /* RES 5,L */
    { L( res( 0x20, L() ) ); return ( 8 ); }
    case 174: /* RES 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 175: /* RES 5,A */
    { A( res( 0x20, A() ) ); return ( 8 ); }

    case 176: /* RES 6,B */
    { B( res( 0x40, B() ) ); return ( 8 ); }
    case 177: /* RES 6,C */
    { C( res( 0x40, C() ) ); return ( 8 ); }
    case 178: /* RES 6,D */
    { D( res( 0x40, D() ) ); return ( 8 ); }
    case 179: /* RES 6,E */
    { E( res( 0x40, E() ) ); return ( 8 ); }
    case 180: /* RES 6,H */
    { H( res( 0x40, H() ) ); return ( 8 ); }
    case 181: /* RES 6,L */
    { L( res( 0x40, L() ) ); return ( 8 ); }
    case 182: /* RES 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 183: /* RES 6,A */
    { A( res( 0x40, A() ) ); return ( 8 ); }

    case 184: /* RES 7,B */
    { B( res( 0x80, B() ) ); return ( 8 ); }
    case 185: /* RES 7,C */
    { C( res( 0x80, C() ) ); return ( 8 ); }
    case 186: /* RES 7,D */
    { D( res( 0x80, D() ) ); return ( 8 ); }
    case 187: /* RES 7,E */
    { E( res( 0x80, E() ) ); return ( 8 ); }
    case 188: /* RES 7,H */
    { H( res( 0x80, H() ) ); return ( 8 ); }
    case 189: /* RES 7,L */
    { L( res( 0x80, L() ) ); return ( 8 ); }
    case 190: /* RES 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 191: /* RES 7,A */
    { A( res( 0x80, A() ) ); return ( 8 ); }

    case 192: /* SET 0,B */
    { B( set( 0x01, B() ) ); return ( 8 ); }
    case 193: /* SET 0,C */
    { C( set( 0x01, C() ) ); return ( 8 ); }
    case 194: /* SET 0,D */
    { D( set( 0x01, D() ) ); return ( 8 ); }
    case 195: /* SET 0,E */
    { E( set( 0x01, E() ) ); return ( 8 ); }
    case 196: /* SET 0,H */
    { H( set( 0x01, H() ) ); return ( 8 ); }
    case 197: /* SET 0,L */
    { L( set( 0x01, L() ) ); return ( 8 ); }
    case 198: /* SET 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 199: /* SET 0,A */
    { A( set( 0x01, A() ) ); return ( 8 ); }

    case 200: /* SET 1,B */
    { B( set( 0x02, B() ) ); return ( 8 ); }
    case 201: /* SET 1,C */
    { C( set( 0x02, C() ) ); return ( 8 ); }
    case 202: /* SET 1,D */
    { D( set( 0x02, D() ) ); return ( 8 ); }
    case 203: /* SET 1,E */
    { E( set( 0x02, E() ) ); return ( 8 ); }
    case 204: /* SET 1,H */
    { H( set( 0x02, H() ) ); return ( 8 ); }
    case 205: /* SET 1,L */
    { L( set( 0x02, L() ) ); return ( 8 ); }
    case 206: /* SET 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 207: /* SET 1,A */
    { A( set( 0x02, A() ) ); return ( 8 ); }

    case 208: /* SET 2,B */
    { B( set( 0x04, B() ) ); return ( 8 ); }
    case 209: /* SET 2,C */
    { C( set( 0x04, C() ) ); return ( 8 ); }
    case 210: /* SET 2,D */
    { D( set( 0x04, D() ) ); return ( 8 ); }
    case 211: /* SET 2,E */
    { E( set( 0x04, E() ) ); return ( 8 ); }
    case 212: /* SET 2,H */
    { H( set( 0x04, H() ) ); return ( 8 ); }
    case 213: /* SET 2,L */
    { L( set( 0x04, L() ) ); return ( 8 ); }
    case 214: /* SET 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 215: /* SET 2,A */
    { A( set( 0x04, A() ) ); return ( 8 ); }

    case 216: /* SET 3,B */
    { B( set( 0x08, B() ) ); return ( 8 ); }
    case 217: /* SET 3,C */
    { C( set( 0x08, C() ) ); return ( 8 ); }
    case 218: /* SET 3,D */
    { D( set( 0x08, D() ) ); return ( 8 ); }
    case 219: /* SET 3,E */
    { E( set( 0x08, E() ) ); return ( 8 ); }
    case 220: /* SET 3,H */
    { H( set( 0x08, H() ) ); return ( 8 ); }
    case 221: /* SET 3,L */
    { L( set( 0x08, L() ) ); return ( 8 ); }
    case 222: /* SET 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 223: /* SET 3,A */
    { A( set( 0x08, A() ) ); return ( 8 ); }

    case 224: /* SET 4,B */
    { B( set( 0x10, B() ) ); return ( 8 ); }
    case 225: /* SET 4,C */
    { C( set( 0x10, C() ) ); return ( 8 ); }
    case 226: /* SET 4,D */
    { D( set( 0x10, D() ) ); return ( 8 ); }
    case 227: /* SET 4,E */
    { E( set( 0x10, E() ) ); return ( 8 ); }
    case 228: /* SET 4,H */
    { H( set( 0x10, H() ) ); return ( 8 ); }
    case 229: /* SET 4,L */
    { L( set( 0x10, L() ) ); return ( 8 ); }
    case 230: /* SET 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 231: /* SET 4,A */
    { A( set( 0x10, A() ) ); return ( 8 ); }

    case 232: /* SET 5,B */
    { B( set( 0x20, B() ) ); return ( 8 ); }
    case 233: /* SET 5,C */
    { C( set( 0x20, C() ) ); return ( 8 ); }
    case 234: /* SET 5,D */
    { D( set( 0x20, D() ) ); return ( 8 ); }
    case 235: /* SET 5,E */
    { E( set( 0x20, E() ) ); return ( 8 ); }
    case 236: /* SET 5,H */
    { H( set( 0x20, H() ) ); return ( 8 ); }
    case 237: /* SET 5,L */
    { L( set( 0x20, L() ) ); return ( 8 ); }
    case 238: /* SET 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 239: /* SET 5,A */
    { A( set( 0x20, A() ) ); return ( 8 ); }

    case 240: /* SET 6,B */
    { B( set( 0x40, B() ) ); return ( 8 ); }
    case 241: /* SET 6,C */
    { C( set( 0x40, C() ) ); return ( 8 ); }
    case 242: /* SET 6,D */
    { D( set( 0x40, D() ) ); return ( 8 ); }
    case 243: /* SET 6,E */
    { E( set( 0x40, E() ) ); return ( 8 ); }
    case 244: /* SET 6,H */
    { H( set( 0x40, H() ) ); return ( 8 ); }
    case 245: /* SET 6,L */
    { L( set( 0x40, L() ) ); return ( 8 ); }
    case 246: /* SET 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 247: /* SET 6,A */
    { A( set( 0x40, A() ) ); return ( 8 ); }

    case 248: /* SET 7,B */
    { B( set( 0x80, B() ) ); return ( 8 ); }
    case 249: /* SET 7,C */
    { C( set( 0x80, C() ) ); return ( 8 ); }
    case 250: /* SET 7,D */
    { D( set( 0x80, D() ) ); return ( 8 ); }
    case 251: /* SET 7,E */
    { E( set( 0x80, E() ) ); return ( 8 ); }
    case 252: /* SET 7,H */
    { H( set( 0x80, H() ) ); return ( 8 ); }
    case 253: /* SET 7,L */
    { L( set( 0x80, L() ) ); return ( 8 ); }
    case 254: /* SET 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 255: /* SET 7,A */
    { A( set( 0x80, A() ) ); return ( 8 ); }

    } // end switch

    return 0;
  }

  private  void execute_id_cb(int op, int z) {

    switch ( op ) {

    case   0: /* RLC B */
    { B( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   1: /* RLC C */
    { C( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   2: /* RLC D */
    { D( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   3: /* RLC E */
    { E( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   4: /* RLC H */
    { H( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   5: /* RLC L */
    { L( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   6: /* RLC (HL) */
    { pokeb( z, rlc( peekb( z ) ) ); return; }
    case   7: /* RLC A */
    { A( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }

    case   8: /* RRC B */
    { B( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   9: /* RRC C */
    { C( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  10: /* RRC D */
    { D( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  11: /* RRC E */
    { E( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  12: /* RRC H */
    { H( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  13: /* RRC L */
    { L( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  14: /* RRC (HL) */
    { pokeb( z, rrc( peekb( z ) ) ); return; }
    case  15: /* RRC A */
    { A( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }

    case  16: /* RL B */
    { B( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  17: /* RL C */
    { C( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  18: /* RL D */
    { D( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  19: /* RL E */
    { E( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  20: /* RL H */
    { H( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  21: /* RL L */
    { L( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  22: /* RL (HL) */
    { pokeb( z, rl( peekb( z ) ) ); return; }
    case  23: /* RL A */
    { A( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  24: /* RR B */
    { B( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  25: /* RR C */
    { C( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  26: /* RR D */
    { D( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  27: /* RR E */
    { E( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  28: /* RR H */
    { H( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  29: /* RR L */
    { L( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  30: /* RR (HL) */
    { pokeb( z, rr( peekb( z ) ) ); return; }
    case  31: /* RR A */
    { A( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }

    case  32: /* SLA B */
    { B( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  33: /* SLA C */
    { C( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  34: /* SLA D */
    { D( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  35: /* SLA E */
    { E( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  36: /* SLA H */
    { H( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  37: /* SLA L */
    { L( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  38: /* SLA (HL) */
    { pokeb( z, sla( peekb( z ) ) ); return; }
    case  39: /* SLA A */
    { A( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }

    case  40: /* SRA B */
    { B( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  41: /* SRA C */
    { C( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  42: /* SRA D */
    { D( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  43: /* SRA E */
    { E( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  44: /* SRA H */
    { H( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  45: /* SRA L */
    { L( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  46: /* SRA (HL) */
    { pokeb( z, sra( peekb( z ) ) ); return; }
    case  47: /* SRA A */
    { A( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }

    case  48: /* SLS B */
    { B( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  49: /* SLS C */
    { C( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  50: /* SLS D */
    { D( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  51: /* SLS E */
    { E( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  52: /* SLS H */
    { H( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  53: /* SLS L */
    { L( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  54: /* SLS (HL) */
    { pokeb( z, sls( peekb( z ) ) ); return; }
    case  55: /* SLS A */
    { A( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }

    case  56: /* SRL B */
    { B( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  57: /* SRL C */
    { C( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  58: /* SRL D */
    { D( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  59: /* SRL E */
    { E( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  60: /* SRL H */
    { H( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  61: /* SRL L */
    { L( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  62: /* SRL (HL) */
    { pokeb( z, srl( peekb( z ) ) ); return; }
    case  63: /* SRL A */
    { A( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  64: /* BIT 0,B */
    case  65: /* BIT 0,B */
    case  66: /* BIT 0,B */
    case  67: /* BIT 0,B */
    case  68: /* BIT 0,B */
    case  69: /* BIT 0,B */
    case  70: /* BIT 0,B */
    case  71: /* BIT 0,B */
    { bit( 0x01, peekb( z ) ); return; }

    case  72: /* BIT 1,B */
    case  73: /* BIT 1,B */
    case  74: /* BIT 1,B */
    case  75: /* BIT 1,B */
    case  76: /* BIT 1,B */
    case  77: /* BIT 1,B */
    case  78: /* BIT 1,B */
    case  79: /* BIT 1,B */
    { bit( 0x02, peekb( z ) ); return; }

    case  80: /* BIT 2,B */
    case  81: /* BIT 2,B */
    case  82: /* BIT 2,B */
    case  83: /* BIT 2,B */
    case  84: /* BIT 2,B */
    case  85: /* BIT 2,B */
    case  86: /* BIT 2,B */
    case  87: /* BIT 2,B */
    { bit( 0x04, peekb( z ) ); return; }

    case  88: /* BIT 3,B */
    case  89: /* BIT 3,B */
    case  90: /* BIT 3,B */
    case  91: /* BIT 3,B */
    case  92: /* BIT 3,B */
    case  93: /* BIT 3,B */
    case  94: /* BIT 3,B */
    case  95: /* BIT 3,B */
    { bit( 0x08, peekb( z ) ); return; }

    case  96: /* BIT 4,B */
    case  97: /* BIT 4,B */
    case  98: /* BIT 4,B */
    case  99: /* BIT 4,B */
    case 100: /* BIT 4,B */
    case 101: /* BIT 4,B */
    case 102: /* BIT 4,B */
    case 103: /* BIT 4,B */
    { bit( 0x10, peekb( z ) ); return; }

    case 104: /* BIT 5,B */
    case 105: /* BIT 5,B */
    case 106: /* BIT 5,B */
    case 107: /* BIT 5,B */
    case 108: /* BIT 5,B */
    case 109: /* BIT 5,B */
    case 110: /* BIT 5,B */
    case 111: /* BIT 5,B */
    { bit( 0x20, peekb( z ) ); return; }

    case 112: /* BIT 6,B */
    case 113: /* BIT 6,B */
    case 114: /* BIT 6,B */
    case 115: /* BIT 6,B */
    case 116: /* BIT 6,B */
    case 117: /* BIT 6,B */
    case 118: /* BIT 6,B */
    case 119: /* BIT 6,B */
    { bit( 0x40, peekb( z ) ); return; }

    case 120: /* BIT 7,B */
    case 121: /* BIT 7,B */
    case 122: /* BIT 7,B */
    case 123: /* BIT 7,B */
    case 124: /* BIT 7,B */
    case 125: /* BIT 7,B */
    case 126: /* BIT 7,B */
    case 127: /* BIT 7,B */
    { bit( 0x80, peekb( z ) ); return; }

    case 128: /* RES 0,B */
    { B( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 129: /* RES 0,C */
    { C( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 130: /* RES 0,D */
    { D( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 131: /* RES 0,E */
    { E( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 132: /* RES 0,H */
    { H( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 133: /* RES 0,L */
    { L( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 134: /* RES 0,(HL) */
    { pokeb( z, res( 0x01, peekb( z ) ) ); return; }
    case 135: /* RES 0,A */
    { A( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 136: /* RES 1,B */
    { B( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 137: /* RES 1,C */
    { C( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 138: /* RES 1,D */
    { D( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 139: /* RES 1,E */
    { E( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 140: /* RES 1,H */
    { H( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 141: /* RES 1,L */
    { L( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 142: /* RES 1,(HL) */
    { pokeb( z, res( 0x02, peekb( z ) ) ); return; }
    case 143: /* RES 1,A */
    { A( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 144: /* RES 2,B */
    { B( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 145: /* RES 2,C */
    { C( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 146: /* RES 2,D */
    { D( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 147: /* RES 2,E */
    { E( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 148: /* RES 2,H */
    { H( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 149: /* RES 2,L */
    { L( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 150: /* RES 2,(HL) */
    { pokeb( z, res( 0x04, peekb( z ) ) ); return; }
    case 151: /* RES 2,A */
    { A( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 152: /* RES 3,B */
    { B( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 153: /* RES 3,C */
    { C( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 154: /* RES 3,D */
    { D( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 155: /* RES 3,E */
    { E( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 156: /* RES 3,H */
    { H( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 157: /* RES 3,L */
    { L( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 158: /* RES 3,(HL) */
    { pokeb( z, res( 0x08, peekb( z ) ) ); return; }
    case 159: /* RES 3,A */
    { A( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 160: /* RES 4,B */
    { B( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 161: /* RES 4,C */
    { C( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 162: /* RES 4,D */
    { D( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 163: /* RES 4,E */
    { E( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 164: /* RES 4,H */
    { H( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 165: /* RES 4,L */
    { L( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 166: /* RES 4,(HL) */
    { pokeb( z, res( 0x10, peekb( z ) ) ); return; }
    case 167: /* RES 4,A */
    { A( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 168: /* RES 5,B */
    { B( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 169: /* RES 5,C */
    { C( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 170: /* RES 5,D */
    { D( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 171: /* RES 5,E */
    { E( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 172: /* RES 5,H */
    { H( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 173: /* RES 5,L */
    { L( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 174: /* RES 5,(HL) */
    { pokeb( z, res( 0x20, peekb( z ) ) ); return; }
    case 175: /* RES 5,A */
    { A( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 176: /* RES 6,B */
    { B( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 177: /* RES 6,C */
    { C( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 178: /* RES 6,D */
    { D( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 179: /* RES 6,E */
    { E( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 180: /* RES 6,H */
    { H( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 181: /* RES 6,L */
    { L( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 182: /* RES 6,(HL) */
    { pokeb( z, res( 0x40, peekb( z ) ) ); return; }
    case 183: /* RES 6,A */
    { A( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 184: /* RES 7,B */
    { B( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 185: /* RES 7,C */
    { C( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 186: /* RES 7,D */
    { D( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 187: /* RES 7,E */
    { E( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 188: /* RES 7,H */
    { H( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 189: /* RES 7,L */
    { L( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 190: /* RES 7,(HL) */
    { pokeb( z, res( 0x80, peekb( z ) ) ); return; }
    case 191: /* RES 7,A */
    { A( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    case 192: /* SET 0,B */
    { B( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 193: /* SET 0,C */
    { C( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 194: /* SET 0,D */
    { D( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 195: /* SET 0,E */
    { E( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 196: /* SET 0,H */
    { H( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 197: /* SET 0,L */
    { L( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 198: /* SET 0,(HL) */
    { pokeb( z, set( 0x01, peekb( z ) ) ); return; }
    case 199: /* SET 0,A */
    { A( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 200: /* SET 1,B */
    { B( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 201: /* SET 1,C */
    { C( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 202: /* SET 1,D */
    { D( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 203: /* SET 1,E */
    { E( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 204: /* SET 1,H */
    { H( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 205: /* SET 1,L */
    { L( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 206: /* SET 1,(HL) */
    { pokeb( z, set( 0x02, peekb( z ) ) ); return; }
    case 207: /* SET 1,A */
    { A( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 208: /* SET 2,B */
    { B( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 209: /* SET 2,C */
    { C( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 210: /* SET 2,D */
    { D( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 211: /* SET 2,E */
    { E( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 212: /* SET 2,H */
    { H( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 213: /* SET 2,L */
    { L( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 214: /* SET 2,(HL) */
    { pokeb( z, set( 0x04, peekb( z ) ) ); return; }
    case 215: /* SET 2,A */
    { A( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 216: /* SET 3,B */
    { B( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 217: /* SET 3,C */
    { C( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 218: /* SET 3,D */
    { D( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 219: /* SET 3,E */
    { E( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 220: /* SET 3,H */
    { H( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 221: /* SET 3,L */
    { L( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 222: /* SET 3,(HL) */
    { pokeb( z, set( 0x08, peekb( z ) ) ); return; }
    case 223: /* SET 3,A */
    { A( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 224: /* SET 4,B */
    { B( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 225: /* SET 4,C */
    { C( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 226: /* SET 4,D */
    { D( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 227: /* SET 4,E */
    { E( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 228: /* SET 4,H */
    { H( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 229: /* SET 4,L */
    { L( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 230: /* SET 4,(HL) */
    { pokeb( z, set( 0x10, peekb( z ) ) ); return; }
    case 231: /* SET 4,A */
    { A( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 232: /* SET 5,B */
    { B( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 233: /* SET 5,C */
    { C( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 234: /* SET 5,D */
    { D( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 235: /* SET 5,E */
    { E( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 236: /* SET 5,H */
    { H( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 237: /* SET 5,L */
    { L( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 238: /* SET 5,(HL) */
    { pokeb( z, set( 0x20, peekb( z ) ) ); return; }
    case 239: /* SET 5,A */
    { A( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 240: /* SET 6,B */
    { B( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 241: /* SET 6,C */
    { C( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 242: /* SET 6,D */
    { D( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 243: /* SET 6,E */
    { E( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 244: /* SET 6,H */
    { H( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 245: /* SET 6,L */
    { L( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 246: /* SET 6,(HL) */
    { pokeb( z, set( 0x40, peekb( z ) ) ); return; }
    case 247: /* SET 6,A */
    { A( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 248: /* SET 7,B */
    { B( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 249: /* SET 7,C */
    { C( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 250: /* SET 7,D */
    { D( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 251: /* SET 7,E */
    { E( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 252: /* SET 7,H */
    { H( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 253: /* SET 7,L */
    { L( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 254: /* SET 7,(HL) */
    { pokeb( z, set( 0x80, peekb( z ) ) ); return; }
    case 255: /* SET 7,A */
    { A( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    } // end switch
  }

  private  int execute_id() {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case  0: /* NOP */
    case  1:
    case  2:
    case  3:
    case  4:
    case  5:
    case  6:
    case  7:
    case  8:

    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:

    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:

    case 39:
    case 40:

    case 47:
    case 48:
    case 49:
    case 50:
    case 51:

    case 55:
    case 56:

    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:

    case 71:
    case 72:
    case 73:
    case 74:
    case 75:

    case 79:
    case 80:
    case 81:
    case 82:
    case 83:

    case 87:
    case 88:
    case 89:
    case 90:
    case 91:

    case 95:

    case 120:
    case 121:
    case 122:
    case 123:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:

    case 135:
    case 136:
    case 137:
    case 138:
    case 139:

    case 143:
    case 144:
    case 145:
    case 146:
    case 147:

    case 151:
    case 152:
    case 153:
    case 154:
    case 155:

    case 159:
    case 160:
    case 161:
    case 162:
    case 163:

    case 167:
    case 168:
    case 169:
    case 170:
    case 171:

    case 175:
    case 176:
    case 177:
    case 178:
    case 179:

    case 183:
    case 184:
    case 185:
    case 186:
    case 187:

    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:

    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:

    case 226:

    case 228:

    case 230:
    case 231:
    case 232:

    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    {
      PC( dec16( PC() ) );
      REFRESH( -1 );
      return ( 4 );
    }

    case  9: /* ADD ID,BC */
    { ID( add16( ID(), BC() ) ); return ( 15 ); }
    case 25: /* ADD ID,DE */
    { ID( add16( ID(), DE() ) ); return ( 15 ); }
    case 41: /* ADD ID,ID */
    {
      int id = ID();
      ID( add16( id, id ) );
      return ( 15 );
    }
    case 57: /* ADD ID,SP */
    { ID( add16( ID(),SP() ) ); return ( 15 ); }

    case 33: /* LD ID,nn */
    { ID( nxtpcw() ); return ( 14 ); }
    case 34: /* LD (nn),ID */
    { pokew( nxtpcw(), ID() ); return ( 20 ); }
    case 42: /* LD ID,(nn) */
    { ID( peekw( nxtpcw() ) ); return ( 20 ); }
    case 35:/* INC ID */
    { ID( inc16( ID() ) ); return ( 10 ); }
    case 43:/* DEC ID */
    { ID( dec16( ID() ) ); return ( 10 ); }
    case 36:/* INC IDH */
    { IDH( inc8( IDH() ) ); return ( 8 ); }
    case 44:/* INC IDL */
    { IDL( inc8( IDL() ) ); return ( 8 ); }
    case 52:/* INC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, inc8( peekb(z) ) );
        return ( 23 );
    }
    case 37:/* DEC IDH */
    { IDH( dec8( IDH() ) ); return ( 8 ); }
    case 45:/* DEC IDL */
    { IDL( dec8( IDL() ) ); return ( 8 ); }
    case 53:/* DEC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, dec8( peekb(z) ) );
        return ( 23 );
    }

    case 38: /* LD IDH,n */
    { IDH( nxtpcb() ); return ( 11 ); }
    case 46: /* LD IDL,n */
    { IDL( nxtpcb() ); return ( 11 ); }
    case 54: /* LD (ID+d),n */
    { int z = ID_d(); pokeb(z,nxtpcb()); return ( 19 ); }

    case 68: /* LD B,IDH */
    { B( IDH() ); return ( 8 ); }
    case 69: /* LD B,IDL */
    { B( IDL() ); return ( 8 ); }
    case 70: /* LD B,(ID+d) */
    { B( peekb( ID_d() ) ); return ( 19 ); }

    case 76: /* LD C,IDH */
    { C( IDH() ); return ( 8 ); }
    case 77: /* LD C,IDL */
    { C( IDL() ); return ( 8 ); }
    case 78: /* LD C,(ID+d) */
    { C( peekb( ID_d() ) ); return ( 19 ); }

    case 84: /* LD D,IDH */
    { D( IDH() ); return ( 8 ); }
    case 85: /* LD D,IDL */
    { D( IDL() ); return ( 8 ); }
    case 86: /* LD D,(ID+d) */
    { D( peekb( ID_d() ) ); return ( 19 ); }

    case 92: /* LD E,IDH */
    { E( IDH() ); return ( 8 ); }
    case 93: /* LD E,IDL */
    { E( IDL() ); return ( 8 ); }
    case 94: /* LD E,(ID+d) */
    { E( peekb( ID_d() ) ); return ( 19 ); }

    case 96: /* LD IDH,B */
    { IDH( B() ); return ( 8 ); }
    case 97: /* LD IDH,C */
    { IDH( C() ); return ( 8 ); }
    case 98: /* LD IDH,D */
    { IDH( D() ); return ( 8 ); }
    case 99: /* LD IDH,E */
    { IDH( E() ); return ( 8 ); }
    case 100: /* LD IDH,IDH */
    { return ( 8 ); }
    case 101: /* LD IDH,IDL */
    { IDH( IDL() ); return ( 8 ); }
    case 102: /* LD H,(ID+d) */
    { H( peekb( ID_d() ) ); return ( 19 ); }
    case 103: /* LD IDH,A */
    { IDH( A() ); return ( 8 ); }

    case 104: /* LD IDL,B */
    { IDL( B() ); return ( 8 ); }
    case 105: /* LD IDL,C */
    { IDL( C() ); return ( 8 ); }
    case 106: /* LD IDL,D */
    { IDL( D() ); return ( 8 ); }
    case 107: /* LD IDL,E */
    { IDL( E() ); return ( 8 ); }
    case 108: /* LD IDL,IDH */
    { IDL( IDH() ); return ( 8 ); }
    case 109: /* LD IDL,IDL */
    { return ( 8 ); }
    case 110: /* LD L,(ID+d) */
    { L( peekb( ID_d() ) ); return ( 19 ); }
    case 111: /* LD IDL,A */
    { IDL( A() ); return ( 8 ); }

    case 112: /* LD (ID+d),B */
    { pokeb( ID_d(), B() ); return ( 19 ); }
    case 113: /* LD (ID+d),C */
    { pokeb( ID_d(), C() ); return ( 19 ); }
    case 114: /* LD (ID+d),D */
    { pokeb( ID_d(), D() ); return ( 19 ); }
    case 115: /* LD (ID+d),E */
    { pokeb( ID_d(), E() ); return ( 19 ); }
    case 116: /* LD (ID+d),H */
    { pokeb( ID_d(), H() ); return ( 19 ); }
    case 117: /* LD (ID+d),L */
    { pokeb( ID_d(), L() ); return ( 19 ); }
    case 119: /* LD (ID+d),A */
    { pokeb( ID_d(), A() ); return ( 19 ); }

    case 124: /* LD A,IDH */
    { A( IDH() ); return ( 8 ); }
    case 125: /* LD A,IDL */
    { A( IDL() ); return ( 8 ); }
    case 126: /* LD A,(ID+d) */
    { A( peekb( ID_d() ) ); return ( 19 ); }

    case 132: /* ADD A,IDH */
    { add_a(IDH()); return ( 8 ); }
    case 133: /* ADD A,IDL */
    { add_a(IDL()); return ( 8 ); }
    case 134: /* ADD A,(ID+d) */
    { add_a(peekb( ID_d() )); return ( 19 ); }

    case 140: /* ADC A,IDH */
    { adc_a(IDH()); return ( 8 ); }
    case 141: /* ADC A,IDL */
    { adc_a(IDL()); return ( 8 ); }
    case 142: /* ADC A,(ID+d) */
    { adc_a(peekb( ID_d() )); return ( 19 ); }

    case 148: /* SUB IDH */
    { sub_a(IDH()); return ( 8 ); }
    case 149: /* SUB IDL */
    { sub_a(IDL()); return ( 8 ); }
    case 150: /* SUB (ID+d) */
    { sub_a(peekb( ID_d() )); return ( 19 ); }

    case 156: /* SBC A,IDH */
    { sbc_a(IDH()); return ( 8 ); }
    case 157: /* SBC A,IDL */
    { sbc_a(IDL()); return ( 8 ); }
    case 158: /* SBC A,(ID+d) */
    { sbc_a(peekb( ID_d() )); return ( 19 ); }

    case 164: /* AND IDH */
    { and_a(IDH()); return ( 8 ); }
    case 165: /* AND IDL */
    { and_a(IDL()); return ( 8 ); }
    case 166: /* AND (ID+d) */
    { and_a(peekb( ID_d() )); return ( 19 ); }

    case 172: /* XOR IDH */
    { xor_a(IDH()); return ( 8 ); }
    case 173: /* XOR IDL */
    { xor_a(IDL()); return ( 8 ); }
    case 174: /* XOR (ID+d) */
    { xor_a(peekb( ID_d() )); return ( 19 ); }

    case 180: /* OR IDH */
    { or_a(IDH()); return ( 8 ); }
    case 181: /* OR IDL */
    { or_a(IDL()); return ( 8 ); }
    case 182: /* OR (ID+d) */
    { or_a(peekb( ID_d() )); return ( 19 ); }

    case 188: /* CP IDH */
    { cp_a(IDH()); return ( 8 ); }
    case 189: /* CP IDL */
    { cp_a(IDL()); return ( 8 ); }
    case 190: /* CP (ID+d) */
    { cp_a(peekb( ID_d() )); return ( 19 ); }

    case 225: /* POP ID */
    { ID( popw() ); return ( 14 ); }

    case 233: /* JP (ID) */
    { PC( ID() ); return ( 8 ); }

    case 249: /* LD SP,ID */
    { SP( ID() ); return ( 10 ); }

    case 203: /* prefix CB */
    {
      // Get index address (offset byte is first)
      int z = ID_d();
      // Opcode comes after offset byte
      int op = nxtpcb();
      execute_id_cb( op, z );
      // Bit instructions take 20 T states, rest 23
      return ( (( op & 0xc0 ) == 0x40) ? 20 : 23 );
    }

    case 227: /* EX (SP),ID */
    {
      int t = ID();
      int sp = SP();
      ID( peekw( sp ) );
      pokew( sp, t );
      return ( 23 );
    }

    case 229:    /* PUSH ID */
    { pushw( ID() ); return ( 15 ); }

    } // end switch

    return 0;
  }


  int global_tstates = -tstatesPerInterrupt;

  /** Z80 fetch/execute loop */
  void execute(float time) {
  
    int    local_tstates = global_tstates;

    int ticksLimit = local_tstates + round(time * clockSpeed * 1e6);

    //trace("delta: " + inttostr(time*1000));
    //trace("ticks: " + inttostr(round(time * clockSpeed * 1e6)));

    int lastticks;
    if(PROFILE)
      lastticks=GetTickCount();

    while ( local_tstates < ticksLimit ) {

    int instruction;

    if(PROFILE) {
      int now=GetTickCount();
      if(now-lastticks>10) {
        trace("Instruction " + intToStr(instruction) + " took " + inttostr(now-lastticks) + "ms");
      }
      lastticks=GetTickCount();
    }

    if ( interruptTriggered( local_tstates ) ) {
      int intTime=tstatesPerInterrupt - interrupt();
      local_tstates -= intTime;
      ticksLimit -= intTime;
    }


    if(DEBUGTRACE) {
      trace("pc: " + inttostr(_PC));
    }

    REFRESH( 1 );


    instruction=nxtpcb();
    switch ( instruction ) {

    case 0:    /* NOP */
    {
      local_tstates += ( 4 );
      break;
    }
    case 8:    /* EX AF,AF' */
    {
      ex_af_af();
      local_tstates += ( 4 );
      break;
    }
    case 16:    /* DJNZ dis */
    {
      int  b;

      B( b = qdec8( B() ) );
      if (b != 0) {
        int d =  getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 13 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 8 );
      }
      break;
    }
    case 24: /* JR dis */
    {
      int d = getSignedByte(nxtpcb());
      PC( (PC()+d)&0xffff );
      local_tstates += ( 12 );
      break;
    }
    /* JR cc,dis */
    case 32:    /* JR NZ,dis */
    {
      if (!Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 40:    /* JR Z,dis */
    {
      if ( Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 48:    /* JR NC,dis */
    {
      if (!Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 56:    /* JR C,dis */
    {
      if ( Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }

    /* LD rr,nn / ADD HL,rr */
    case 1:    /* LD BC(),nn */
    {
      BC( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 9:    /* ADD HL,BC */
     {
      HL( add16( HL(), BC() ) );
      local_tstates += ( 11 );
      break;
    }
    case 17:    /* LD DE,nn */
    {
      DE( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 25:    /* ADD HL,DE */
    {
      HL( add16( HL(), DE() ) );
      local_tstates += ( 11 );
      break;
    }
    case 33:    /* LD HL,nn */
    {
      HL( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 41:    /* ADD HL,HL */
    {
      int hl = HL();
      HL( add16( hl, hl ) );
      local_tstates += ( 11 );
      break;
    }
    case 49:    /* LD SP,nn */
    {
      SP( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 57:    /* ADD HL,SP */
    {
      HL( add16( HL(), SP() ) );
      local_tstates += ( 11 );
      break;
    }

    /* LD (**),A/A,(**) */
    case 2:    /* LD (BC),A */
    { pokeb( BC(), A() ); local_tstates += ( 7 ); break; }
    case 10:    /* LD A,(BC) */
    { A( peekb( BC() ) ); local_tstates += ( 7 ); break; }
    case 18:    /* LD (DE),A */
    { pokeb( DE(), A() ); local_tstates += ( 7 ); break; }
    case 26:    /* LD A,(DE) */
    { A( peekb( DE() ) ); local_tstates += ( 7 ); break; }
    case 34:    /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); local_tstates += ( 16 ); break; }
    case 42:    /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); local_tstates += ( 16 ); break; }
    case 50:    /* LD (nn),A */
    { pokeb( nxtpcw(), A() ); local_tstates += ( 13 ); break; }
    case 58:    /* LD A,(nn) */
    { A( peekb( nxtpcw() ) ); local_tstates += ( 13 ); break; }

    /* INC/DEC * */
    case 3:    /* INC BC */
    { BC( inc16( BC() ) ); local_tstates += ( 6 ); break; }
    case 11:    /* DEC BC */
    { BC( dec16( BC() ) ); local_tstates += ( 6 ); break; }
    case 19:    /* INC DE */
    { DE( inc16( DE() ) ); local_tstates += ( 6 ); break; }
    case 27:    /* DEC DE */
    { DE( dec16( DE() ) ); local_tstates += ( 6 ); break; }
    case 35:    /* INC HL */
    { HL( inc16( HL() ) ); local_tstates += ( 6 ); break; }
    case 43:    /* DEC HL */
    { HL( dec16( HL() ) ); local_tstates += ( 6 ); break; }
    case 51:    /* INC SP */
    { SP( inc16( SP() ) ); local_tstates += ( 6 ); break; }
    case 59:    /* DEC SP */
    { SP( dec16( SP() ) ); local_tstates += ( 6 ); break; }

    /* INC * */
    case 4:    /* INC B */
    { B( inc8( B() ) ); local_tstates += ( 4 ); break; }
    case 12:    /* INC C */
    { C( inc8( C() ) ); local_tstates += ( 4 ); break; }
    case 20:    /* INC D */
    { D( inc8( D() ) ); local_tstates += ( 4 ); break; }
    case 28:    /* INC E */
    { E( inc8( E() ) ); local_tstates += ( 4 ); break; }
    case 36:    /* INC H */
    { H( inc8( H() ) ); local_tstates += ( 4 ); break; }
    case 44:    /* INC L */
    { L( inc8( L() ) ); local_tstates += ( 4 ); break; }
    case 52:    /* INC (HL) */
    {
      int hl = HL();
      pokeb( hl, inc8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 60:    /* INC A() */
    { A( inc8( A() ) ); local_tstates += ( 4 ); break; }

    /* DEC * */
    case 5:    /* DEC B */
    { B( dec8( B() ) ); local_tstates += ( 4 ); break; }
    case 13:    /* DEC C */
    { C( dec8( C() ) ); local_tstates += ( 4 ); break; }
    case 21:    /* DEC D */
    { D( dec8( D() ) ); local_tstates += ( 4 ); break; }
    case 29:    /* DEC E */
    { E( dec8( E() ) ); local_tstates += ( 4 ); break; }
    case 37:    /* DEC H */
    { H( dec8( H() ) ); local_tstates += ( 4 ); break; }
    case 45:    /* DEC L */
    { L( dec8( L() ) ); local_tstates += ( 4 ); break; }
    case 53:    /* DEC (HL) */
    {
      int hl = HL();
      pokeb( hl, dec8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 61:    /* DEC A() */
    { A( dec8( A() ) ); local_tstates += ( 4 ); break; }

    /* LD *,N */
    case 6:    /* LD B,n */
    { B( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 14:    /* LD C,n */
    { C( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 22:    /* LD D,n */
    { D( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 30:    /* LD E,n */
    { E( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 38:    /* LD H,n */
    { H( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 46:    /* LD L,n */
    { L( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 54:    /* LD (HL),n */
    {
      pokeb( HL(), nxtpcb() );
      local_tstates += ( 10 );
      break;
    }
    case 62:    /* LD A,n */
    { A( nxtpcb() ); local_tstates += ( 7 ); break; }

    /* R**A */
    case 7: /* RLCA */
    { rlc_a(); local_tstates += ( 4 ); break; }
    case 15: /* RRCA */
    { rrc_a(); local_tstates += ( 4 ); break; }
    case 23: /* RLA */
    { rl_a(); local_tstates += ( 4 ); break; }
    case 31: /* RRA */
    { rr_a(); local_tstates += ( 4 ); break; }
    case 39: /* DAA */
    { daa_a(); local_tstates += ( 4 ); break; }
    case 47: /* CPL */
    { cpl_a(); local_tstates += ( 4 ); break; }
    case 55: /* SCF */
    { scf(); local_tstates += ( 4 ); break; }
    case 63: /* CCF */
    { ccf(); local_tstates += ( 4 ); break; }

    /* LD B,* */
    case 64:    /* LD B,B */
    { local_tstates += ( 4 ); break; }
    case 65:    /* LD B,C */
    { B( C() ); local_tstates += ( 4 ); break; }
    case 66:    /* LD B,D */
    { B( D() ); local_tstates += ( 4 ); break; }
    case 67:    /* LD B,E */
    { B( E() ); local_tstates += ( 4 ); break; }
    case 68:    /* LD B,H */
    { B( H() ); local_tstates += ( 4 ); break; }
    case 69:    /* LD B,L */
    { B( L() ); local_tstates += ( 4 ); break; }
    case 70:    /* LD B,(HL) */
    { B( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 71:    /* LD B,A */
    { B( A() ); local_tstates += ( 4 ); break; }

    /* LD C,* */
    case 72:    /* LD C,B */
    { C( B() ); local_tstates += ( 4 ); break; }
    case 73:    /* LD C,C */
    { local_tstates += ( 4 ); break; }
    case 74:    /* LD C,D */
    { C( D() ); local_tstates += ( 4 ); break; }
    case 75:    /* LD C,E */
    { C( E() ); local_tstates += ( 4 ); break; }
    case 76:    /* LD C,H */
    { C( H() ); local_tstates += ( 4 ); break; }
    case 77:    /* LD C,L */
    { C( L() ); local_tstates += ( 4 ); break; }
    case 78:    /* LD C,(HL) */
    { C( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 79:    /* LD C,A */
    { C( A() ); local_tstates += ( 4 ); break; }

    /* LD D,* */
    case 80:    /* LD D,B */
    { D( B() ); local_tstates += ( 4 ); break; }
    case 81:    /* LD D,C */
    { D( C() ); local_tstates += ( 4 ); break; }
    case 82:    /* LD D,D */
    { local_tstates += ( 4 ); break; }
    case 83:    /* LD D,E */
    { D( E() ); local_tstates += ( 4 ); break; }
    case 84:    /* LD D,H */
    { D( H() ); local_tstates += ( 4 ); break; }
    case 85:    /* LD D,L */
    { D( L() ); local_tstates += ( 4 ); break; }
    case 86:    /* LD D,(HL) */
    { D( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 87:    /* LD D,A */
    { D( A() ); local_tstates += ( 4 ); break; }

    /* LD E,* */
    case 88:    /* LD E,B */
    { E( B() ); local_tstates += ( 4 ); break; }
    case 89:    /* LD E,C */
    { E( C() ); local_tstates += ( 4 ); break; }
    case 90:    /* LD E,D */
    { E( D() ); local_tstates += ( 4 ); break; }
    case 91:    /* LD E,E */
    { local_tstates += ( 4 ); break; }
    case 92:    /* LD E,H */
    { E( H() ); local_tstates += ( 4 ); break; }
    case 93:    /* LD E,L */
    { E( L() ); local_tstates += ( 4 ); break; }
    case 94:    /* LD E,(HL) */
    { E( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 95:    /* LD E,A */
    { E( A() ); local_tstates += ( 4 ); break; }

    /* LD H,* */
    case 96:    /* LD H,B */
    { H( B() ); local_tstates += ( 4 ); break; }
    case 97:    /* LD H,C */
    { H( C() ); local_tstates += ( 4 ); break; }
    case 98:    /* LD H,D */
    { H( D() ); local_tstates += ( 4 ); break; }
    case 99:    /* LD H,E */
    { H( E() ); local_tstates += ( 4 ); break; }
    case 100: /* LD H,H */
    { local_tstates += ( 4 ); break; }
    case 101:    /* LD H,L */
    { H( L() ); local_tstates += ( 4 ); break; }
    case 102:    /* LD H,(HL) */
    { H( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 103:    /* LD H,A */
    { H( A() ); local_tstates += ( 4 ); break; }

    /* LD L,* */
    case 104:    /* LD L,B */
    { L( B() ); local_tstates += ( 4 ); break; }
    case 105:    /* LD L,C */
    { L( C() ); local_tstates += ( 4 ); break; }
    case 106:    /* LD L,D */
    { L( D() ); local_tstates += ( 4 ); break; }
    case 107:    /* LD L,E */
    { L( E() ); local_tstates += ( 4 ); break; }
    case 108:    /* LD L,H */
    { L( H() ); local_tstates += ( 4 ); break; }
    case 109:    /* LD L,L */
    { local_tstates += ( 4 ); break; }
    case 110:    /* LD L,(HL) */
    { L( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 111:    /* LD L,A */
    { L( A() ); local_tstates += ( 4 ); break; }

    /* LD (HL),* */
    case 112:    /* LD (HL),B */
    { pokeb( HL(), B() ); local_tstates += ( 7 ); break; }
    case 113:    /* LD (HL),C */
    { pokeb( HL(), C() ); local_tstates += ( 7 ); break; }
    case 114:    /* LD (HL),D */
    { pokeb( HL(), D() ); local_tstates += ( 7 ); break; }
    case 115:    /* LD (HL),E */
    { pokeb( HL(), E() ); local_tstates += ( 7 ); break; }
    case 116:    /* LD (HL),H */
    { pokeb( HL(), H() ); local_tstates += ( 7 ); break; }
    case 117:    /* LD (HL),L */
    { pokeb( HL(), L() ); local_tstates += ( 7 ); break; }
    case 118:    /* HALT */
    {
      int  haltsToInterrupt = (((-local_tstates-1) / 4)+1);
      local_tstates += (haltsToInterrupt*4);
      REFRESH( haltsToInterrupt-1 );
      break;
    }
    case 119:    /* LD (HL),A */
    { pokeb( HL(), A() ); local_tstates += ( 7 ); break; }

    /* LD A,* */
    case 120:    /* LD A,B */
    { A( B() ); local_tstates += ( 4 ); break; }
    case 121:    /* LD A,C */
    { A( C() ); local_tstates += ( 4 ); break; }
    case 122:    /* LD A,D */
    { A( D() ); local_tstates += ( 4 ); break; }
    case 123:    /* LD A,E */
    { A( E() ); local_tstates += ( 4 ); break; }
    case 124:    /* LD A,H */
    { A( H() ); local_tstates += ( 4 ); break; }
    case 125:    /* LD A,L */
    { A( L() ); local_tstates += ( 4 ); break; }
    case 126:    /* LD A,(HL) */
    { A( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 127:    /* LD A,A */
    { local_tstates += ( 4 ); break; }

    /* ADD A,* */
    case 128:    /* ADD A,B */
    { add_a( B() ); local_tstates += ( 4 ); break; }
    case 129:    /* ADD A,C */
    { add_a( C() ); local_tstates += ( 4 ); break; }
    case 130:    /* ADD A,D */
    { add_a( D() ); local_tstates += ( 4 ); break; }
    case 131:    /* ADD A,E */
    { add_a( E() ); local_tstates += ( 4 ); break; }
    case 132:    /* ADD A,H */
    { add_a( H() ); local_tstates += ( 4 ); break; }
    case 133:    /* ADD A,L */
    { add_a( L() ); local_tstates += ( 4 ); break; }
    case 134:    /* ADD A,(HL) */
    { add_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 135:    /* ADD A,A */
    { add_a( A() ); local_tstates += ( 4 ); break; }

    /* ADC A,* */
    case 136:    /* ADC A,B */
    { adc_a( B() ); local_tstates += ( 4 ); break; }
    case 137:    /* ADC A,C */
    { adc_a( C() ); local_tstates += ( 4 ); break; }
    case 138:    /* ADC A,D */
    { adc_a( D() ); local_tstates += ( 4 ); break; }
    case 139:    /* ADC A,E */
    { adc_a( E() ); local_tstates += ( 4 ); break; }
    case 140:    /* ADC A,H */
    { adc_a( H() ); local_tstates += ( 4 ); break; }
    case 141:    /* ADC A,L */
    { adc_a( L() ); local_tstates += ( 4 ); break; }
    case 142:    /* ADC A,(HL) */
    { adc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 143:    /* ADC A,A */
    { adc_a( A() ); local_tstates += ( 4 ); break; }

    /* SUB * */
    case 144:    /* SUB B */
    { sub_a( B() ); local_tstates += ( 4 ); break; }
    case 145:    /* SUB C */
    { sub_a( C() ); local_tstates += ( 4 ); break; }
    case 146:    /* SUB D */
    { sub_a( D() ); local_tstates += ( 4 ); break; }
    case 147:    /* SUB E */
    { sub_a( E() ); local_tstates += ( 4 ); break; }
    case 148:    /* SUB H */
    { sub_a( H() ); local_tstates += ( 4 ); break; }
    case 149:    /* SUB L */
    { sub_a( L() ); local_tstates += ( 4 ); break; }
    case 150:    /* SUB (HL) */
    { sub_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 151:    /* SUB A() */
    { sub_a( A() ); local_tstates += ( 4 ); break; }

    /* SBC A,* */
    case 152:    /* SBC A,B */
    { sbc_a( B() ); local_tstates += ( 4 ); break; }
    case 153:    /* SBC A,C */
    { sbc_a( C() ); local_tstates += ( 4 ); break; }
    case 154:    /* SBC A,D */
    { sbc_a( D() ); local_tstates += ( 4 ); break; }
    case 155:    /* SBC A,E */
    { sbc_a( E() ); local_tstates += ( 4 ); break; }
    case 156:    /* SBC A,H */
    { sbc_a( H() ); local_tstates += ( 4 ); break; }
    case 157:    /* SBC A,L */
    { sbc_a( L() ); local_tstates += ( 4 ); break; }
    case 158:    /* SBC A,(HL) */
    { sbc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 159:    /* SBC A,A */
    { sbc_a( A() ); local_tstates += ( 4 ); break; }

    /* AND * */
    case 160:    /* AND B */
    { and_a( B() ); local_tstates += ( 4 ); break; }
    case 161:    /* AND C */
    { and_a( C() ); local_tstates += ( 4 ); break; }
    case 162:    /* AND D */
    { and_a( D() ); local_tstates += ( 4 ); break; }
    case 163:    /* AND E */
    { and_a( E() ); local_tstates += ( 4 ); break; }
    case 164:    /* AND H */
    { and_a( H() ); local_tstates += ( 4 ); break; }
    case 165:    /* AND L */
    { and_a( L() ); local_tstates += ( 4 ); break; }
    case 166:    /* AND (HL) */
    { and_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 167:    /* AND A() */
    { and_a( A() ); local_tstates += ( 4 ); break; }

    /* XOR * */
    case 168:    /* XOR B */
    { xor_a( B() ); local_tstates += ( 4 ); break; }
    case 169:    /* XOR C */
    { xor_a( C() ); local_tstates += ( 4 ); break; }
    case 170:    /* XOR D */
    { xor_a( D() ); local_tstates += ( 4 ); break; }
    case 171:    /* XOR E */
    { xor_a( E() ); local_tstates += ( 4 ); break; }
    case 172:    /* XOR H */
    { xor_a( H() ); local_tstates += ( 4 ); break; }
    case 173:    /* XOR L */
    { xor_a( L() ); local_tstates += ( 4 ); break; }
    case 174:    /* XOR (HL) */
    { xor_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 175:    /* XOR A() */
    { xor_a( A() ); local_tstates += ( 4 ); break; }

    /* OR * */
    case 176:    /* OR B */
    { or_a( B() ); local_tstates += ( 4 ); break; }
    case 177:    /* OR C */
    { or_a( C() ); local_tstates += ( 4 ); break; }
    case 178:    /* OR D */
    { or_a( D() ); local_tstates += ( 4 ); break; }
    case 179:    /* OR E */
    { or_a( E() ); local_tstates += ( 4 ); break; }
    case 180:    /* OR H */
    { or_a( H() ); local_tstates += ( 4 ); break; }
    case 181:    /* OR L */
    { or_a( L() ); local_tstates += ( 4 ); break; }
    case 182:    /* OR (HL) */
    { or_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 183:    /* OR A() */
    { or_a( A() ); local_tstates += ( 4 ); break; }

    /* CP * */
    case 184:    /* CP B */
    { cp_a( B() ); local_tstates += ( 4 ); break; }
    case 185:    /* CP C */
    { cp_a( C() ); local_tstates += ( 4 ); break; }
    case 186:    /* CP D */
    { cp_a( D() ); local_tstates += ( 4 ); break; }
    case 187:    /* CP E */
    { cp_a( E() ); local_tstates += ( 4 ); break; }
    case 188:    /* CP H */
    { cp_a( H() ); local_tstates += ( 4 ); break; }
    case 189:    /* CP L */
    { cp_a( L() ); local_tstates += ( 4 ); break; }
    case 190:    /* CP (HL) */
    { cp_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 191:    /* CP A() */
    { cp_a( A() ); local_tstates += ( 4 ); break; }

    /* RET cc */
    case 192:    /* RET NZ */
    {
      if(!Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 200:    /* RET Z */
    {
      if(Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 208:    /* RET NC */
    {
      if(!Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 216:    /* RET C */
    {
      if(Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 224:    /* RET PO */
    {
      if(!PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 232:    /* RET PE */
    {
      if(PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 240:    /* RET P */
    {
      if(!Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 248:    /* RET M */
    {
      if(Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }

    /* POP,Various */
    case 193:    /* POP BC */
    { BC( popw() ); local_tstates += ( 10 ); break; }
    case 201: /* RET */
    { poppc(); local_tstates += ( 10 ); break; }
    case 209:    /* POP DE */
    { DE( popw() ); local_tstates += ( 10 ); break; }
    case 217:    /* EXX */
    {
      exx();
      local_tstates += ( 4 );
      break;
    }
    case 225:    /* POP HL */
    { HL( popw() ); local_tstates += ( 10 ); break; }
    case 233: /* JP (HL) */
    { PC( HL() ); local_tstates += ( 4 ); break; }
    case 241:    /* POP AF */
    { AF( popw() ); local_tstates += ( 10 ); break; }
    case 249:    /* LD SP,HL */
    { SP( HL() ); local_tstates += ( 6 ); break; }

    /* JP cc,nn */
    case 194:    /* JP NZ,nn */
    {
      if(!Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 202:    /* JP Z,nn */
    {
      if( Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 210:    /* JP NC,nn */
    {
      if(!Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 218:    /* JP C,nn */
    {
      if( Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 226:    /* JP PO,nn */
    {
      if(!PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 234:    /* JP PE,nn */
    {
      if( PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 242:    /* JP P,nn */
    {
      if(!Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 250:    /* JP M,nn */
    {
      if( Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }


    /* Various */
    case 195:    /* JP nn */
    { PC( peekw( PC() ) ); local_tstates += ( 10 ); break; }
    case 203:    /* prefix CB */
    { local_tstates += execute_cb(); break; }
    case 211:    /* OUT (n),A */
    {
      outb( nxtpcb(), A(), local_tstates );
      local_tstates += ( 11 );
      break;
    }
    case 219:    /* IN A,(n) */
    {
      A( inb((A() << 8) | nxtpcb()) );
      local_tstates += ( 11 );
      break;
    }
    case 227:    /* EX (SP),HL */
    {
      int t = HL();
      int sp = SP();
      HL( peekw( sp ) );
      pokew( sp, t );
      local_tstates += ( 19 );
      break;
    }
    case 235:    /* EX DE,HL */
    {
      int t = HL();
      HL( DE() );
      DE( t );
      local_tstates += ( 4 );
      break;
    }
    case 243:    /* DI */
    {
      IFF1( false );
      IFF2( false );
      local_tstates += ( 4 );
      break;
    }
    case 251:    /* EI */
    {
      IFF1( true );
      IFF2( true );
      local_tstates += ( 4 );
      break;
    }

    /* CALL cc,nn */
    case 196: /* CALL NZ,nn */
    {
      if( !Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 204: /* CALL Z,nn */
    {
      if( Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 212: /* CALL NC,nn */
    {
      if( !Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 220: /* CALL C,nn */
    {
      if( Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 228: /* CALL PO,nn */
    {
      if( !PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 236: /* CALL PE,nn */
    {
      if( PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 244: /* CALL P,nn */
    {
      if( !Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 252: /* CALL M,nn */
    {
      if( Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }

    /* PUSH,Various */
    case 197:    /* PUSH BC */
    { pushw( BC() ); local_tstates += ( 11 ); break; }
    case 205:    /* CALL nn */
    {
      int t = nxtpcw();
      pushpc();
      PC( t );
      local_tstates += ( 17 );
      break;
    }
    case 213:    /* PUSH DE */
    { pushw( DE() ); local_tstates += ( 11 ); break; }
    case 221:    /* prefix IX */
    {
      ID( IX() );
      local_tstates += execute_id();
      IX( ID() );
      break;
    }
    case 229:    /* PUSH HL */
    { pushw( HL() ); local_tstates += ( 11 ); break; }
    case 237:    /* prefix ED */
    { local_tstates += execute_ed( local_tstates ); break; }
    case 245:    /* PUSH AF */
    { pushw( AF() ); local_tstates += ( 11 ); break; }
    case 253:    /* prefix IY */
    {
      ID( IY() );
      local_tstates += execute_id();
      IY( ID() );
      break;
    }

    /* op A,N */
    case 198: /* ADD A,N */
    { add_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 206: /* ADC A,N */
    { adc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 214: /* SUB N */
    { sub_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 222: /* SBC A,N */
    { sbc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 230: /* AND N */
    { and_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 238: /* XOR N */
    { xor_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 246: /* OR N */
    { or_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 254: /* CP N */
    { cp_a(nxtpcb()); local_tstates += ( 7 ); break; }

    /* RST n */
    case 199:    /* RST 0 */
    { pushpc(); PC( 0 ); local_tstates += ( 11 ); break; }
    case 207:    /* RST 8 */
    { pushpc(); PC( 8 ); local_tstates += ( 11 ); break; }
    case 215:    /* RST 16 */
    { pushpc(); PC( 16 ); local_tstates += ( 11 ); break; }
    case 223:    /* RST 24 */
    { pushpc(); PC( 24 ); local_tstates += ( 11 ); break; }
    case 231:    /* RST 32 */
    { pushpc(); PC( 32 ); local_tstates += ( 11 ); break; }
    case 239:    /* RST 40 */
    { pushpc(); PC( 40 ); local_tstates += ( 11 ); break; }
    case 247:    /* RST 48 */
    { pushpc(); PC( 48 ); local_tstates += ( 11 ); break; }
    case 255:    /* RST 56 */
    { pushpc(); PC( 56 ); local_tstates += ( 11 ); break; }

    }

    } // end while
    
    global_tstates = local_tstates;
  }





    /** Reset all registers to power on state */
   void reset() {
    PC( 0 );
    SP( 0 );

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    exx();
    ex_af_af();

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    IX( 0 );
    IY( 0 );

    R( 0 );

    I( 0 );
    IFF1( false );
    IFF2( false );
    IM( IM0 );
  }

  private void readBytes(byte[] data, ref int position, byte[] dest, int offset, int count) {
    for(int i=0; i<count; i++)
      dest[offset+i]=data[position++];
  }

  void loadSna(byte[] data) {
    int position=0;
    byte[27] header;

    readBytes( data, position, header, 0,        27 );
    readBytes( data, position, mem,    16384, 49152 );

    I( header[0] );

    HL( header[1] | (header[2]<<8) );
    DE( header[3] | (header[4]<<8) );
    BC( header[5] | (header[6]<<8) );
    AF( header[7] | (header[8]<<8) );

    exx();
    ex_af_af();

    HL( header[9]  | (header[10]<<8) );
    DE( header[11] | (header[12]<<8) );
    BC( header[13] | (header[14]<<8) );

    IY( header[15] | (header[16]<<8) );
    IX( header[17] | (header[18]<<8) );

    if ( (header[19] & 0x04)!= 0 ) {
      IFF2( true );
    }
    else {
      IFF2( false );
    }

    R( header[20] );

    AF( header[21] | (header[22]<<8) );
    SP( header[23] | (header[24]<<8) );

    switch( header[25] ) {
    case 0:
      IM( IM0 );
      break;
    case 1:
      IM( IM1 );
      break;
    default:
      IM( IM2 );
      break;
    }

    outb( 254, header[26], 0 ); // border

    /* Emulate RETN to start */
    IFF1( IFF2() );
    REFRESH( 2 );
    poppc();
  }]]>
      </Source>
    </ZLibrary>
    <ZExpression>
      <Expression>
<![CDATA[trace("Loading rom...");
byte[] RomBytes;
getBinaryProp(RomFile.FileEmbedded,RomBytes);
for(int i=0; i<RomBytes.SizeDim1; i++)
  mem[i]=RomBytes[i];
trace("done");

trace("Loading game...");
byte[] GameBytes;
getBinaryProp(GameFile.FileEmbedded,GameBytes);
loadSna(GameBytes);
trace("done");


//fill ram
/*for(int i=0; i<mem.SizeDim1; i++) {
  mem[i]=0;//45;
}*/]]>
      </Expression>
    </ZExpression>
    <ZExternalLibrary Comment="OpenGL 4.0 graphics" ModuleName="opengl32" DefinitionsFile="opengl.txt">
      <BeforeInitExp>
<![CDATA[if(ANDROID) {
  if(App.GLBase==0)
    this.ModuleName="libGLESv1_CM.so";
  else
    this.ModuleName="libGLESv2.so";
}]]>
      </BeforeInitExp>
    </ZExternalLibrary>
  </OnLoaded>
  <OnUpdate>
    <ZExpression>
      <Expression>
<![CDATA[execute(App.DeltaTime);

App.Caption = intToStr(App.FpsCounter);]]>
      </Expression>
    </ZExpression>
    <Group Comment="input">
      <Children>
        <KeyPress Name="KeyTest1_5" Keys="12345">
          <OnPressed>
            <ZExpression>
              <Expression>
<![CDATA[//Keys_1_5 &=
//_1_5=1;

Keys_1_5 = 0xff;
Keys_1_5 &=  (~(1 << KeyTest1_5.KeyIndex))&0xff;

//trace(inttostr(Keys_1_5));]]>
              </Expression>
            </ZExpression>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTest6_0" Keys="67890">
          <OnPressed>
            <ZExpression>
              <Expression>
<![CDATA[Keys_6_0 = 0xff;
Keys_6_0 &=  (~(1 << (4-KeyTest6_0.KeyIndex)))&0xff;]]>
              </Expression>
            </ZExpression>
          </OnPressed>
        </KeyPress>
        <ZExpression>
          <Expression>
<![CDATA[JoyState=0;
const float threshold = 0.25;

float axis=joyGetAxis(0,0);
if(axis<-threshold)
  JoyState |= 2;
if(axis>threshold)
  JoyState |= 1;

axis=joyGetAxis(0,1);
if(axis<-threshold)
  JoyState |= 8;
if(axis>threshold)
  JoyState |= 4;

if(joyGetButton(0,0))
  JoyState |= 16;]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
  </OnUpdate>
  <OnRender>
    <Group Comment="gl texture render">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[byte[6144] video;

for(int addr=16384; addr<(16384+192*32); ) {
	int y = ((addr&0x00e0)>>2) +
			 ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}


if(VideoBitmap.Handle) {
  glBindTexture(GL_TEXTURE_2D, VideoBitmap.Handle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, VideoBitmap.Width, VideoBitmap.Height, GL_RGBA, GL_UNSIGNED_BYTE, video[0]);
}
//glBitmap(256,192,0,0,0,0,video[0]);]]>
          </Expression>
        </ZExpression>
        <Material Name="SpeccyMaterial1" Shader="SpeccyShader1">
          <Textures>
            <MaterialTexture Texture="VideoBitmap" TexCoords="1"/>
          </Textures>
        </Material>
        <Shader Name="SpeccyShader1" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D tex1;

void main()
{
  vec4 color;

  int specX=int(gl_TexCoord[0].s * 256.0);
  //float specY=gl_TexCoord[0].t * 192.0;

  float u=(specX >> 5) / 8.0;

  vec2 uv = vec2(u ,gl_TexCoord[0].t);
  int byte=int( texture2D(tex1, uv)[ (specX>>3)&3 ] *255.0 );

  int lit=0;
  if(byte & (1 <<( 7-(specX & 7))))
    lit=1;
  if(lit==1)
    color=vec4(1.0);
  else
    color=vec4(0.0);

  gl_FragColor = color;
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable Name="MemSampler1" VariableName="mem"/>
          </UniformVariables>
        </Shader>
        <Bitmap Name="VideoBitmap" Width="8" Height="192" Filter="1"/>
        <UseMaterial Material="SpeccyMaterial1"/>
        <RenderTransformGroup Scale="8 8 1">
          <Children>
            <RenderSprite/>
          </Children>
        </RenderTransformGroup>
      </Children>
    </Group>
  </OnRender>
  <OnClose>
    <ZExpression Expression="MemSampler.ValueArrayRef=null;"/>
  </OnClose>
  <Content>
    <File Name="RomFile" Comment="Imported from spectrum.rom">
      <FileEmbedded>
<![CDATA[78DAED7BFB4314D7F5F8CCBE17D817CF010CCCEEA08EBBA20BE2324558E5251A9425A092E8A8C194A8890145121EEA86A4ADA9E923266DD3E6FBE9A76A9A863C45F3F063FA30ACEB52C6714454D03525B09A5D92EE67251851A361F89E3B60DAEF7FF0FDA1139C997BEFB9E79C7BCEB9E77167F34DA76972D2CB9BACEB59CB469628F6DE48984417B4DDC21EEC9CD08411B7A1ED5DB740EAF7596BD9A0F70F89E3416B0B4B595AD8DD1F93F2899C25BE7EE153599F2730768F0BD44F3C8D457615B05E5FE2E4D405D0471024FE55602C520AB8290BE0E744F33951D7231A2F8BC4E2CB9498C8E0542E0C709F56559C5A5E515EFAC81B95DCD2B395AEE51517AB8BAB4A4B2BDE285CB5EA7CE1C5558527D714AE78A3D855E25B53786645E9D9EAE5678B5D1756159E2DAC3E5B587CA170D5D915674B1F3E87E63D74BEBAEC6C61D185CAD2527EF9D9D5D5E7AB5755BD51BCACEA8D0AD7C5A2E5675DE70B2B4EE5FFCDF9B7FC132B9657F8562D2B3DBBAAB77A55E9B992D2A5E4D2B3C5851797BAAA56165E5CE95AE32BAD2AACF6B92A4B2BC83F16AF705597927F5C595A55E65B535AB57CA9BFA8B4F45CF1F2AAE215BEE5157C656165E9F9A52B0AAB7B8AAA96972DBBB8BC028060EE9AD2F3AED51757545601672B562CAFBE58BDCA75AEAAB4F05449E12A4F5529B4AA7C15A5978A5C5525A5E78B5D15AB9657ACF6952C17AA4A85A5AEF3652E72552FDCAA579F5C5E5109785C85A7109215A5172B0B5757C3CC872F56BACA7D12FACA15AE8B55ABCF5617AEF155155694B8562E5FEB5BDE5DBCE2424955E1A5E215A585E7AB4A57ADAE02B955FA8B963DE258B8AA6C4DC583AB7373AA9616AF2C5FCE2C282D7958BFC2F583EC9AEAB5A4AED29EF550E1B553C35F7CF4D7BFFDA5F3C8D1AE8E374FBCFFC19F837F3A19F8F013CF71F73FAEB0FFB36BCFE54F0FBFF3EEE0E743CF7E3CB0BB7FFD67C7FCEB2EC5A8550AA5262A5A6BB86A5D2CF49CE137BC97692B98377791E5EFF95EA76F3EF76877DEB9B36F9DBE70B1EFFCDBBDF3E68335E2A21869991F4AA7F59BF7C4770D68F87CFBDDEA8DE4CD4C1E63426DF93D22DD2326F7EC5A5B23129CF04B599719637937A9A616DA489963728F59C1FE8DBC2EA4C9CFC1C0097A5E183A4ED0B3014411E6DD3D1B9B298792CAD3B2CDD444857A620D1E1416C803CDD91A7682C7AF73687061575E140CBB897F162562BBC4D9E7448294F32D5D66A52CD99DCBED12F398F9BABB2E392DEF7671E630AEA0E530948825BB39F31C19BF84BEC9AFA5A32678FB862E455737C975FF8913ED977577FF5B4E269B57C9F82DF40591B1AB0748454FB7861B70C043E4CC7699F803FACFA29D3E165277B72B7AAE1B38450FBF05FAC937068CA285568964977323E75CC27DB3872FE00BE687E42E153668EE930F6AF396B121C66030DCD26018A688D19113FAC5CA9303F2EBC60B62898BDF4C6ADB3EA4B5AD2B5307BF5A1933F8D53D6E346B76973CE77FB7FD2E7D5C71C8C0985F61DD1DE406AA825ADA9274E01372157582AC6CE9CEBF315371759B427557311063BFD71DE333D72B04558EF0D182510533B6B779B44B96C508BF4E13A3ED96D161C5704E7BF1EA03EDB83267E10E3923BC96E6837F81CA47DA3EEC49F57E2CEF8DDA273B17BB775FD46F1F7D7A5F6C7F52FABED4FD85B27D19E7AA4FEF9BF7DF8EA3FB98C9E5CE7DC5934FECDCE7EAC056ED63612DFBB6C6DFCAD8F7CC985129DCCBC85BC4BE70F7C51981734161CCB6E949DD1D2D0F825BAC0C9ADBD3F967410BBF8BD1C40DDABE71CACA8CE205F1BA41F5462639AE9C79E3B242351FF53875AA5CF4C4F58B340D5EB512841233588FED7E7FB313CFF5CE546E236EB6F22D46D1AE5015213895931C5576E6F30927E395A983942ACBF9EC6762FAB9B6FC93A242B5C82872E3F7050FB8D1D03D46D61B33C6C56B12BE71421FE20D7A43E42D99EBD32E614469BF6B4E5018451BF8C26F856B4A7B58F57BF4F8C2D97DDC3E9C418EA93804D4DF225EB4DF84B773ADD7E5AE5998EA0891AE21D576C3E0D31861E04DEF77B5A6BBE208F5A01B7BBF6B904AD5A83E9887039E734EFE389FA03A72FEB41296D4F621797AB788238CE79C8905E44487A2678AFFB74324FD4DEB7C57487D4B7341CCE5C6F29AD881E1EC2656F8F90CC13E93CEC74D187475D032BDE576FF604015ED2463E38CDF0D3AF04990BCF9D664B4566E37201052D6AB6F394A47E151D860304085234786C42FC8E53024CA4FBF386344F880E6BFB5479B3184B0804EE8C54FBE28D12028F7607334BAC550833BF44E9CDF41E3F983CD5878449C435E1911AEA786BD6BD5E23B64FABF905D4F1D744463838E985433B664F069DD60939E58297692AE7F812C23C918C4183484D00CC2203C3F63489C4BFF7B9F62043A011718E7E08EE8C1ED31D28B6E70BBFED1AD830E4C4E9488A769AD444CDF4E24A1992711EA7F4D42B00089591F6123EBAAD9DC48D5E0D3D1834D31D67216BD1A069B8C6189E0766D106439A81D0C9A4C5867AEB0463918B0DF708A029E38E1A892EBDB41858327464999FE96A8B0FB4D5D5A9F1015E3190CF699BF9E4C5645B9F349796BBB2B2EE50445E231978CB7F856F243A7EE5200E68972695505A7351A5176FA982638587F77F0F17B831BA207D7C4ECFE98D645AA9859B45A82241F0880C9A906EB75838FEB838301242F592E8977382781A7CBBD2953B38208282E2E2E4CC44C210BC3D218AD49892597AC1494E9886C07ED04E471B6A5B60A9B5C2E1F84B441F83279D0BA910569D8062BA20797C6F8D0807B625C589D488D35F7513BA9460AA8E63A27BD324D58828369D3B04230D913F40128C2410D561806971AB596721638DD1DEA22A380694B113BE188C2FAEEA3B84FE5B6A33DDC179CC22CC83401A40C37CC494E890381C9524EA4DAEC9A6058389E1C20FE5798AB25AEBA5D627B4F10F4E416DBE9999FD01A1F0C7AC2C4D7A161F12019DBD71FA440D8A42AC97E3B40C803C4B073B22F9C9F8BE69E228D1AE01A6183058781598DA61F1AD067AD66AFF9348CDA86164CC8D1DDD317A9AE06EBD8C8FAFA6157043CFD30A98F0B3A2740F79DA6435AD0F3042FBB2E5C4C98320EE1A402765AF633C689295D38270703DE938AF6EAA6DAC626B2A9767BDD5CB2694B5D3DB9BDB16EE74EB2B6BE957CB2AEF5B0AEB2B1617363ED53790775154F3FB5A9AE91AC6D6CAC6D8566F196DAC6DAC79AFEADA7A8B5A96E67DE41411E2D92E7FD51A28AD92A12F63A7374D446885E1B92835E7974458D71CEAAEAAADC4AD7C60DEBD9756B5755C7382D9F9026888E15A456A1973989E3A45CA9377BFDBABC97D9F109470DEE2485BAE8B1EC97590E419D14F47AB3B03A46091040AAB5A0206424D63A1713DB4C2F44651B5822DAF4541421470D3D6B7D8805E3E04C37B5427B9455CFD6EC1113AF982CE49C92079DE92F3331DD32974439D199B8FFCA81B4FC3205086DE9C9D5311327B2AEEC8D0112BB81C67305A1F49E1A00EC065616C52490773821235A9A9882E0494DA4F8A7ACE5C72C17297E918D143FCF5AF602B33B4A2DED533C93F191F29FB2D61FB308BA2752FE226B450015A5560010DB990271BF7D5699C0440331D32B2C510601537046F3C48190C185EE5F1FD52B9A291D798F1BF8935DDB9DE08B94EF82950AC6189029341C6CD8BC88E5F78A2429E3BB67610D73E6CCD17AC2AD054E33A9574A6BA455FD82A0EF6BFDA4FFCCEA983E5F10A4AB9A4C6770457AFA019753D321C12821AD389B1BD6A41C3CFC76AC86898BA70AC81BE19968ECCC67D1018F8EE2344EF2471B3544683784A590FCD6C39B23EB5E62DDEFBEFEEE045FF30CAD09FD9DAF2165D719683D0EAD3B7C03B4D4CD5C7016768D50987E838D0B85318CD64902CEA56716C5A4849E0591A6C4BD601FEF1397D172F1F9CB6DA2FCB293ECF75FF2F771E3E17CDE4DD1F70AC83BE13191BC9C32502849B4CBE4D7F5B748CA92E940594C6A17341EA7132736643E40AF7562B00D22BB162381BFC9F52A26165691A54E627FF6CF59EB4B2C5AFBF8F44EB91333BD5390FC3EE70FFB61C7F845922E15AFD285B748B19E5E24F953647F01CB4BAC20EA26966629F4669FF05FFAEF65601A5E9B52A122C3B13BE228E35D0FD7BEF3B1C6866DDB3EED8D11654CFBC4DEAC81E47391125F19226E7D990D0A2B752DE3E627D9A52DF9CDE67DEC09469EA322044C3F56407E199878BA06514226038CED15FC3A78747BB84EEB2F2403A2159B27EAF500617E9925656EC3E1D0EAC3CD9CD0A933E7B3FC61BE1B90038B4289DEDCB536EF17AC9250EB495B33188FF1F684234B262D1C36066C8A0EE4394D6F191733B77073126185386AD90334EC7B855FEBA465032E60AC443F050FE0105770DC4C98B1759261C74A3A00BB812512BE329089C7697E19ED77EF3FA25449D0D66B7CC19690BA858C099B87EF248771122B881C81F7C9E47059480D1274B5A8B0C811955A1BBA437E16C8F0E84841F8A95E02806EDCF72F24D3C0BA55EB1D585CE4880957271784EE94914169D63F60D6A627E3F2A6A52487E4A9393A72C4A33773485105B72A37876BB7CC4157C94A0EACA106A96FB8A12D44DC5AB299FB467504C23E848A9B7A4F206377484D46EDE9261B161F08DDF9F166E308A1FB0616ADD248E3C66F9D8A0BF7EE21293CBDB4B3AC99327E0752FBA5E4B65A44F98190ECC2BD1A61553A1325C10943FADE98CFEEBD70C71ED6431AACD2F0B17C1C9FF2D9BD74FBBDB60BF78C5FEBC8AF386B011B343F6B0C467616B06084E389D8C48649730F267C2C1F33338620F8D22C51CD648A46260F97613550D0C6C827F85CF7E93423C06F847FFDD675B076F55E88101E6A3BB58388422DE814AA1263E322D5EB580E54637ECD80BC317473DAC79FA8FC78BBBBF7A275394CCCAD3FF95BA3509F2CFC26B1EDC3D3BF350651C26E8EC2B45274167E6B042BB81684588827066C130B0DC26A6222C700F19682CBB28E0D0809891C42436ACCCB59C1904C3C35E1C08CC40342969150BAA11847501CB4701CF37E990C1CC35F2010B0140075CCDDF52D972BFCC614A94AA63C977D252B373D49A584BE168DA4964A19483A8B9138D51129D286999044A50B98066EC3C0AEF9415698017C2739312FE43E2014FA2DEF7306D0C9E3F421E06112095334EF4F01617AED86A0B0DF6483C400B89970A8B100A0936D38F5800939C1FA9E3CA9583B3C0E9DF5A7EA75E076EC55A2D19E29AAEC516521DCD592DE1D4B5849ADF909D6A939DC4CE845FDE5019DB9903DD10C252206D33EFF9403D376398DFCC3249E3FB1E38249672254793A16F69AD505E2828D94CBA17DCACBFE00FF0E5B5F04BF80F4BFD924E9DFFA3C1B44A2080B7B88B0102060FC5A18E0F37EC6BEC2CC2255BB265EADB4A78193146E6AFB88AFFE6D7568B191752FB284AC4F922B24067E5DC0F23C2C7416C6596B595B4764DD2392B27B22EB6AD9CBD6C758CE2DEA711576E6CB643725EAC831EE1B27E0F880F547CA3F821C8361ADBB587F99530D55C8E24819265D9B9E74C86C7F25EF76206DD9550B69F942FA1B9B3F520C33AA19D602331474B2E523D6D4E9C4DFC2C291E3610A3A6DF8122C520CE31FB0662CDFE260AD1FB00EA7ED5B9B0D788DAC9930E7B1F7CCC7588B0BE625E00930EF48D866A961294B350B499BA39DB23CC23A74147AA9652D8FB1963AD6C964FF82CD7E89CD5EC69A29A545CB4E2CEC9E5878DADC9D6032B2B81E7C0BA8F32CEC41E4FD8427759D262661DAE9136AA9EF3749C29144296608730D42522A32463256B29E2560DE4287098995188477CB7A56B897DC72F4E4FA8421514743D4B12F3DD5A913EA75CEE489575D1060809888C021A5C48517539F41B6045015A7047D5E1E9B3F0E4E76A22977A26996259A35E398259105E2A08FC38003F13456264631B26EB5309AE0242FB5985E8E03663B4D0EC473A4BC941552539C7997262A742A0C5E615722AC74AAA8A51562023A2DD3E172CCB49D3597B0BC9BC6B591E3C0C92470F107EF7BB1ED2EBEA2F4E15564F3D6A62D0D4F37914B5DE7D7D4366EADDDB4AD8EAC6F68221F6F78BAFE8BEAA73741FCDABABD896C6E6CA81F71015CC3E3E453754F35347E3BDD80F1BABAEBD32961534303B969EB8874E253F13DEA3257F5EA93A5F53F44E08F6FDD16AC5EE5AA247736D536D53D55577F7379FD33B5DBB6FE1092C7CD4F4FB59BEA3603AE8629FC8DB5F59B83150DF53BEBE08FDC5A4F1615562FF716559516969399243ABB221BEBB6D7D5367D33CD103AE2BA8F13A8C16A6A9F0204646343C353B0AA4672DBD6FA2916009974BEB5D455F53DAFE86CEBFEECE5F35DE40FEB9ED9FA58F07ECF630DDB1A9EBE31457C6B7D5303E4C828298E5415AE4408EB1BC8CD0D0D5F544F2FAD89DCD6B0F3FBF5ED6C6AACAB8D2CFD97584A4ABB2B21737EAA0EA5CE758D8D0D375641F20D736A7FB8B57EF354CFDC83CF92593F60B2C9EAADF58F6DABDDDA4856D5EDACAB6D7C6C0BB9A2E90BA711C7306F5C5CA478396B5D0F99DFEA84206C6CA8A5828F6E058748AAA66A084F6BC1119A46C592DC864A977E080B01D8471E5F1CF203B6C87170A061CF76DB0EDB4E5BE398F7F5D89BDAB78CE537B5A712AA9F339C4AA8426F95EDBDB138A6C2A2311C434F23F26FF524CA933F17420997E9BBBD6A7F10020345119A34FB8FA4F70DD49AB0303731E0E75EE84E6C9885DA6D1F422D9F940ADE2FD9F2104A31DE4441A3C29C9928FC23F15C22B621F9AB7255756C652AC2DF3DBD674204A2B3175ABFF42267899FE520720451A928FC30D15AC7825BE1C683E672D6A9071AD79033BA66D7F687B5E146DB4EAA0FB2D72FC37D63D05DB2529E1CE6302C6C7A29119570B7D7501B38707D5249457922C5B5AC274C7156E45C202A4CFB17ABE462AC929709424E6ED9C20638E43EBDC164CADDD1F30945DE013F9E9624E049A013D3D53F869319357E31410B8133BC83DACE0561C15AB4D0B0393109565AA1C2B45F952BABE595788043475B4606C4D22D579B8DAC0BC6609E8D1BC519C0D972944E0C4F4F7787C5725A2356C316AF247B85F549A8AA41C7542D47D111892F2534E432B72102F63144C28384A9A98CC2D2704295A6226469C66800EDAF0970C4FEC84EC88B1D3223648C92ACA55C714ACEF66E3089C8BA6D2C922463E9076B3275C9C291AA6BF0E6918A592DA30F83F06C91EA6D2C11B16C63ADDB5014A6F1B0B08090D26DA79C903965400113EC334FE18943C27692891F121701F77349153AE92034E8A4442E7C3E7DE6D1125ABC79AB450AE76938A41597A464FE56DE932CF854F2FABB3DC17EF3369451F441CD1C2907C0F6E44427AD3461181F37B133D32D2EF19CF309740AC80ACC646F5B07ADBC840AB6FE302CEA5594DBBF8A421E2DE307A0B286D5914AE762C143406C0DBB856304C43D5A1516729389E13E4ED47751D2E5E6FC2863E7FFCA4F4CA5DB6BFA1D1884DCC0449394A2FB3948A20059575E21CBAB69457731918868FDC159CEAFA1A3F9CFF3D1312D2D7316F703AD3E0E6C3418A6A632AC8094C2809972BB3AEE10BA4E6D3EF35DA4A8801EF38E2608A99976BB6866E6C2125E15793A43CC23F552620581C2BE868E879CC342468DE73DC15E57643FC18E01DCC02530B66A76D57A0FC8E61C525598B8E93EDE45B96D9F70283F5BCFEAB1849E91BF908A0E8E426B861EC082EBC43C500C4F2AF8421A421A792D21970B82409924BE818E7FE1EEDF9317E34ACC2ED3C726516EFB3D4245A1B490D2F649DB0A76953098EC6B995FD63ADF25875D190E24F7478E04D056B2018511B46DEA586151A6F07A26A3307F7D597BE5C5195E5F627FB0936F21C947B7A64D129A7EB0A860388DC489EF046B32FEFB49B8EB6FC16D0F44C1401F7794FFEBA7A73A3FFAD5CBAFFCE67753D7B3CFCDDB56BF7DD9AFD72C2EB425A5E73697181EB115673E94F754916E395B92B01E2F90A9B0CD692A5EF9F50C282FD2B0EB33302A5D51A03AA352CA1F5060EF3EA014D295FB48A56CAEF28354EC7F4CF24369CA6F9334587B9ADC95866D4C93BF97863DA9D362FFB0A8B0BC7465E401E5EC3479519A56F93C85BDA75772E9CAF1A468B834D81DB95649526AE9D2606D692AECD716E5A3E9AAB951982349850513A3B05F2545CD95EEF00FFE405D27208BE8CC2E630BB2F358021F113E4D84C07DF7C519432A0C4CB10D7412363F931A748DB40E9C0581B9CCCB52B4155A426E6D62DD94A589C5AB527D2EC84C63CCF80CE437B4C1212537F4093A49E450E121EB8D9FE0A3DCE40E6B11CBEFA6E3CDE2A4A51439341BF25FA979252CB1000C119E747207595C064EB18536F44E7A60CFF65857B3CEAE37BB3A45FC2C069A895497B214F2E9C99465351B06ADD6A46128A9489868D49DA653E3859F25D39ADE4498DAE5F1A0B4E8CF621EF47B5F9C6178A05CBB397AD72F777CF45C2FECF64F3D67AEA786610DC83FFA38E1037AC2918BD93560DB6749A2173FF3EA1C90CD33A4AE13B98E319B79077BAC391C296E642D2B59CE23AC41FE82CB5BC48E0BF732C626D6E0EF849690197CDBC9492B4236DE7AEB403E193F46BC8D9C0C381BED08C0218C5DBDD1D36F3DC44D78B891BF3BB552279D4DC709DF99012F6C75CB2FD02E77AB0F87DE4125B57D261D2795E02B75E6FDACFBD69DE609BEE6D89070D54C1CF02A55B05005ECCCDF23918D1E64B85E0D921E1D352A63C2C25739573E4CF5CE491505C48574B84BA8E0367A8819ED92E1C3E0E327AD10506C6E5E84E45BAB66547A1D8A46C151998C0984F5519123D652368C6AEE35BA78AA51B8F2C0B989A50CF4598AD8BC3236525203D13FED1B5FA47C352BEC7D2052BC9AF530A6915BE4715A3E427C39E2C45FC92E61B95E931BAC89A040C3B95D4BA98A4871118B767010CABA4022E603E579CE11C3A0828A93F3665857A2AC319D02CE4687AF1ABA640CD0BD6CDDC29A0C5832D800F578D8BB33AD171B0D0C5F7560325C9E8B29980E8EC9E5468474E9E87DCE103AB2AC61DDE25C5A9BF605706697F5EA84660CB43704A93CF85F548B082D183A39E79042611A89F423CE3D753D758418777E5116F9C484C9BC3F4B86E0202535A808E050A4384A2A22E52D6CA4F81996B3D6B3136B1C448C049488ED16BFB6CF4587B98D519CF093B4482BBACB38A13F9349A065919271801B434D883CE08CF09EDE2861731A046EA1340DBAEE23FF80F545D6954BE7CD502342C1008986291B4BEE8B54D935D68F90C387152584A186E9F3A0E2C5874AB6F0577D138FEB32AE2D4039BA4FAAE2FA11F6780CA66B99A8B0B9124B66E491C6CBF3E4DED518A2AA4C2F59C979027D6DA2938E5E742D8CE6F840BAFDC15E1570F30C846C3AA6E5503E89CB51614A5F476911277D64B9EC14E12E59A8D279D6FB833418BA25FC62AE3D7144CC2095D03A3622D264FE88388726A1FFFC8B33C26844161E0983B549598F430F3B042C65589C43C68D8805A47EE4FB9D75180F2D419F52203ADB67067ABE9A8AE953F11C768330948EF436249492B44EA820E97BC277E9E8F98D38A747F0A63B7597B821F13D5227B4CE80A6A0A69C8984517C9F8C95B602F4BC96E64CBAD47AA9E51227DC309F830CE11CD08501B445CF8CD94E5ECB6C391ADD93127789B80D28D177FC3C0EA510F1C073145A76B45375895089B3BB84F1F411E083C43D9F722295DB852874201228BB3AAF4F84AAAE431294C689A30A0FAA2C870C173C24AC009DB14192719C91EBCD65E810D799BC5F2AE1A463376FFDD4DA4090FA1158F2903807F957EF0766F1346942F60E9B46441C4337A14362EE344FF59E0082A73F30835B0717C61FE3AF43DECABBC9681030782C995E7EACF9B643D76A30D8954E4BACAD199D44F0B96E722E6CE9A993803C73502A4015D27940EDFD22140A54297A7C62068B857787051306CC2092074C91F2E759E01A113CCCBBF913E40CE9042000DB11D5A430657AEB8103279220AB45F57F2E0AE2C207567046805052E2690F890E0A006A48BC4AC7E4ED608547668057EF011F0A9EAED72865FB901D89E5B0E96F982FA37D7C0B7473031CBEE8BF2C0E2DBE3C3E3236C08D8326C6902AC64117356397DA2E7103A6B318FDC0800CEE6B44BC4D85930AB55AA570B589327B622BF85E826953A9192584521503BD5009F7C6995F62450D13EDA6D547E6873268BCC5D52A6CB338D57F3E000FB53A5459E6D4FCF9C0E183879BA916EE409B41D54ECA0DAA25305D030E5A66FF5B2B60005010B781B88CEC42637FFB820834A64EA7B397B19CB373FF956F33CA3AD273D33BD2DF0ADD796B732B8CBF15FAFB5B6A75436B48CD810D0BEF58CA146EB57122847BE94CD411B4405D1229DEC34A434ED1609C28734F54D4F085247E907F8894BD35BFD9FB59B4104F95F9E0F688E72117F23F40498FF7E827C1A2E7FEEBDBDFA8B580718BCFD995103F8843A37F641C3F1AF581FFDD93E11BCD0A2860ACDDAE41C1C1E3FD8765F424DE2593E3C3862E3C6B18FE0E7A64CC44CE26585C43106E81CD963DACC74B6620DDA0B0E36DCEB84FC6F7BA223DCB6EC75432067ABB641E5996358007AC8661A575189FE2418DE8C0A8445C16C0951E190E3C9C94EE5783C3F2D71559E93E19D9253B29F30415C357158600EE910DC398427ED20AC8644C8AF89CE74A33CCC7993C90109D39DA658057B7F4EA330C07198F92CE27E2470359D71457BF50C83DB22F1457AF290C27658C0F6264C090757FA21C85227CF8FE643923FC4F86C7D80D4C7E8F5B8EFF3FA3A097D12C3A271BC395415C696550105085BEEB56D865CEEFC611187467A59F926581343C20CB2C4596E1903CD50BE245BA6E3D6E576DEDEFDC48A88FF66C29EC4FC41E6D49FF0923FF2BA3FEB5CBEFF1110A57BFDF63DDC3B6FCB8AC35FF278C8ED615B8C01CFCAD467F1F477FD31B05899CCF657E7526D464ADE77F3C4B855568BF129A30B9A83B0DBBC4427E030DD1C2212FAD022F39E55B506682A85B1DAC09C3935BA503EAB736B68688EB4B6A548FFAFA83298769453E9952E052A9E3A994C36F9306E36D8FC7E36CDF0F1EE6762C111530692054798C1796796157C342D0A139200123965F7F78B31B2CD7328376CDBB618B7D6BCD9F6A3A7EFCE64BA742EF7CFAEEDFDF3E8B8D78273386A8208A4D8699642ADCC0B183E734DD0EF4BBA9D83860FB8E9B122DF48DE83E54E71CE3DDA73EB07A6367A3346BDA39C6CEF6FE6D369A4447CA9F61055BE6E821434E6EA222A7BD10C3DAB36587E4590C445F14BFDD1DB47CC0D84C6811B8020C3E67C4EB9D85AF358E88D469DDEC690A74BAF04B991E23E38434B95D9FB05158201F476B1D8B45879682445FB0CC3CB570E688F7B399E8AD7DE608B10CBDF0961162B1F0D3B9F63562A13D1F651994F05F7387A603A0434F852136EB951D91222851D049236429847E083C9B9EBC4B091F2D001F88022B110FC9E5957933203D05072E76310A34482CC03FD38A99F46C1C42DB619A1CE884441DFF5A21C6D3F1106F55C6EE7FB8C421BB8C3F2A5E6764FC273E49BCA0EF1829C74D12AAAC23C4D72ACC65FECD6C54B9AB2ACC9159DAA57D6DC799BC8ED304E60301EC1223A48A7F8694A5BDD68FA4A4DD155A5C36BA8821B4BBEEC7684913B7F85DA48C3FE6213CFDAD12F684D0E26E8D4B344259374668984B6212D4BEDF4A2CD87A33BDD653F37D1BBA0BCE3ACFE40B7FE77A4E73BCEFEFDD3D984AA38992C995D2A542F25A3832953C40EE304EE2C85863514A61047D0F4D650FE3537A97943506346E2173080D958D0C64B860C6082A4A6DE0F57D90087A206F2282C2BB7468E838A981E740C627744CC006A99E948612973ACEBC4BF7F545AAD7B3301A044A454819894B68B50D3AA8448C0AF67F9FA090B600522054A7FF52E0BB344CD2051173BA9100348913D09843CB7A93FB50E5628D66AF59A2D9FE1164B201E808400B592DD0313377D1C7C55B43536B0E86D25D234191A6697E4CCCA04DFC57C8940CE896C81F1D216E8DA0342B2F86EDA091AC4E3E34A710894CD31A1AE6275D442EFA1940E8593AF313D292F4C28DC573183BFAFE9F122792F4DD5BE409FAE6ADF613A42A05E14B084805BB8738CBDFE90313A1B5FC9784AEAFAF2F38848641CC7702BC91DFCE01FB6E71CEE951DA7DEBD132249A69C1F06FB57C42C74A871692080002ADDDCF6F2563A8C83A28C0BB168441467D7D9DF95C6719DF4A96433AA2CF974AF9306CA221EF722B4C5ECAEFA0A394F4976164A7B5E13091111C0A400821F956BA8ADF41AA2057CC1FE140A0DBC43364F6102AF1890D660C0B8E045AC52E528B64FD9078860EFA82C275EBB5B070C6CA24470B37AD5AF0491F02DDC7838026AEA87C4A29B291804989A1610E81C38B474B15958785A35604A006357E86F60988E40E9236375517221BACECEF1CF799700CF83B43278D098275BCF291A0D4D24A36B9E949220ED802D0186974E8D1ADC07D68EC5AB20D9D14829763D454C75DD25AB2B20FE146C94D277AF1096F2FF08061354BBF2CD9416DA740725C677F504A68D0368C45A5445FCBD15C5A190882FB68FB1C0BF471615424230E7B84B7ED5712D23928A65059456F00139583B640F1F668D1C898C444BB8E2222A05B0676D6E92E5BAB546DA0AC3CDC0FB352075465B469CA246F9171B146B0955867178C1CBE4506847FDAA04864202A63409B5882363CAD32A9B06462044022E58D88EC52D2DE72B42778BBDFB76A3DE52023C7D17961E01AFA82669795ACBC1686EA421639E2E90BC05B8F746663B3D9DC419FD06DF304E472B9F7CB64E710E07B731C2686B53E1BD4E0D03DCD290C787C72F459079D208FD99A513F0752937EBAB3C6B6C1E6465203C739F5932C52C31F155E9D03090823FD2A061D50F3DF4290344366BC8394CD538647664D82B95C21AD015F063ACABE690DA3F4E54BD0DA5F463CAD5B66611435271904DBEF0B96ACBC2FB1664F747434D292A7856ADEF464AA03D0D13207E9891C97CEB60BD0CF355233175F160B179F13D75D166BE1B18B134F91C9260C1B19C83A8B9151E1C59127AEBC9F1526468BCABDB64C711E6D1016C183A447602E6321A2D013FC3BD4F9A387A02A1E122C994CF4E8F01BCA2E8581192146C5525A2ED675A92647441BAD14334999429ACAFBD0D9577FA607D077DC7D3F4B812A51AF2B53B45F16F31623CE2E0FD85D2A0C7DFAEADCF8D0B232E19875142AEA71A03406442E8FE26F0005F44BE931B5C12E9B9F3F8E7E1D12BD70F40D668C5F6CD78D8F7A86318562814C1960C668CDF86896821923908170B0BBDD6FBFBC9172EF7BBB86D36341070672DAF5F6CBCD54DBBEB79B290716E0461988C2CAD1D70DB3199811EC0F2F159ECDECDCCFB71695EFEA0B7035490736BA3A259E724653C8FFF313C56C14BD2F8F2B15B47C2C971BE346B31C5874562EA693314EFB25CECA38332F8D1EF49E82CCD51FF48F66CD3E29BF8A4346E7EE20CB00B5CAD8D641AA3EA4B5D52A4DBFBFCF4FD48C5E65DC036EC1935993F71EFB4AF67B6C9BE0CA84791E7900656DC1EC436C41D2817CF3BBB01FF73607BCBDF306DAC5194C1CCC18509799DF63F736B7444A600EF14A58F8F37C3F7F778F7FA0BD8CA7F8583F1F0737F33B10E3DD2FCD6EB6E9C83BC6914EF39BACE910ABD2461AF493910652A18B21A362E32672764CE434EA317E098D53C691BC77D901A8DA2716EE702A264E341085A3B2AB8C84DFD9FE9B79187FD72F0CCE9F70EF80C244E50722048963B25DC2CFE66F6C835B8DCFEF318E990FB1AD13153BB4CD809BB8300E4D68A9306DE198CD7D166B06B98B518BED1AE398035700ED89ED3B4005FE803F52FE2E0BC02DA2965188DF31B33ACE8C2674EEBF5B35BF8C8869859CC94DE984D104E3CDD68E1E8573DE25A7DD78AF90085526A870E1C1F9CED24B0FB676DCF8D1FC4889CB990955BBED920AF3A6A6F437CCC2D6AF9A332779CE23C92BF6F4716E07D6D143419D28DA7A7CE049B485AE5C9B7B3EF065BCD3EAE182E310199AA9D60A1F0A11E19A0DFDD41A6A03682CE0F1A3B7B100D7D1239AED89BE323F9FC9A7F0A97E7433DEF09C1314F62E7FE73CAC66BD1F361837A32BBECB3F83C4E3FD5C58A8CF09A71C2367F55341E42B511189D007C2DAF02F0DB00FA30F483E17FC501F67EB137E950D26D41F14FE6B7E59186EAEE376794B61787C3FA801A43F16680E6EA94DF687230F8677FFA221FD7D7F38906E4755FEE0FC1C9AF2EF09B5FBA9661B9DBE2B52B278631B2CADC6BF0BEED2AB5D9DEECF39FD7E96BFC6DFE95D9DE5531977AF8430368789E24D4976793223337E0385C0573997A9C320220EB8B6F443EEF16C66F85A21DC5BDE7605C0CB87034C54DB8724EE127E99D9C7218E3B852EFB65C476185EC2CCDA2030DBD211D9E40FC23F959930D995C9FEC85ABF9F9FC13F307D23F8643F9F9C6EFC22EC0FFB3D8196E748BCA36071D2E2F41B4BB3EC5B3AF249C9C8DAFC24DBEC6FF1DB13DC1DCE761AEFF4BF2EDC9BAF6E66E6C12A89392A520289554B462FDD16D2978CFF242E25D9634027A4DA9FD8EECFA18920E587DAA525894F4C6F067FD048ED0CF481D571BD4A603F8CF8676E86EFAF02B1EF0767ECAFDDD2A91A228C49BCC9CF9B78A37F8E3FF2849F3146AAFCF06737486BEA20341D531DB98ABBE7B3C6E9C0C687FC8F548EF104FCA185BDEC2DC87283DD3C6757393027493C24BE4CA26F36CEF6376DC76CA4DCD97ED8463AC0334DDA9C04B1C03EB77F7EF7CBC8DC6C36D8996D34AEE3EFAA34FBDB19C5DA446C3FAD2EE3F3C0E6EE4AC2770F1CFC3A52D21FB695F10CFA8F563A309BF15E484D6BCB9C93FC6CE3776F3687FB38E1D5ECB0BBA30B69B213E4D6AC7A191C92E6C322DA58FDB06A5F5839C7FE1DAF456A09A3AFA2B6ED7D1C76045B7204C3EDD8D872C395D7E135EA25477ECEA10506FB697B67D6434CEAC28C858BFEEDBF787BE6FFD3FEFDC2CF17FE35A7D4519FB3D5F1F9C226C7C7B9EFE45EC95DC014335773E3724F393A1D0F32AFE43C91F35ECE9F723ECC4977700BF1855D0B0E3AF63ABA17B439540BBFCDF92FC78F72E3B35F5FE0CAFC6DF6F29CD49CCC1C438EF0E9C296ECCDACFF9A3F525DC7FADD54B0E346FB829AD0A350EF19BA7737B485D209BD48D8357EFCDEE4AAF55ABFBAC174297B9674886BAE5B70AD1FDCCCE32C37960738086F3F54C3E84012B298E96C1161E520118A1CE1363D094F30866B3E77A84BAD76C5B8438B4919E5EEAE8C752A5FA6E2D0CFB73CD7C084CA3A953DB171C4DD8E9EF17ED8FA42CF82BEB102E2864BAD7E0E7DDCE4FAAD5B58F403FFAE050140EA0F9A7DD97EE1F6028043F6170C4F0D8751AE1AE054CA948A70EC0E2ACE783BCC95091B166419BA64074F660D2BAE7AA0C4EF5E206C5A6080C8B2F07A40CE70AA49428576AB0A8378164DB584DA8FC1FE69B67160C1CF66065A8ECE9FDAA208A61FB2468A4FB41D98EE7A2D2DD24228E011858E755E4B33DB32833E0E921EF4CD944A816A80D10EEC6792C5047B427EC10B2FBC20BE658F41BFC07CCE65C715902EF46A83BE3237750CFDD7E20974E54A649C532C11CA4EEAB04D1D7462CD543395D49C0EF7E60087BE10842FE71223D2CBB90EE2F3A997FED4CED8D4D83EAE6540C3D7907881C1AE190F0AF9397DE13168AB0DE382C14E2C30A09CACDF8732BADD1F5F6B21A38F7A68C5D86222718C883B4AEB525E65B464243A8EBA6623863C631D523231FE0F7CE1D8F8C56F73C60C17F185DCF70882FD3E6DC9CADB5004C00E9DCA09A79FE8E0FBDE6430B94F3A43D79331D385378086B9DE287456D9D27DED80C48BFC7600956DFDA80A73E8A6BE7065A0EF89EAC0F7C7C953E5B4385D7911071136CB3A16FD6460EA6765C2B54CF423B2BEA9CFAAD2C16478EA33F9F90369080AC184122075B7CB636E233E10B8F7D385D2A7701A4F410A1CB3814AC0B836B30B03A482F273FE0DBB920ED424FBB9B8B894D4D40E72D40F9D63B07338F47F980C2B670FE35D0AF93023E5328A3C86CBCAEB920FC386971F02CB1A2DC81963DE5934479135DB2B4767443F8D733C5CF7F87FB7D42D79FDD16C6EC47CBB33233CFFC891F8EBEEBFFCFAE1B13CF79DDE6B287121D58C7CAF5DDBAB64D4AFDA159192666E547610A1CB429F4C7AB507212772B4A393A81C0693E359395FAF38734690E7621AFC901C677246F19CAFB31A93EE28F0D7E5AFCBB372B249C5EBF29F9BDE8BD7AEB9F2A747EC3E76FF3B7FD8DE507B88BFF2EA1B59073E1A3928B2DFFD33B5F8B423D2F17BF786AFEBA9F65F41DE88D8BF6EF9F647F58A2CC8F1807FF8CF7A489E95DB85292043044A0E4C960A603F80DE614C95BA403EFA83ACA9C3B0BDF121363DFA8F2F31D7BF4A78EC2FD4F5577442648C5A9FFA4F0512553A4E2A194EF86DB65B7C8ED18F1E4AC595598E3FE253280EE2D3387E6EFC204EBFFA8B5F3CFC83BFAEFBDDC41F30C7D3073FFBF2A3C78A4E853ED63A4E7CE5D899BAFE7F2F7FFED889AF6B0F7D1823F10B130FC953E943066546166A5BFE2847FC65D9B1B4D799511C9EEA990AC67BCA218357ED413C17531DC295B2430C37F99FEB3FD77FAEFF5CFFDF5CD8FDCB081766C4B08C8CA976863B03FE304CE3A49D514E0DB6E9871AE3ACA500471BAD2579D06F9C825368E0526018891090D011AF716AE2E1A981A7660A463305ECBC4F8B20E0265368107CFED207AB36E5431F0D780022BF4896BFC48D9E31B222E8D710F43237E0712FD92DB5F397EC2E424F379A6F4470F9521BEE4E59BEB412E94F7A20020086F843E42506A0A591E6293418E0CD7F70CD862553F3DD454518B6BB08F0EF46ED254B10DE9692A2A2921689FE12C497F45C228D57A071691ACC736AA6F897C964123F25CBB62F2B81FE25E88279458FAF95E08A36553DB8B448A227C1216A53F88AAA1E9C6EA379F94BF2A5F58A46493358D1343C7A641053CFB5A01F68101900FF7C092DC1B99158819E1EF1A387F52E21A5F56F4768B6C3F2995512DCD43589CDB0B490081E6314F925809F24F32D1624C7192449CE00F14137EAC798921624A7182331351F752B18585F4B49490912B7DD6864001E6628804192B6DBE98C29BB32C600FC9655706148A0123CE02B2961A6DA2D9200103ED5145D6447CC1246D182F89D9E5F320D5F5242D3887E09A0A3D19336D22553E3881F6C37AC7F375ABF5D5ABF46BAD0FA63A4F5C7D3D2C2F38B5E3B74E8B5A2FCFF0B5E9D65D3]]>
      </FileEmbedded>
    </File>
    <File Name="GameFile" Comment="Imported from JETPAC.SNA">
      <FileEmbedded>
<![CDATA[78DAED7B7B405357B6F73A3921090249F079542427C656AA8E22BE220512108D4EAB306A6B5B09A0D6677D800F0882C9B10FC776BCADD3E9EDD8C7A8BDF3B0D34E479DE9C3995A0D44D118636DADB6B4A6842A696B45A2588812CEB96B9F04C447677ABF997BBF7FCE6F939373F6DAAFDFDA6BAFB577124C00AF8CD76B296159E1AA4280F48267E7C2BB67A1B58802E19F024C82E0D4084290168430E08D13F0CE8F35431491533A41D86C11C26C22CA398B207C050705E190411054A21C948E8B304110F0C23BC94D5889B99F0D148A2122AFC71A580DC0C2B3E2EB20CF88F59D9DED3F49E4E73BE57142834A38A415842BD48F18FD3FC18F68A15E10F6E0B08F27908709843A2AE133D441E026FEE62EFE9449E4CF6B23FCE4C215C813C40B2BDE6005E1FC50616B843FB543E4CF739DFC28139F22F267237216E43015A0374CC55B7CF585B45818A205E871837F50AB659215CA60B143F784DF5CCD383B0555A0253433FEDFF947F909359DFC82D00FF9E1243644C72704A75A78DADC5323C8390BAFFB8A7284C8F83746F92B410D2500F178F1931B7512F65B60C4DB4EFD89FCCD5DFC1DE108FFAD11B91318B15AB4BE3F0992D590140FA0ECCE3F9589976B424E414739CD0B18AE5390936B341A0172FE75FE4F76F2FF068622FF38D448647C2EC745A385072E6902EF12F9CB1C4132FE62FF0FCCFFD09BE73FC21F974394BFCC119EDA9D3FB1388720F07821377E9310D608613A228A225C1AB66DC975848E08BAC443B90B54CF75CD7FAE36D7AC05D90FF3FF078BA3BB7D0BF24EFEE76114F2EFD5C53FEC38172266A13BC29B44FB9709A2FDEBFC775EFF5B70790867BBD67F277FB68BBF108AF03F4AFD9315DC8D7F49954D25778482C89FCB5D009B6FCCBFD666FC87F6FF63F9AB6EF0CF8BF07F323ABF8EAF480EF18D91F98DB9697E4539DA47CF083F7CCE1336127EDA9BF96FEDE42F17429BFFC7FC71FE19E41F7688FCB55BBAF86768CD7200F3BFCC9FD7DEF0EF4511FFDEC91FAD4B5C9FA9D1F5ADC0AA495DEBBB93BF3ACACFC914098BEFC0FF6427FF182118E17FFEC7F30F9664D82E1FD284FC0E8A4A22EBFFC34EFB97C767D8B460FF97F987BBF1DF71537CBB6D7DC7DE3CFFA6083F3ECACFE4DF2144E25B57FB35447EB4937FAC7019E39B5E10AEFE0FF807936C976B9541B3403D9144FC7F277F30C2BF800C0802A87600C8BF819A48165A52BF09F51BD510D1E918E855BDA3842CAF6A6767AD8E9FFDE5CBF74F82521D1784789B5CCEB0FEE5903AD506542AC01CDAAFD109FBDBDA4A284119B7858279E7951B9F7042B192E65F4EB904138E084E5BEAE67307CB3930395B6EF5C6ADBFE2B76E955117EE2EBF94C5298F8769FF8978E09CB005AACCFE2A2D1D52863541655838C78DBE00201B4DD3CE2C2899E7B72B4001499A2B71DBA8235F3374D0B623717DE14EA0BBB355DDC63F87F08F7D5FA47D6309DD1D7770D365A078913F6738FA9C3F0B80BED2C5FFD5A73F287CFF1BA0B730B6629951AE62B4C19590BFCD06328C7C1FFE9CBB5770567CD7B60F1E7BE2A967297095699C5C31E5A439C7BB3F3B420B877608D7559BDD072BCDA0F3578252F93624C1822D0A28A1AACF71430F0AF34046D7199A2F66718AC07EE5E37C3C98FDE08264B6C4144F85656F8A1BB3C7C17B05876294D14E13D8D8A083E2349C2269C353419991512441A87EE25AD3934041647FF00378093E03487C8B23A552BA7267289A9F6E06AA19B3618173EE664B890955BDD64F6424D0FC46F1D7BAF68B4007990D7E59AA4A6B4C342E36065FAD02D924806F76383A324DDE2FDAF7C1B806D7D7B7CE6FF800BAC76F399DAD7E1F0BCA60E6ADF2B7364DDB06F2045FAFFAE793394D4BA15AB9450DE62034804E5B62AA013BF58E58AE3F9D791E7D51924C0D26C8604BD4106C0ED15B343541FA5B3F5545855CC232FBC9AE29BBD941EAC200B9F8AE7D0DF60195F896532BEB2E9F414F189FCCD18DA4F63CE74B9BB3FD4738901945FEA850E0A1C9D2860A0A8D98B04FCEAA980C2AE95E217B4419C4189C30E735A1A34668F1B59F857B43D5EFDDCAEFFBB925794F1F72266634EF6701429A5BE59F9C997644088D39FBEB036B92B9E4966793D44C323843D465CEAE328EF98A33C105B1DCC6F88E8B43D017CB33A099CB624B94604383F56B8241E89B0A07E8D0B989652E79C4E2235A101D05432E34EE2E70B5A8CCC6D7E038D0AF7DE0BA397CBC4A977F516F565E2C41473FCFFF7BADFEF24027C8534F12195A1375DC7C69FD4191FFF82415AB8DCF902567366F8CAF841E3D9D70C021D4F142FB071D5FC2A8107BED567E4DA39C796F171767BCBA6A3F4E1FFFF3DBB66397A6F9A1CDB57F4BC5F3CF72C9138F3049C164280ED12167283E491F749A148EC8AEEDAF7CB0A7193448CBC1656A5369A70D349C8E0323755E55B54373F5B789D706ECD90A68C3147624D3C2DA2EFE0AA135EC24F7DA97E004C4BCB6E550F12DFC2BCE6B9CA61AE3400E522FC768D9CB4A7F84BFA827DD893FB6BD75B0D94985EEEF992C37237FD0286C3DEFAFE07A27A6C2FBE54947DB43FD0E745C02479BF6ECADF4F6F40B6A9E4FDB99BBBDFC2CFA4BC102494A151A556A097025F095D90663B05048699F1EE8DD0419494752197F32945CA4C3F38272251564E334408E17027B9C0F56E0161983B2E0DCC03969B60A687F5209C453F55F0B458EF3EFFDAA7EEE27C564EE6546D1FE6FAC058DE9526A2A0B192AF47F01886DD87EB48430E3BAF8CBF82FCB774EC9C9E8C5A9B4D7652A6D706310542CAA11974012D887F6FBC5F48397FC547848CF8132335B9525D7D0FED4671DFE853DABA0A02C7E886653BF727B3374F0D46DFCAF4FCD48783E35A52CAFDF591EF907C198104F01176F84931CAC6693414B36BE6DF60DDB1216823FFE1C6BFC06F92FA642133939BDB19E894B00332E9A70EA1E3E685511FE548BD3AE65286D150E8F56819CDA598E2D9CCB1456E9E6AF2523966FBF85BFEEC366331E2FB04286AA1CE3DBAF4B4AC8CAEEE2BFDD90F5E52F4E729B123CC5A0AD92C999122E045A9C1B0AEDC404A1BE6DFC1947B39FE293630701C75ED53C4173CE799B4CA197875D82839B65434CD59A73F6368E139C81DBEC7F081DFBBC96BD6019EEDB00E00B41899AF05726818DF667A46A8EE2C034C2757E7071DC61E014EBA8607132041738AB34B862E73D777C601298B45F0B2163F5F3A137288C6FACB6C5195625512AF469C5A80F1A7EFB0A6E460E3361D3AED08B77DC1235A1FE0E6B835CF2053D24DD2A3542919A447E8ADACDF3BD771AC3261398A86BC2877C55151DD4714940270967B1807C332832DF30BE3D6A28DC454DBB67FDCCFBEA734AFA72491940B509EB88327BFC5968330ADBE9708B4BA8680E99BEBE16EC1092803AA06989F4255B5677DBF62509FE9741415B81F06A8EAFC6B0E893F57087FED98962E4EF3147687A5365BCDAC5DF11E50F2DD5074801C380578ABE341E281A053FA1962E5DBFBE48A809F6E3927240D92E5412FEFA5241300A5F2AF9087F4773C735C21F063537473B7BEAEE3BE8FF7F9DBF6ECB9F5FDE9235E8ACE3421647E657295CBBC653BCC3EF1076E0F8745F7790D18F3E517FA6DFA3C6AB9999227FE1BA9DA74F2693F1C7538BC9E4251C9C55BECE785018258CA2BEFD66BFBD50F355B09F90F412E83AF856D2D3E4DDF582B1E54BE5F616A7ADA2196C9ACC6B1D7E42B87E7B6428F25ED6E45B8767FB5FE7FF9C70E8B59737C36B0F0B1F14C21DF8AB34EDC45728FA5F0D176A45FE9911FE7F47FE1B71FC72998B28E8AEC68E03AD227FD44F288CFCCF057542D26B20F0FC25B1ABFF74B48BF38F3B5EF41795CD1D424798F0D79544C7A21F76DB0620F86F667B6BFB1C38846FABC7A5C2B0DD42E83FD94EFE02CD3B8251FE421BD9EAC48C6F7F47F17A947F45A5707DBD557632B903C74F276C22FCE31E7BA4B0CE58C49B44FE36BB5DD922F2A7840E9E3808881FE5E371FD2B79C72DFC93FCD1D1C95394B78ECFFFEFE57F87F6396570D210DCA839842B37ECBF3B7FAA990C42F6C0E9E50ED6F8BB7B7E42D6F7207EC07CE4DF9BD83FB4A843A4EDE96FB4FFC5680ADFC2FF2510DAF99DA2EE1FF9BBCF184C566EA745FBAF68CE6CFE40B4FFB82E92FA3BCCCFBF1577B02F4E58155602F471383A72B55DFEFDE7BC2314F16F72A817C7F7FB5933A79F313EA9D7E328637B34E4E4B08F6BB55C64FDEE2705DEB30A176FF79F39B4AE9D8F6CA87AAD5A6F0CEADAB60B843FFABFCCAF3345FD29E1FF0C77F02FE6F6ED34CEDF038E4F6D26F39DF8D32671115253A7CE99D8C59FCA99E4EFE4DF8CFB365C20C3DAEBDB6FE79F4137B47544361BAA57F9087F8EF03775F1FF3FC4947F8AC93F8C1F25CFF961FC5BE4226A6F435460BE15B7B09B049649782AB5588024F2471E086092C532C53209261110F9245161964E79247F52141079890D59BA15B8155DD268014203DFB2B3B3274FCECD9D32A59BD802FF446EE9D67717BA8991DD1DD05D9E33C9F28388E8DE72EB9C46F801E4FC43392920C2927B0B2CD12E2152E27679B47D8814B0FC1328FF45C0FF67E8E5C589504C01DBB4C7D538EFFFBE7F417C1912120C3178D73786C263441CEE01C9FB3FF86428C30C8217C245B3052C2950D04B49416161EFC2770BDE2FF01414161E2B5858B8B87078E14658554892EEF982E87710325BF0C80080A14FC243D8B71EE6EAFBC1547FBE5EABEF478B1FB23D3DF237E3F746BBE9715BC7DF8250240857635FD7DE7735F6509F591B3587FACC2477F91CEEDCA88EB4B1E3268C5323A72248FF74E468F586FB8F1F3F3E62B45AFC64A65B4E9A5AFCACAA5BCE18CCA16FCA198B39F29B7248CBA8A7F4EFFF3411EF6201464C508BE1EADEC13F9D3C3B3F7B123B6D167B7F5E76EEB41996C1F7FE6934E9050F6C2346A7AA4532F70EEE4DE5DF3F397BD664764EF6B4D9837B93A6880C3122FA9EDE3C78F01BE9759D4FDFFF29DA6977F9EE1FCABE9A3666429A1173F614C088B43184D3B728C3ECF113C8606C983D9ED4CCEECC25452A3077F418A2A42730FBB22DF3403749FA95CE1E6E6AE5A6CCCE466CE9DF3BC90C8C27C26248B0892D7217A3FA4FE8BE79A1D3D84EA8819B0BDD64D29CFC7BE684DB3BE6D14278E295F10BC7EC1D7377E117B2E940BEFF5F5668842C5DD940BA1764B5B8B8B972AE78A0C2B66FB33C75AA417E32D54071EF11073C24F6F5F764386B49F254E290B58C9C2BB250A062E4C04EA28061D4C08A9F99591CA3271AC7B0D923278DB48C64B3EFBF9F9D39CD3275F62C76E6E45993673E38F9D0A4BCFC87C52CF61F17CCDD7D8AF7EE2BF5D6967A9F2FD5B30F5153D8D211DAB037A9D43BA4D435A2343D680DD06C0FAFB7587FD93AD6FBF23CEF3D4BBDCF147B5794797F57926E2B48FBC4EAD633C589A9568A81A63D592AD7B595FAA956450F6FF1227D86D5F3AC3E172FE92D05018A4D48BF6CDD75EC8179DEBF17BB5E9E977ECDBA2BA589641D9F3ECFBB6C5EFA47D651691F59D3C75A3146048CDE6B2B23E5B2F6A6BD340FBB4CFCF93CBDB1C4BBBC5421D7030CAF7A876DD75E7367FD85F163CD5D299F3157BDDB16905B56E11D3ECFF5FD3CEF3472D507AD8921AB42E6DD304F9F6A4DDC66553003669457F434F4D2B6B92D96ECE993D9BC0727CF64F3EFCF7E18DFF6EAB5181DAC948A90E1F42D059E2929B25A47DAA7561C6966DA65AB0B69934E06E919F0AA572B687B2B576EC091441E020EF141FF19300DE91505FC134E7DB080821EA5066DB86574B0008964C9D38E59BDC5F3512973B2DA4E757CC18FF25852649EC73D7978ADF1CCC1EB339E22BC1EF32CAE19B3607D5A4B81FE59523CCF93CD267867CEF74C63E3F0CD45CDF73E3C9FB94C2E2D1EDEE0396070E30BEFDC89FF31BF4EFFABF9892FCD5728EA06A49DB1F6AA3B6C37342E1E99EA15E6D73554F7D27EAB877D89E662D4A73B12D659E3D487966C8BAE5F512FB326DF3F79D2EC69792746A3C318DDA921141D267E24AD7BC618CCB86FF2C33979D9330F8D15EFA7E7CF9A9D3783FD69DEC3B3664F9BE4198799B36667CF9C2D166FF4AAD6A49FB1AAEA1A506B2E5BA9427678775AD08A9AB96C4553436BA8D63665C5A45DB38A96E3C41BB7FE2AEAB1D8FB41A957B3C0FB8BA5DE3F16A33ADB7D38A9BBD33C5634C5BCF44FAC7F3BB470A9FEF5A58DFAB50B7C765006EC790A88B51B16AD72ED2918B8F42F6B4AD79D5AA15BF8FDF251CB3F5FB0778972F19145DF2D9ABDE4BE25DB1E6D5E165EB57CD9B0AB054D73DB0A362C5F5CF9C89C5D4D338DF1EC3DE9AD0545E9D70ADE37EAF46D058D89C102053DE08051C5CAD1845A1BDC0D9843D1682E64844CBDDE83CBE4EBE53E3BB1524F1E6BF4AA1E4D9759CFC4FB0EC88EAB1F4D3F6E0D9853E4431077DDC58C4B3F610DE89C3E8FFC441E4A36061CADACAF3CC6379EB6B87DE362521ECE92FB3C5096226BCA5D858D60134637E3426601672BED2B079F9D7ACA574EF9ECB2277DE532EFB2D5DE0F4BF1814F31EABC3357A2B530DE41659E596CA2975D3928A55FA4A2122BBAA907C07BADC4DBB4D8F5C212EF0B4BB228EFD825AE754BBC43D7446A287C6365F847EAB1BD777B1B1FF5EE5CED1B8F21255F86F55CB14B7C764540A3F73EEA5ABAE0D347AF616A7954BD10073E452C5CB8DA8523D9A4D0BB16931928343CE846592EF315E1AFE39954053E02730AAF93192F666A3401254B65B49A7DE534B31F87810AF4CCA9797521AAF0A7B83CFA8B0C06DF3CB865A417F4509A808274FA8AD829EAD2FBFBD5B89D22FCE825C328AB6F1DE55B2BC336196FD753FA68ABEF45EACA96854DB9BC22F51DAC7586649553CC1F9119CFA40CF70CF56D92F1EF7D6E5A989E616DA5D232886BCA481B6B4579AD8AB8A7DF8B1A71752C262ADF430A8EC302E3AC4C633A5803A6A33C7D526F2C4E34136F326097935077389BF6787B2E4ACBB6361505D464910754AD6CDA14346F761131068D68B06E159B926A343F546CE3363BFDAA878A6F34985A9C68EC6C709C95579CC466470534D17627624346AB223E5105E3A1BFB6DD8D43ABED83B6A1AFB6DA6BFB949391EE4B99983A980C46CE0E4FDCED389DB8C581938B7778FD089588739213B1A3339D35CFF429776331E654F7B2AEDF2E22F3344E8656E45DBA48B4BBD487D1DF8EF5CE5DE41B0BBEF131E0FA63312933B65B99F78CE3506DB1184A9811C4DC8885197CF6185E614C22B51A7D7AB0124144BDBE061278D0EBFA5652BE45B246B40B8B1A0E9359D704E8BD9EA1DE6F88B95593E16A71B8E9D5D633DAB46A6B45AD3C4FFB59962CED10FA0797B501E77CF08756DF14B987B5615743B1C75D297A5EF17DC4F8E4AD93F22E57A4F6F44D21AB6F9277EFE22C85EFC5184B96050DD2B577F161D448F5B00FAD5567548BB11D6DB3FB44D5840D0BAB766EB85CF5C886CD55AE0DBD376CD8F066556043923D9262EDE3EC33EC8FD9393B0E4D83C0C56D9EA3D6327DFAB2EA7C46D3375F9DC2C4F64D559BB3B4A7F81C2DBF5BBC26B041B75A95ADE5496EB6981B5FC11BD926779E47AF80C414ABDEB224D68EF1CBDED31D2F4F90FBC651292C361B476E708953B54CDE8DBAD991168926DD44B59C15B53BC360474B27175985F7CD25BE86DD69607577BA159C365F39AE4F50F9C6CBB1D6F8188AB944DC9A6F861CD583FADAC9D2BEB1F20A321EBD662959DD91C9C195D49BA75387A311115B56B6E610E5115352A0CFE936A7E83B4C3CFDB9AFD8ED1DB6DAF5FAEAB42AA1F27865E49A7EDABACBA977C2F00D6FB3ED6EFDE4A538D5B821482AEA0BFD1B13A1D07BF7AA86C44585AEE9ABB657BE53F98A7D9FFD7B7B5FC769FB69FB794C631C631C3331ADC2D412D99F645169A7ADBE460C1483DF599AE54A3BB554FF9BA5833F594AECCCF5B305FACD627E3AC9CF9561BE1BA30B51C9692B767FC23A16D792AFBFAFB181DA6CDDD594F3F9CF1664F12468A3536A1D76DC6A187CDC7A373415E521E34D1BD34E5855E91E2B4F1BE355011D9B42EE15A9FAF44F71C730505CC499297426ABD5E75B150A6CD8BEEB58FF65FDB5216FEA226FFD42D7E4058DDFE93D2BC4DD87AF01355D1440872847E555061CB529385FBEC6EA0A9D4E17A0333250B7010A674AFFE832B24B5312058973F82E96776997D1890AA52686D644231206848463816564BD1DFB8F4777A7B9ADA2334DE9E3A964D33D0BD88CCA80B9085757E0E05F49971E7919DA52CA885A1909301E39B1E294C1E44996EEB6EEAA59BF22039B60DE47D101E623BCF28CE78C8CF9F88C8C1F92FAB9F8FC09C59120E34A59DE7D088397DF3684FE9ECA1AF972CF829AB8E538884BDD87618FB1A04FB4058296744AF4D86F3E468676CCFB5805AF49A532F27C8B286FCFE518AA7D6BA90D81E05E123EED8AAE4A18345F945DA92395ECC7AE3F5691C92E2523C66AB248B52A745A842D8FC422F515DDF8B954627729BD2B326BA691DB77A31DF677CD124710CC609A50F677226B758945EC29895D639389459F21FD6E1175F21D8A3EE61ECB7071A4E801570A79E3F16D49453F442088B3E831787ABAA97C3140BFB064B76BEC92A8FE448DA10E29331CFBD58AA81A6FCCE23A9CC5F25B67710A7B175A665140C30EC2A75A31FED6A2A354540638B1A0831464FE468A12F72113198C1727DA374EC1923636A125886A182E5A4377FDDCB75C34801745725BCF9010502BDE3BD1184E89715CF42A69355637321089102BD8BAE28E56B07D055AC15B2B6EB5828831D6BCBD42ECFF6EF0AD54DCE37B50E62B8C1147BBAEBF6F5D0C3AF81B73497267FBC692E18F570864C0AC42B4D717703CDF47774F91FDD265713B541CD5761685EA26945069B52A54936BE40A718646AE382373A5AF202AD923127C63D7774D335DF92BF0B09CC3C92109B98A4E32A22AD6E8DB1413D99AE136A86B7316D9BFF4411554EC62555115B8A9BBBACD35461DA6165D5332D889B790653AD151A3E14F58895B95F893E44176E53E7CF03DA8AC5533B2BE7DFE7E329972A333D1ABAC0A79A37D57CA0483C1601F8E0789918110A95A86A5D52A46A666FF963A703869A029F7FA8B2B6B714FAAFCF8C5956A0C058150396E65FB6B9D6A70DB54C930C3F0A0C1B6EBA867A2678067A036A4B2B80F2B541A4FA2B6BDA21A0BA8C1EEFDEBCA2203B9CE110BA2CDA29414AC4BFF18CF6389DE032B4F1FAEFB688DE1A3D5863506EDB76EEF6F56324D7991EDDA5EDCE6E0DE3036F1782186E85318A23FB6AAE5BB0F5BD494376795AD7AF8F004F68A9B92011E0950CADC4DC9412CC8B488778CB6F1F461B2AF371898DE62B1F453C4D17F6C8DE6377E87A79CC37695A16E3C18C6D306159F68946569CB0D16EFD995D50D8963A0FF47DF190C588BB324B0C7DC182A02B41335887A54C85187F2FE788C1BAF35E0617080A5D78040A83526CF539232E68C2AAFD7803309E506055D5A116837946BC30612EC8CAD4F961BBED37FBB8A3CD0E22EAEA72B798965D2A4C90302CA0A3C44AA6AB5013E8FA9F63D48AC0267C7B82A4BE5994C36F74F15CD274722B41D9E4BC5DED91CDF1AD978819C8E7C7625EEDA1467882D06426439CA5EACA392E8647F5D328DD180A6E91EBE3FCB50945867CBBEAF8E1EC4368BD1BE81F9A487670E3B102D96C45BA5531C58ABDCF72E9AA3A247AB5CE6EE716300B2F9D8BFD8C0A83F94D3836AA697B8F566C03CEFB9925D2949DE8325FA3DE2E3657CEC599BEABDBF34F18B92C3A75D05A5DE8F4A98AFB258CCC9625DF797324332EC8F64642C124FC9723C35BBF1A4EF16CFE8AD4C50CC8DD1B71630B4FE5A817DE3D0F2E1F6CDE4720286968B42955E6F4EC493945A3FD19CD856C028F43F31470E5DE2264A23F63D20FA8EE758F7E1D38DABEE867BEEB9A769EEF882FEDF35285403CA7B0DD15EFFA89A6CD646B8896607A87A8967CDBA011E079E9DB1629DAA7C848A690E38F001EFDD789C4F7CAB148FC37A1B24BE23DE7C06897B4B5DCB4B2DA31F3869497BE0E4E4A96E3D98150FA9A1D450B5CF781D9F1E52CC555B98601DEE0CB1F5F443564BBA0BB793199A800EDDFF83F4438D55FCDCD444FE2163C2EA111B704720DF70865DA5BDD0707817C542534EF5A404F6AC7B0321A65B55A554E605FCEFACAAC0697A68B1DB5BBD7A98D33AA0D753AB0801B4C1B4C35635F4727BCFAD8E6CB78808F7A2A214B7B958A0D68A5B5DE6F3D3DEA1ABEB3EF29A56D7314A6FC6EA3AEF90D5B82DC6657F6C43F9F52DABF3D20F5BFFF6F986F25F6283AEF4F2BAA6DCBCF45ACCA92AFFA56B6B395663186C80A1B15ADDEEBC48A375589034B51BEBE4E17DBAD31A50E4A5D7583DE529324F5D26F9601FA32759D6D7CB22E73D3B8525D0DD3267EFAA0A2879A593500FF879FFD1AA5AD5623779EAC69C10C762AA2A92C3B49A17ABDE5E4CDA4873E2814B861B7A6C8904912F74A3DCE92D05782CFC3EB20F0B24F3C929AA406FBE774A6FA64F96A32B2F5ECCA3B33ADC59BC3B4B88D63AA8906575886574BC8E55661DD45E4159567354BC13C5EDDDC4F511719B5BFFA915BDC28071351FCCF3C62E895A2A03DE53F39818F2694F2BD9DE66ADF1588E35ADF1E41D1BBF8E445A2AE52ED7FC7578847F97C4849AEC75E9C7AC4DB9185736C5F0E6548C0F310C06A8183389683168C1E81AD28F588BC4C2A3D6F5DF9076C48ADB1A7164356BD6E2D09ABB86362CAB4D7BC5FBAB359EA29A1EA4870324E6D5F4B9D1838237A5E2F94DC1F4C610088CDA9BBEC633E7D88AB5CC317C36610415D70C46D1F4A3628FF66373498F47AD622075A6E6F3C38C33239199C1C87C762DEE2E922B2F99BBEF2FA2416DED1ACFE2E3BF5CE58EEC7048F48C447D19F988821C27C8004E891B853F8BE1D9AEF098527E4B06B71D872E86EB9A47D6E2D0CF90815F59B296D4C05E2E71D8896BE35A31D4DEBD16CBB68ABA09AD89968DB9A2582BF68065C94ED9A58994DDB6B65B81DD2EC5DACED949598C9373751DA9232A2FE59E08C5C19EB9C78EAC2587C29A236BC5CF5C14789E72E1FD580A0BB3E44EE4843B6E209F22E0596A2AB1C95D6C0F74B7F4E069568CDFBE063C0EE35FB45E64DEDF15EB3FB90EDB8B12688DE6A8489378104AA1554CB2EA4CEC95D165B5B14C6FF2016771323446E2BEA2AC29D7D362301CF87861596DCF039F9BCA3C5F44637846C6F58565BCCCD813E3B831363313DF527B78CE794E35B83DED4CA801B70106EDBB6EB1BDC378D438556698813B8340B8297763ADB671F822E25912BF2AF37E5176CE7ECE63F298CEC82D8917C8B3B63DF10A796FB8517ACAF0E1338A571D463F57DD595A66A9283768C30D866A26A65AEC6D1BBA6385CA55583ACA21F8DA2B4BF51F0842DB77BEB7E4F7F34296C0BFAA7AB1DC5DDEDB56649B5BA1ADF0D9DEB0FDD7FAD3EB5595B32AE7AC8F5F5F57F1870A2884C231985EC2B408D3F142A130AD6821A6B422019F2A76A54C4C38DC3800C354AF6E1EB5B9C17B6975751D4A19227DF726613022645C2867FD75E8FE88C3DB7B9438B33ABCCBDB8D4EAE8EF91DE0BE0258F80C72C108F9C9905405B3997B4299A14A6EAE736DD6EC936B4FCEE18A61B173A47FA4FF277E352839A0991E00F9E2771078A3E2A00F662A4107D047013DECA0B143B21FFA06619086EB3316068D853E7EF29BD7FE4188DB27FED980E680F203364589DFB4683920FFCF81D76A3F504EA51362B239D90E8EAEE794FB20663F2827F963A683723AC4D848494515C82E897F5F8ABF07B591A654620BB12C90DF516F05D949CC2DA18240E517C32E3FB4F9A94B40AD02EA64889A65A64E99A942F2734B6A07C0FB1CF97B8F23BF7B4B06958C01158E6A200C86245B0FCCCB6286E95ED0EDA7BEA43FAF1A19372C6E247501147440B916D3DBD8879F54C9476DEC847C4AEB7F1D47142A7EDD9E6F0F2A6D9A25C17D235E1FB14FF93A309A6D834E0E3A997C121912358ABF766501CFBE500C14289F2846B500EDA71EDF495D3353ED4E18E487CC9DCA1A3FFC6527FCC50FC93B49C9AC62283793BF4A33F9062A19C4A6B4E4BB2FF956423E1692E3CCE45B1A0DA7E8C1291B41D90C50CE412BA78BE364C738998783F51C217F8DA37C40FE9AC4DF3CDA44EEE4B7311CCD919FA2521C7D807E83FE840EE3FB3FE08E7070F772FDB938E807EA90FA754DBE26A8F9E636EE47938F767117FBF939D04F70D4531C9C00380B50E907FB4EC83483C909993F9EBBD85408E87D406D03D823FED8BA99830B1C7C2F7EF9DC7627EE9739EAACF877918B70870811CA4F3923DC37381F700E779A9C95CE1F5C0BD12A3C75167B3E09DFE84AFA94F4086A82C9C1BEC1419A3E63078DEDE367D0F2E3F6F5DAD7CB864AF5770D181AFC54B5937A8D833500F782F24B88B1836C3FD06150EEFFB136DFF963623F0C72427F0E1200D41CD506D41C80DD843BD57C279B7F0EA87B39F237216AF371B290ECE2CF9E1D7AEE57D79ACF0DFDCDDC9ABBAE523695364E6E936DB9EB0FFDEA5DE7E63ED7D734FD65EABCBC04D716ADC575A50C6DD2F0C1C7F85058080B0E9B70E0BC602FB45F3B5829D4FB78C1D47C6055F3A1C5A742F7BEEAD7A89D58253AD62A8000A879A7CEE1D71D74EA3E0D699AC3BAE68BFDEAF7270B9FC51E742A759D5FD2D237FF36201EA82F9D74BD936E76D27F2AA1EB43941082517B600CF9B7B02864DAED79243D9E5D30B260644A6F073F399A1CFC1F16FE6161DD362C52F78A20FC427826F119DF331F91D72FF0491044F12B75AF38782C721F7F57F8AE70AF50B22A3648924A1BE3979929AE3361917DFDF6F5FBDBAF9FFEE5CC630F5CF8BEF9EAA8DDDFFF11D335E16F6D9184453A6F9FBEFC70EBC3ADF75CBD27DC3FD49F89DD139B8AAF60AC168BC4E68B29D89954DAD8608C1F3B73CA9CD18EB83C2ECF99579FF72949FA4F477EFA5F735E9DC34FB04F281B58165796508645E2CAE2AB34AD9AD6B8BE7165F83A93D037AE358E3C3D983033EE91B8474891EB71D73598E23129AFC831D157284C4052155A0176443D7DF9E9CBEE96A3BD1ABF6EFCFA4A5ECB87EDBE5F7CF4E6E937EBDFFCB4BDFE7D1F1679DFF7BEEFD7DF92F4DC659234415D88A441FBFA6F4BDCDC7F3316E9B3B917DEF4D93C705BECD6D8AD097B6276C6EC54FA69274911462A21CCA9CDC9661D6B327DA9BBA809812C8E61C8EF02F73DFDF7F79F79055F64420486418126A4951BBECAAE2E7E827D7C55E58C89437A6AE5A44642495228EBE0A56D779724B12A2D226EA7C61FE3943BD187CA624D61072F081F0A470497506C37666882208B476FE654FAC9908D494BFA5ABE1A755517D20469A7BAA779C00B8F5D28124CFCB51DE397B7AEACD861E2F33A3457FB7ED32357DD23B7EF379AABD33B4C7CC58ED695E3975F436191F0D885012FF4342B75C1235C7BBD70F1C36032F19EA45B6241A670C21EA59FE2B44ABF2E4432C96808BEC6744E28E52BB0882EA4F4AB6F2E40C40BF8527EA228D4D01C12322BF155B9FF6AE13B0FBE30B3723F798ED0546B71E19A9CF3424E93201C731E730A82D3342F647226633050C7A7F63A1AD1423DA6A9DBA7AC1C75B5FFB6FEDB34414531C83460966F9699B55BE31E1A327FD6DB13963DF3C89CA69157DFEB28BCE8B83A2A4C56920638F1C7346C4F0CA7B1BFEB797406D3E7E3617F9CFBC94F46F6BC7A70BD2EFCA3BF707F4E00091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020418204091224489020E10BD974F0E7E3CDCFF44AFF9C2F64E4B9680EC0D0AC96841371E7F34FC435E627F53BDBE344DCD7F903F0FD5346097BC7AC288C11AF80D733054B0BC1E29C53AA6E49D0F7AB4D168ACA06D2BD200B327272EC39390055395539395580CF66734E06802D372727D70660375799CDF6E8BB5994CF2072B11AD6CB5221B2006432590EC9CF9D5A323517F3CD04582F67D12362B99CF9337F3A2587D4CF11CB91DE22EDE5CCFC69F499D4CB3067C8889CD712907EC4F2FF0DCB3B5003]]>
      </FileEmbedded>
    </File>
    <Group Comment="shader render" DesignDisable="255">
      <Children>
        <ZExpression Expression="MemSampler.ValueArrayRef=mem;"/>
        <UseMaterial Material="SpeccyMaterial"/>
        <RenderTransformGroup Scale="8 8 1">
          <Children>
            <RenderSprite/>
          </Children>
        </RenderTransformGroup>
        <ZExpression Expression="MemSampler.ValueArrayRef=null;"/>
        <Material Name="SpeccyMaterial" Shader="SpeccyShader"/>
        <Shader Name="SpeccyShader" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D mem;

void main()
{
  vec4 color;

  float specX=gl_TexCoord[0].s * 256.0;
  float specY=gl_TexCoord[0].t * 192.0;

  float index=0 + specY*32 + specX/8;
  float u=index / 65536.0;

  vec2 uv = vec2(u ,0.0);

  color.r=texture2D(mem, uv).r*8388607.0;

/*  int pixelbyte=int(texture2D(mem, uv).r);
  if(pixelbyte) & (1<<int(specX)&7) )
    color.r=1;
  else
    color.r=0;*/

//  if(color.r!=0)
//    color.g=1.0;
  color.b=0.3;
  color.a=1.0;

  gl_FragColor = color;
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable Name="MemSampler" VariableName="mem"/>
          </UniformVariables>
        </Shader>
      </Children>
    </Group>
    <Group Comment="gl raster render" DesignDisable="1">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[byte[6144] video;
//for(int i=0; i<video.SizeDim1; i++)
//  video[i]=mem[16384+i];//rnd()*255;

for(int addr=16384; addr<(16384+192*32); ) {
	int y = ((addr&0x00e0)>>2) +
			 ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}

/*glMatrixMode(GL_PROJECTION_MATRIX);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW_MATRIX);
glLoadIdentity();*/
glRasterPos2f(-1,-2);
glBitmap(256,192,0,0,0,0,video[0]);]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
  </Content>
</ZApplication>
