<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="4" ViewportRatio="2" FileVersion="2">
  <OnLoaded>
    <ZExternalLibrary ModuleName="kernel32.dll">
      <Source>
<![CDATA[//Import a DLL-library by setting ModuleName to name of the DLL
//and then declaring the function headers here. For example:
//
//  int SetWindowLongA(int hWnd, int nIndex, int dwNewLong) { } 
//  int SetWindowTextA(int hWnd,string lpString) { }
int GetTickCount() { }]]>
      </Source>
    </ZExternalLibrary>
    <ZExternalLibrary Comment="OpenGL 4.0 graphics" ModuleName="opengl32" DefinitionsFile="opengl.txt">
      <BeforeInitExp>
<![CDATA[if(ANDROID) {
  if(App.GLBase==0)
    this.ModuleName="libGLESv1_CM.so";
  else
    this.ModuleName="libGLESv2.so";
}]]>
      </BeforeInitExp>
    </ZExternalLibrary>
    <ZLibrary Comment="jasper" HasInitializer="1">
      <Source>
<![CDATA[//Based on https://github.com/begoon/jasper

  const int DEBUGTRACE = 0;
  const int PROFILE = 0;

  private const float clockSpeed = 3.5;
  private const int tstatesPerInterrupt = ((clockSpeed * 1e6) / 50);


  int Keys_B_SPC  = 0xff;
  int Keys_H_ENT  = 0xff;
  int Keys_Y_P    = 0xff;
  int Keys_6_0    = 0xff;
  int Keys_1_5    = 0xff;
  int Keys_Q_T    = 0xff;
  int Keys_A_G    = 0xff;
  int Keys_CAPS_V = 0xff;
  int JoyState = 0;

  const int IM0 = 0;
  const int IM1 = 1;
  const int IM2 = 2;

  private const int F_C  = 0x01;
  private const int F_N  = 0x02;
  private const int F_PV = 0x04;
  private const int F_3  = 0x08;
  private const int F_H  = 0x10;
  private const int F_5  = 0x20;
  private const int F_Z  = 0x40;
  private const int F_S  = 0x80;

  private const int PF = F_PV;
  private const int p_ = 0;

  private int[256] parity;

  private const int true = 1;
  private const int false = 0;

  int getSignedByte(int b) {
    if(b&0x80)
      return 0-((b^255) +1);
    else
      return b;
  }

  {
    for ( int i = 0; i < 256; i++ ) {
      int p = true;
      for ( int j = 0; j < 8; j++ ) {
        if ( (i & (1<<j)) != 0 ) {
          p = p ? false : true;
        }
      }
      parity[ i ] = p;
    }
  }

  /** Alternate registers */
   int        _AF_ = 0, _HL_ = 0, _BC_ = 0, _DE_ = 0;

  /** Index registers - ID used as temporary for ix/iy */
   int        _IX = 0, _IY = 0, _ID = 0;

  /** Stack Pointer and Program Counter */
   int        _SP = 0, _PC = 0;

  /** Interrupt and Refresh registers */
   int        _I = 0, _R = 0, _R7 = 0;

  /** Interrupt flip-flops */
   int    _IFF1 = true, _IFF2 = true;
   int        _IM = 2;

  /** Memory */
  byte[ 65536 ]  mem;

    /** Main registers */
   int        _A = 0, _HL = 0, _B = 0, _C = 0, _DE = 0;
   int    fS = false, fZ  = false, f5 = false, fH = false;
   int    f3 = false, fPV = false, fN = false, fC = false;

  /** Flag access */
    inline void setZ( int f ) { fZ = f; }
    inline void setC( int f ) { fC = f; }
    inline void setS( int f ) { fS = f; }
    inline void setH( int f ) { fH = f; }
    inline void setN( int f ) { fN = f; }
    inline void setPV( int f ) {fPV = f;}
    inline void set3( int f ) { f3 = f; }
    inline void set5( int f ) { f5 = f; }

    inline int Zset()  { return fZ; }
    inline int Cset()  { return fC; }
    inline int Sset()  { return fS; }
    inline int Hset()  { return fH; }
    inline int Nset()  { return fN; }
    inline int PVset() { return fPV; }


  /** 8 bit register access */
  inline int  A() { return _A; }

  inline void A( int bite ) {
    _A = bite;
  }

  inline int F() {
    return  (Sset()  ? F_S  : 0)  |
      (Zset()  ? F_Z  : 0)  |
      (f5      ? F_5  : 0)  |
      (Hset()  ? F_H  : 0)  |
      (f3      ? F_3  : 0)  |
      (PVset() ? F_PV : 0)  |
      (Nset()  ? F_N  : 0)  |
      (Cset()  ? F_C  : 0);
  }
  inline void F( int bite ) {
    fS  = (bite & F_S)  != 0;
    fZ  = (bite & F_Z)  != 0;
    f5  = (bite & F_5)  != 0;
    fH  = (bite & F_H)  != 0;
    f3  = (bite & F_3)  != 0;
    fPV = (bite & F_PV) != 0;
    fN  = (bite & F_N)  != 0;
    fC  = (bite & F_C)  != 0;
  }


  inline int  B() { return _B; }
  inline void B( int bite ) {
    _B = bite;
  }
  inline int  C() { return _C; }
  inline void C( int bite ) {
    _C = bite;
  }

  inline int D() { return (_DE >> 8); }
  inline void D( int bite ) {
    _DE = (bite << 8) | (_DE & 0x00ff);
  }
  inline int  E() { return (_DE & 0xff); }
  inline void E( int bite ) {
    _DE = (_DE & 0xff00) | bite;
  }

  inline int  H() { return (_HL >> 8); }

  inline void H( int bite ) {
    _HL = (bite << 8) | (_HL & 0x00ff);
  }

  inline int L() { return (_HL & 0xff); }
  inline void L( int bite ) {
    _HL = (_HL & 0xff00) | bite;
  }

  /** 16 bit register access */
  inline int AF() { return (A() << 8) | F(); }

  inline void AF( int word ) {
    A( word >> 8 );
    F( word & 0xff );
  }

  inline int BC() { return (B() << 8) | C(); }
  inline void BC( int word ) {
    B( word >> 8 );
    C( word & 0xff );
  }

  inline int  DE() { return _DE; }
  inline void DE( int word ) {
    _DE = word;
  }

  inline int  HL() { return _HL; }
  inline void HL( int word ) {
    _HL = word;
  }

  inline int PC() { return _PC; }

  inline void PC( int word ) {
    _PC = word;
  }

  inline int  SP() { return _SP; }
  inline void SP( int word ) {
    _SP = word;
  }

  inline int ID() { return _ID; }
  inline void ID( int word ) {
    _ID = word;
  }

  inline int IX() { return _IX; }
  inline void IX( int word ) {
    _IX = word;
  }

  inline int IY() { return _IY; }
  inline void IY( int word ) {
    _IY = word;
  }




  inline int  IDH() { return (_ID >> 8); }
  inline void IDH( int bite ) {
    _ID = (bite << 8) | (_ID & 0x00ff);
  }
  inline int  IDL() { return (_ID & 0xff); }
  inline void IDL( int bite ) {
    _ID = (_ID & 0xff00) | bite;
  }


  /** Memory refresh register */
  inline int  R7() { return _R7; }
  inline int  R() { return (_R & 0x7f) | _R7; }
  inline void R( int bite ) {
    _R  = bite;
    _R7 = bite & 0x80;
  }

  inline void REFRESH( int t ) {
    _R += t;
  }


  /** Interrupt modes/register */
  int  I() { return _I; }
  void I( int bite ) {
    _I = bite;
  }

  int IFF1() { return _IFF1; }
  void IFF1( int iff1 ) {
    _IFF1 = iff1;
  }

  int IFF2() { return _IFF2; }
  void IFF2( int iff2 ) {
    _IFF2 = iff2;
  }

  int IM() { return _IM; }
  void IM( int im ) {
    _IM = im;
  }



  /** Byte access */
  inline int peekb( int addr ) {
    return mem[ addr ];
  }

  void pokeb( int addr, int newByte ) {
    if ( addr < 16384 ) {
      return;
    }

    mem[ addr ] = newByte;
  }


  /** Word access */
  void pokew( int addr, int word ) {
    pokeb( addr, word & 0xff );
    addr++;
    pokeb( addr & 0xffff, word >> 8 );
  }

  private  int peekw( int addr ) {
    int        t = peekb( addr );
    addr++;
    return t | (peekb( addr & 0xffff ) << 8);
  }


  /** Program access */
  int nxtpcb() {
    int pc = PC();
    int t = peekb( pc );
    PC( ++pc & 0xffff );
    return t;
  }
  private  int nxtpcw() {
    int pc = PC();
    int t = peekb( pc );
    t |= ( peekb( ++pc & 0xffff ) << 8 );
    PC( ++pc & 0xffff );
    return t;
  }

  /** Index register access */
  private  int ID_d() {
    return ((ID()+nxtpcb()) & 0xffff);
  }


  /** Stack access */
  void pushw( int word ) {
    int        sp = ((SP()-2) & 0xffff);
    SP( sp );
    pokew( sp, word );
  }

  int popw() {
    int sp = SP();
    int t  = peekb( sp );
      sp++;
      t |= (peekb( sp & 0xffff) << 8);
      SP( ++sp & 0xffff );
    return t;
  }


  /** Call stack */
  void pushpc() { pushw( PC() ); }
  void poppc()  { PC( popw() ); }



  int bordercolor;

  /** IO ports */
  void outb( int port, int bite, int tstates ) {
    if ( (port & 0x0001) == 0 ) {
      bordercolor = (bite & 0x07);
    }
  }

  int inb( int port ) {
    int res = 0xff;

    if((port & 31) == 31) {
      res=JoyState;
    } else if ( (port & 0x0001) == 0 ) {
      if ( (port & 0x8000) == 0 ) { res &= Keys_B_SPC; }
      if ( (port & 0x0800) == 0 ) { res &= Keys_1_5;   }
      if ( (port & 0x4000) == 0 ) { res &= Keys_H_ENT; }
      if ( (port & 0x1000) == 0 ) { res &= Keys_6_0;   }
      if ( (port & 0x2000) == 0 ) { res &= Keys_Y_P;   }
      if ( (port & 0x0200) == 0 ) { res &= Keys_A_G;   }
      if ( (port & 0x0400) == 0 ) { res &= Keys_Q_T;   }
      if ( (port & 0x0100) == 0 ) { res &= Keys_CAPS_V;}

      /*if ( (port & 0x8000) == 0 ) { res &= _B_SPC; }
      if ( (port & 0x4000) == 0 ) { res &= _H_ENT; }
      if ( (port & 0x1000) == 0 ) { res &= _6_0;   }
      if ( (port & 0x0800) == 0 ) { res &= _1_5;   }
      if ( (port & 0x0400) == 0 ) { res &= _Q_T;   }
      if ( (port & 0x0100) == 0 ) { res &= _CAPS_V;}*/
    }

    return(res);
  }

  /** Interrupt handlers */
  private inline int interruptTriggered( int tstates ) {
    return (tstates >= 0);
  }

   int interrupt() {
    // If not a non-maskable interrupt
    if ( !IFF1() ) {
      return 0;
    }

    switch( IM() ) {
    case IM0:
    case IM1:
      pushpc();
      IFF1( false );
      IFF2( false );
      PC( 56 );
      return 13;
    case IM2:
      pushpc();
      IFF1( false );
      IFF2( false );
      int t = (I()<<8) | 0x00ff;
      PC( peekw(t) );
      return 19;
    }

    return 0;
  }

  /** EX AF,AF' */
  void ex_af_af() {
    int   t;
    t = AF(); AF( _AF_ ); _AF_ = t;
  }

  /** Quick Increment : no flags */
  private inline int inc16( int a ) { return (a + 1) & 0xffff; }
  private inline int qinc8( int a ) { return (a + 1) & 0xff; }

  /** Quick Decrement : no flags */
  private inline int dec16( int a ) { return (a - 1) & 0xffff; }
  private inline int qdec8( int a ) { return (a - 1) & 0xff; }

  /** Bit toggling */
  private inline int res( int bit, int val ) { return val & ~bit; }
  private inline int set( int bit, int val ) { return val |  bit; }

  private  int in_bc() {
    int        ans = inb( BC() );

    setZ( ans == 0 );
    setS( (ans & F_S)!=0 );
    set3( (ans & F_3)!=0 );
    set5( (ans & F_5)!=0 );
    setPV( parity[ ans ] );
    setN( false );
    setH( false );

    return ans;
  }

  /** Add with carry - alters all flags (CHECKED) */
  private  void
  adc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a + b + c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f) + c) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Add - alters all flags (CHECKED) */
  private  void
  add_a( int b )
  {
    int a    = A();
    int wans = a + b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f)) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Subtract with carry - alters all flags (CHECKED) */
  private  void
  sbc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a - b - c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f) - c) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Subtract - alters all flags (CHECKED) */
  private  void
  sub_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Rotate Left - alters H N C 3 5 flags (CHECKED) */
  private  void
  rlc_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right - alters H N C 3 5 flags (CHECKED) */
  private  void
  rrc_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Left through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rl_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }

    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rr_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Compare - alters all flags (CHECKED) */
  private  void
  cp_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (b & F_3)   != 0 );
    set5( (b & F_5)   != 0 );
    setN( true );
    setZ( ans == 0 );
    setC( (wans & 0x100)!=0 );
    setH( (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
  }

  /** Bitwise and - alters all flags (CHECKED) */
  private  void
  and_a( int b )
  {
    int ans = A() & b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise or - alters all flags (CHECKED) */
  private  void
  or_a( int b )
  {
    int ans = A() | b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise exclusive or - alters all flags (CHECKED) */
  private  void
  xor_a( int b )
  {
    int ans = (A() ^ b) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Negate (Two's complement) - alters all flags (CHECKED) */
  private  void
  neg_a()
  {
    int t = A();

    A( 0 );
    sub_a(t);
  }

  /** One's complement - alters N H 3 5 flags (CHECKED) */
  private  void
  cpl_a()
  {
    int ans = A() ^ 0xff;

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setN( true );

    A( ans );
  }

  /** Decimal Adjust Accumulator - alters all flags (CHECKED) */
  private  void
  daa_a()
  {
    int        ans = A();
    int        incr = 0;
    int    carry = Cset();

    if ((Hset()) || ((ans & 0x0f) > 0x09)) {
      incr |= 0x06;
    }
    if (carry || (ans > 0x9f) || ((ans > 0x8f) && ((ans & 0x0f) > 0x09))) {
      incr |= 0x60;
    }
    if (ans > 0x99) {
      carry = true;
    }
    if (Nset()) {
      sub_a(incr);
    } else {
      add_a(incr);
    }

    ans = A();

    setC( carry );
    setPV( parity[ ans ] );
  }

  /** Load a with i - (NOT CHECKED) */
  private  void
  ld_a_i()
  {
    int ans = I();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Load a with r - (NOT CHECKED) */
  private  void
  ld_a_r()
  {
    int ans = R();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate right through a and (hl) - (NOT CHECKED) */
  private  void
  rrd_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t >> 4) | (ans << 4);
    ans = (ans & 0xf0) | (q & 0x0f);
    pokeb( HL(), t );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate left through a and (hl) - (NOT CHECKED) */
  private  void
  rld_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t << 4) | (ans & 0x0f);
    ans = (ans & 0xf0) | (q >> 4);
    pokeb( HL(), (t & 0xff) );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Test bit - alters all but C flag (CHECKED) */
  private  void
  bit( int b, int r )
  {
    int    bitSet = ((r & b) != 0);

    setN( false );
    setH( true );
    set3( (r & F_3) != 0 );
    set5( (r & F_5) != 0 );
    setS( (b == F_S) ? bitSet : false );
    setZ(  !bitSet );
    setPV( !bitSet );
  }

  /** Set carry flag - alters N H 3 5 C flags (CHECKED) */
  private  void
  scf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setH( false );
    setC( true );
  }

  /** Complement carry flag - alters N 3 5 C flags (CHECKED) */
  private  void
  ccf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setC( Cset() ? false : true );
  }

  /** Rotate left - alters all flags (CHECKED) */
  private  int
  rlc( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right - alters all flags (CHECKED) */
  private  int
  rrc( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate left through carry - alters all flags (CHECKED) */
  private  int
  rl( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right through carry - alters all flags (CHECKED) */
  private  int
  rr( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left Arithmetically - alters all flags (CHECKED) */
  private  int
  sla( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = (ans << 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left and Set - alters all flags (CHECKED) */
  private  int
  sls( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = ((ans << 1) | 0x01) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Arithmetically - alters all flags (CHECKED) */
  private  int
  sra( int ans )
  {
    int c = (ans & 0x01) != 0;
    ans = (ans >> 1) | (ans & 0x80);

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Logically - alters all flags (CHECKED) */
  private  int srl( int ans ) {
    int c = (ans & 0x01) != 0;
    ans = ans >> 1;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Decrement - alters all but C flag (CHECKED) */
  private  int dec8( int ans ) {
    int    pv = (ans == 0x80);
    int    h  = (((ans & 0x0f) - 1) & F_H) != 0;
    ans = (ans - 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( true );

    return(ans);
  }

  /** Increment - alters all but C flag (CHECKED) */
  private  int inc8( int ans ) {
    int    pv = (ans == 0x7f);
    int    h  = (((ans & 0x0f) + 1) & F_H) != 0;
    ans = (ans + 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int adc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a + b + c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff) + c) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add - (NOT CHECKED) */
  private  int add16( int a, int b ) {
    int lans = a + b;
    int ans  = lans & 0xffff;

    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setC( (lans & 0x10000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff)) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int sbc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a - b - c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) - (b & 0x0fff) - c) & 0x1000)!=0 );
    setN( true );

    return(ans);
  }

  /** EXX */
  void exx() {
    int t;

    t = HL();
    HL( _HL_ );
    _HL_ = t;

    t = DE();
    DE( _DE_ );
    _DE_ = t;

    t = BC();
    BC( _BC_ );
    _BC_ = t;
  }

  private  int execute_ed( int local_tstates ) {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case 0:  /* NOP */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:

    case 164:
    case 165:
    case 166:
    case 167:

    case 172:
    case 173:
    case 174:
    case 175:

    case 180:
    case 181:
    case 182:
    case 183:
    {
      return ( 8 );
    }

    /* IN r,(c) */
    case 64:  /* IN B,(c) */
    { B( in_bc() ); return ( 12 ); }
    case 72:  /* IN C,(c) */
    { C( in_bc() ); return ( 12 ); }
    case 80:  /* IN D,(c) */
    { D( in_bc() ); return ( 12 ); }
    case 88:  /* IN E,(c) */
    { E( in_bc() ); return ( 12 ); }
    case 96:  /* IN H,(c) */
    { H( in_bc() ); return ( 12 ); }
    case 104:  /* IN L,(c) */
    { L( in_bc() ); return ( 12 ); }
    case 112:  /* IN (c) */
    { in_bc(); return ( 12 ); }
    case 120:  /* IN A,(c) */
    { A( in_bc() ); return ( 12 ); }

    /* OUT (c),r */
    case 65:  /* OUT (c),B */
    { outb( BC(), B(), local_tstates ); return ( 12 ); }
    case 73:  /* OUT (c),C */
    { outb( BC(), C(), local_tstates ); return ( 12 ); }
    case 81:  /* OUT (c),D */
    { outb( BC(), D(), local_tstates ); return ( 12 ); }
    case 89:  /* OUT (c),E */
    { outb( BC(), E(), local_tstates ); return ( 12 ); }
    case 97:  /* OUT (c),H */
    { outb( BC(), H(), local_tstates ); return ( 12 ); }
    case 105:  /* OUT (c),L */
    { outb( BC(), L(), local_tstates ); return ( 12 ); }
    case 113:  /* OUT (c),0 */
    { outb( BC(), 0, local_tstates ); return ( 12 ); }
    case 121:  /* OUT (c),A */
    { outb( BC(), A(), local_tstates ); return ( 12 ); }

    /* SBC/ADC HL,ss */
    case 66:  /* SBC HL,BC */
    { HL( sbc16( HL(), BC() ) ); return ( 15 ); }
    case 74:  /* ADC HL,BC */
    { HL( adc16( HL(), BC() ) ); return ( 15 ); }
    case 82:  /* SBC HL,DE */
    { HL( sbc16( HL(), DE() ) ); return ( 15 ); }
    case 90:  /* ADC HL,DE */
    { HL( adc16( HL(), DE() ) ); return ( 15 ); }
    case 98:  /* SBC HL,HL */
    {
      int hl = HL();
      HL( sbc16( hl, hl ) );
      return ( 15 );
    }
    case 106:  /* ADC HL,HL */
    {
      int hl = HL();
      HL( adc16( hl, hl ) );
      return ( 15 );
    }
    case 114:  /* SBC HL,SP */
    { HL( sbc16( HL(), SP() ) ); return ( 15 ); }
    case 122:  /* ADC HL,SP */
    { HL( adc16( HL(), SP() ) ); return ( 15 ); }

    /* LD (nn),ss, LD ss,(nn) */
    case 67:  /* LD (nn),BC */
    { pokew( nxtpcw(), BC() ); return ( 20 ); }
    case 75:  /* LD BC(),(nn) */
    { BC( peekw( nxtpcw() ) ); return ( 20 ); }
    case 83:  /* LD (nn),DE */
    { pokew( nxtpcw(), DE() ); return ( 20 ); }
    case 91:  /* LD DE,(nn) */
    { DE( peekw( nxtpcw() ) ); return ( 20 ); }
    case 99:  /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); return ( 20 ); }
    case 107:  /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); return ( 20 ); }
    case 115:  /* LD (nn),SP */
    { pokew( nxtpcw(), SP() ); return ( 20 ); }
    case 123:  /* LD SP,(nn) */
    { SP( peekw( nxtpcw() ) ); return ( 20 ); }

    /* NEG */
    case 68:  /* NEG */
    case 76:  /* NEG */
    case 84:  /* NEG */
    case 92:  /* NEG */
    case 100:  /* NEG */
    case 108:  /* NEG */
    case 116:  /* NEG */
    case 124:  /* NEG */
    { neg_a(); return ( 8 ); }

    /* RETn */
    case 69:  /* RETN */
    case 85:  /* RETN */
    case 101:  /* RETN */
    case 117:  /* RETN */
    {
      IFF1( IFF2() );
      poppc();
      return ( 14 );
    }
    case 77:  /* RETI */
    case 93:  /* RETI */
    case 109:  /* RETI */
    case 125:  /* RETI */
    {
      poppc();
      return ( 14 );
    }

    /* IM x */
    case 70:  /* IM 0 */
    case 78:  /* IM 0 */
    case 102:  /* IM 0 */
    case 110:  /* IM 0 */
    { IM( IM0 ); return ( 8 ); }
    case 86:  /* IM 1 */
    case 118:  /* IM 1 */
    { IM( IM1 ); return ( 8 ); }
    case 94:  /* IM 2 */
    case 126:  /* IM 2 */
    { IM( IM2 ); return ( 8 ); }

    /* LD A,s / LD s,A / RxD */
    case 71:  /* LD I,A */
    { I( A() ); return ( 9 ); }
    case 79:  /* LD R,A */
    { R( A() ); return ( 9 ); }
    case 87:  /* LD A,I */
    { ld_a_i(); return ( 9 ); }
    case 95:  /* LD A,R */
    { ld_a_r(); return ( 9 ); }
    case 103:  /* RRD */
    { rrd_a(); return ( 18 ); }
    case 111:  /* RLD */
    { rld_a(); return ( 18 ); }

    /* xxI */
    case 160:  /* LDI */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( inc16( DE() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 161:  /* CPI */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 162:  /* INI */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 163:  /* OUTI */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxD */
    case 168:  /* LDD */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( dec16( DE() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 169:  /* CPD */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 170:  /* IND */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 171:  /* OUTD */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxIR */
    case 176:  /* LDIR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH( -2 );
      do {
        pokeb(dest, peekb(from) );
        from  = inc16( from );
        dest  = inc16( dest );
        count = dec16( count );

        _local_tstates += ( 21 );
        REFRESH( 2 );
        if ( interruptTriggered( _local_tstates ) ) {
          break;
        }
      } while (count != 0);
      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 177:  /* CPIR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 178:  /* INIR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 179:  /* OTIR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    /* xxDR */
    case 184:  /* LDDR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH ( -2 );
      do {
        pokeb(dest, peekb(from));
        from  = dec16( from );
        dest  = dec16( dest );
        count = dec16( count );

        _local_tstates += ( 21 );
        REFRESH( 2 );
        if ( interruptTriggered( _local_tstates ) ) {
          break;
        }
      } while (count != 0);
      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 185:  /* CPDR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 186:  /* INDR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 187:  /* OTDR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    } // end switch

    // NOP
    return ( 8 );
  }

  private  int execute_cb() {
    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case   0: /* RLC B */
    { B( rlc( B() ) ); return ( 8 ); }
    case   1: /* RLC C */
    { C( rlc( C() ) ); return ( 8 ); }
    case   2: /* RLC D */
    { D( rlc( D() ) ); return ( 8 ); }
    case   3: /* RLC E */
    { E( rlc( E() ) ); return ( 8 ); }
    case   4: /* RLC H */
    { H( rlc( H() ) ); return ( 8 ); }
    case   5: /* RLC L */
    { L( rlc( L() ) ); return ( 8 ); }
    case   6: /* RLC (HL) */
    {
      int hl = HL();
      pokeb( hl, rlc( peekb( hl ) ) );
      return ( 15 );
    }
    case   7: /* RLC A */
    { A( rlc( A() ) ); return ( 8 ); }

    case   8: /* RRC B */
    { B( rrc( B() ) ); return ( 8 ); }
    case   9: /* RRC C */
    { C( rrc( C() ) ); return ( 8 ); }
    case  10: /* RRC D */
    { D( rrc( D() ) ); return ( 8 ); }
    case  11: /* RRC E */
    { E( rrc( E() ) ); return ( 8 ); }
    case  12: /* RRC H */
    { H( rrc( H() ) ); return ( 8 ); }
    case  13: /* RRC L */
    { L( rrc( L() ) ); return ( 8 ); }
    case  14: /* RRC (HL) */
    {
      int hl = HL();
      pokeb( hl, rrc( peekb( hl ) ) );
      return ( 15 );
    }
    case  15: /* RRC A */
    { A( rrc( A() ) ); return ( 8 ); }

    case  16: /* RL B */
    { B( rl( B() ) ); return ( 8 ); }
    case  17: /* RL C */
    { C( rl( C() ) ); return ( 8 ); }
    case  18: /* RL D */
    { D( rl( D() ) ); return ( 8 ); }
    case  19: /* RL E */
    { E( rl( E() ) ); return ( 8 ); }
    case  20: /* RL H */
    { H( rl( H() ) ); return ( 8 ); }
    case  21: /* RL L */
    { L( rl( L() ) ); return ( 8 ); }
    case  22: /* RL (HL) */
    {
      int hl = HL();
      pokeb( hl, rl( peekb( hl ) ) );
      return ( 15 );
    }
    case  23: /* RL A */
    { A( rl( A() ) ); return ( 8 ); }

    case  24: /* RR B */
    { B( rr( B() ) ); return ( 8 ); }
    case  25: /* RR C */
    { C( rr( C() ) ); return ( 8 ); }
    case  26: /* RR D */
    { D( rr( D() ) ); return ( 8 ); }
    case  27: /* RR E */
    { E( rr( E() ) ); return ( 8 ); }
    case  28: /* RR H */
    { H( rr( H() ) ); return ( 8 ); }
    case  29: /* RR L */
    { L( rr( L() ) ); return ( 8 ); }
    case  30: /* RR (HL) */
    {
      int hl = HL();
      pokeb( hl, rr( peekb( hl ) ) );
      return ( 15 );
    }
    case  31: /* RR A */
    { A( rr( A() ) ); return ( 8 ); }

    case  32: /* SLA B */
    { B( sla( B() ) ); return ( 8 ); }
    case  33: /* SLA C */
    { C( sla( C() ) ); return ( 8 ); }
    case  34: /* SLA D */
    { D( sla( D() ) ); return ( 8 ); }
    case  35: /* SLA E */
    { E( sla( E() ) ); return ( 8 ); }
    case  36: /* SLA H */
    { H( sla( H() ) ); return ( 8 ); }
    case  37: /* SLA L */
    { L( sla( L() ) ); return ( 8 ); }
    case  38: /* SLA (HL) */
    {
      int hl = HL();
      pokeb( hl, sla( peekb( hl ) ) );
      return ( 15 );
    }
    case  39: /* SLA A */
    { A( sla( A() ) ); return ( 8 ); }

    case  40: /* SRA B */
    { B( sra( B() ) ); return ( 8 ); }
    case  41: /* SRA C */
    { C( sra( C() ) ); return ( 8 ); }
    case  42: /* SRA D */
    { D( sra( D() ) ); return ( 8 ); }
    case  43: /* SRA E */
    { E( sra( E() ) ); return ( 8 ); }
    case  44: /* SRA H */
    { H( sra( H() ) ); return ( 8 ); }
    case  45: /* SRA L */
    { L( sra( L() ) ); return ( 8 ); }
    case  46: /* SRA (HL) */
    {
      int hl = HL();
      pokeb( hl, sra( peekb( hl ) ) );
      return ( 15 );
    }
    case  47: /* SRA A */
    { A( sra( A() ) ); return ( 8 ); }

    case  48: /* SLS B */
    { B( sls( B() ) ); return ( 8 ); }
    case  49: /* SLS C */
    { C( sls( C() ) ); return ( 8 ); }
    case  50: /* SLS D */
    { D( sls( D() ) ); return ( 8 ); }
    case  51: /* SLS E */
    { E( sls( E() ) ); return ( 8 ); }
    case  52: /* SLS H */
    { H( sls( H() ) ); return ( 8 ); }
    case  53: /* SLS L */
    { L( sls( L() ) ); return ( 8 ); }
    case  54: /* SLS (HL) */
    {
      int hl = HL();
      pokeb( hl, sls( peekb( hl ) ) );
      return ( 15 );
    }
    case  55: /* SLS A */
    { A( sls( A() ) ); return ( 8 ); }

    case  56: /* SRL B */
    { B( srl( B() ) ); return ( 8 ); }
    case  57: /* SRL C */
    { C( srl( C() ) ); return ( 8 ); }
    case  58: /* SRL D */
    { D( srl( D() ) ); return ( 8 ); }
    case  59: /* SRL E */
    { E( srl( E() ) ); return ( 8 ); }
    case  60: /* SRL H */
    { H( srl( H() ) ); return ( 8 ); }
    case  61: /* SRL L */
    { L( srl( L() ) ); return ( 8 ); }
    case  62: /* SRL (HL) */
    {
      int hl = HL();
      pokeb( hl, srl( peekb( hl ) ) );
      return ( 15 );
    }
    case  63: /* SRL A */
    { A( srl( A() ) ); return ( 8 ); }

    case  64: /* BIT 0,B */
    { bit( 0x01, B() ); return ( 8 ); }
    case  65: /* BIT 0,C */
    { bit( 0x01, C() ); return ( 8 ); }
    case  66: /* BIT 0,D */
    { bit( 0x01, D() ); return ( 8 ); }
    case  67: /* BIT 0,E */
    { bit( 0x01, E() ); return ( 8 ); }
    case  68: /* BIT 0,H */
    { bit( 0x01, H() ); return ( 8 ); }
    case  69: /* BIT 0,L */
    { bit( 0x01, L() ); return ( 8 ); }
    case  70: /* BIT 0,(HL) */
    { bit( 0x01, peekb( HL() ) ); return ( 12 ); }
    case  71: /* BIT 0,A */
    { bit( 0x01, A() ); return ( 8 ); }

    case  72: /* BIT 1,B */
    { bit( 0x02, B() ); return ( 8 ); }
    case  73: /* BIT 1,C */
    { bit( 0x02, C() ); return ( 8 ); }
    case  74: /* BIT 1,D */
    { bit( 0x02, D() ); return ( 8 ); }
    case  75: /* BIT 1,E */
    { bit( 0x02, E() ); return ( 8 ); }
    case  76: /* BIT 1,H */
    { bit( 0x02, H() ); return ( 8 ); }
    case  77: /* BIT 1,L */
    { bit( 0x02, L() ); return ( 8 ); }
    case  78: /* BIT 1,(HL) */
    { bit( 0x02, peekb( HL() ) ); return ( 12 ); }
    case  79: /* BIT 1,A */
    { bit( 0x02, A() ); return ( 8 ); }

    case  80: /* BIT 2,B */
    { bit( 0x04, B() ); return ( 8 ); }
    case  81: /* BIT 2,C */
    { bit( 0x04, C() ); return ( 8 ); }
    case  82: /* BIT 2,D */
    { bit( 0x04, D() ); return ( 8 ); }
    case  83: /* BIT 2,E */
    { bit( 0x04, E() ); return ( 8 ); }
    case  84: /* BIT 2,H */
    { bit( 0x04, H() ); return ( 8 ); }
    case  85: /* BIT 2,L */
    { bit( 0x04, L() ); return ( 8 ); }
    case  86: /* BIT 2,(HL) */
    { bit( 0x04, peekb( HL() ) ); return ( 12 ); }
    case  87: /* BIT 2,A */
    { bit( 0x04, A() ); return ( 8 ); }

    case  88: /* BIT 3,B */
    { bit( 0x08, B() ); return ( 8 ); }
    case  89: /* BIT 3,C */
    { bit( 0x08, C() ); return ( 8 ); }
    case  90: /* BIT 3,D */
    { bit( 0x08, D() ); return ( 8 ); }
    case  91: /* BIT 3,E */
    { bit( 0x08, E() ); return ( 8 ); }
    case  92: /* BIT 3,H */
    { bit( 0x08, H() ); return ( 8 ); }
    case  93: /* BIT 3,L */
    { bit( 0x08, L() ); return ( 8 ); }
    case  94: /* BIT 3,(HL) */
    { bit( 0x08, peekb( HL() ) ); return ( 12 ); }
    case  95: /* BIT 3,A */
    { bit( 0x08, A() ); return ( 8 ); }

    case  96: /* BIT 4,B */
    { bit( 0x10, B() ); return ( 8 ); }
    case  97: /* BIT 4,C */
    { bit( 0x10, C() ); return ( 8 ); }
    case  98: /* BIT 4,D */
    { bit( 0x10, D() ); return ( 8 ); }
    case  99: /* BIT 4,E */
    { bit( 0x10, E() ); return ( 8 ); }
    case 100: /* BIT 4,H */
    { bit( 0x10, H() ); return ( 8 ); }
    case 101: /* BIT 4,L */
    { bit( 0x10, L() ); return ( 8 ); }
    case 102: /* BIT 4,(HL) */
    { bit( 0x10, peekb( HL() ) ); return ( 12 ); }
    case 103: /* BIT 4,A */
    { bit( 0x10, A() ); return ( 8 ); }

    case 104: /* BIT 5,B */
    { bit( 0x20, B() ); return ( 8 ); }
    case 105: /* BIT 5,C */
    { bit( 0x20, C() ); return ( 8 ); }
    case 106: /* BIT 5,D */
    { bit( 0x20, D() ); return ( 8 ); }
    case 107: /* BIT 5,E */
    { bit( 0x20, E() ); return ( 8 ); }
    case 108: /* BIT 5,H */
    { bit( 0x20, H() ); return ( 8 ); }
    case 109: /* BIT 5,L */
    { bit( 0x20, L() ); return ( 8 ); }
    case 110: /* BIT 5,(HL) */
    { bit( 0x20, peekb( HL() ) ); return ( 12 ); }
    case 111: /* BIT 5,A */
    { bit( 0x20, A() ); return ( 8 ); }

    case 112: /* BIT 6,B */
    { bit( 0x40, B() ); return ( 8 ); }
    case 113: /* BIT 6,C */
    { bit( 0x40, C() ); return ( 8 ); }
    case 114: /* BIT 6,D */
    { bit( 0x40, D() ); return ( 8 ); }
    case 115: /* BIT 6,E */
    { bit( 0x40, E() ); return ( 8 ); }
    case 116: /* BIT 6,H */
    { bit( 0x40, H() ); return ( 8 ); }
    case 117: /* BIT 6,L */
    { bit( 0x40, L() ); return ( 8 ); }
    case 118: /* BIT 6,(HL) */
    { bit( 0x40, peekb( HL() ) ); return ( 12 ); }
    case 119: /* BIT 6,A */
    { bit( 0x40, A() ); return ( 8 ); }

    case 120: /* BIT 7,B */
    { bit( 0x80, B() ); return ( 8 ); }
    case 121: /* BIT 7,C */
    { bit( 0x80, C() ); return ( 8 ); }
    case 122: /* BIT 7,D */
    { bit( 0x80, D() ); return ( 8 ); }
    case 123: /* BIT 7,E */
    { bit( 0x80, E() ); return ( 8 ); }
    case 124: /* BIT 7,H */
    { bit( 0x80, H() ); return ( 8 ); }
    case 125: /* BIT 7,L */
    { bit( 0x80, L() ); return ( 8 ); }
    case 126: /* BIT 7,(HL) */
    { bit( 0x80, peekb( HL() ) ); return ( 12 ); }
    case 127: /* BIT 7,A */
    { bit( 0x80, A() ); return ( 8 ); }

    case 128: /* RES 0,B */
    { B( res( 0x01, B() ) ); return ( 8 ); }
    case 129: /* RES 0,C */
    { C( res( 0x01, C() ) ); return ( 8 ); }
    case 130: /* RES 0,D */
    { D( res( 0x01, D() ) ); return ( 8 ); }
    case 131: /* RES 0,E */
    { E( res( 0x01, E() ) ); return ( 8 ); }
    case 132: /* RES 0,H */
    { H( res( 0x01, H() ) ); return ( 8 ); }
    case 133: /* RES 0,L */
    { L( res( 0x01, L() ) ); return ( 8 ); }
    case 134: /* RES 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 135: /* RES 0,A */
    { A( res( 0x01, A() ) ); return ( 8 ); }

    case 136: /* RES 1,B */
    { B( res( 0x02, B() ) ); return ( 8 ); }
    case 137: /* RES 1,C */
    { C( res( 0x02, C() ) ); return ( 8 ); }
    case 138: /* RES 1,D */
    { D( res( 0x02, D() ) ); return ( 8 ); }
    case 139: /* RES 1,E */
    { E( res( 0x02, E() ) ); return ( 8 ); }
    case 140: /* RES 1,H */
    { H( res( 0x02, H() ) ); return ( 8 ); }
    case 141: /* RES 1,L */
    { L( res( 0x02, L() ) ); return ( 8 ); }
    case 142: /* RES 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 143: /* RES 1,A */
    { A( res( 0x02, A() ) ); return ( 8 ); }

    case 144: /* RES 2,B */
    { B( res( 0x04, B() ) ); return ( 8 ); }
    case 145: /* RES 2,C */
    { C( res( 0x04, C() ) ); return ( 8 ); }
    case 146: /* RES 2,D */
    { D( res( 0x04, D() ) ); return ( 8 ); }
    case 147: /* RES 2,E */
    { E( res( 0x04, E() ) ); return ( 8 ); }
    case 148: /* RES 2,H */
    { H( res( 0x04, H() ) ); return ( 8 ); }
    case 149: /* RES 2,L */
    { L( res( 0x04, L() ) ); return ( 8 ); }
    case 150: /* RES 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 151: /* RES 2,A */
    { A( res( 0x04, A() ) ); return ( 8 ); }

    case 152: /* RES 3,B */
    { B( res( 0x08, B() ) ); return ( 8 ); }
    case 153: /* RES 3,C */
    { C( res( 0x08, C() ) ); return ( 8 ); }
    case 154: /* RES 3,D */
    { D( res( 0x08, D() ) ); return ( 8 ); }
    case 155: /* RES 3,E */
    { E( res( 0x08, E() ) ); return ( 8 ); }
    case 156: /* RES 3,H */
    { H( res( 0x08, H() ) ); return ( 8 ); }
    case 157: /* RES 3,L */
    { L( res( 0x08, L() ) ); return ( 8 ); }
    case 158: /* RES 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 159: /* RES 3,A */
    { A( res( 0x08, A() ) ); return ( 8 ); }

    case 160: /* RES 4,B */
    { B( res( 0x10, B() ) ); return ( 8 ); }
    case 161: /* RES 4,C */
    { C( res( 0x10, C() ) ); return ( 8 ); }
    case 162: /* RES 4,D */
    { D( res( 0x10, D() ) ); return ( 8 ); }
    case 163: /* RES 4,E */
    { E( res( 0x10, E() ) ); return ( 8 ); }
    case 164: /* RES 4,H */
    { H( res( 0x10, H() ) ); return ( 8 ); }
    case 165: /* RES 4,L */
    { L( res( 0x10, L() ) ); return ( 8 ); }
    case 166: /* RES 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 167: /* RES 4,A */
    { A( res( 0x10, A() ) ); return ( 8 ); }

    case 168: /* RES 5,B */
    { B( res( 0x20, B() ) ); return ( 8 ); }
    case 169: /* RES 5,C */
    { C( res( 0x20, C() ) ); return ( 8 ); }
    case 170: /* RES 5,D */
    { D( res( 0x20, D() ) ); return ( 8 ); }
    case 171: /* RES 5,E */
    { E( res( 0x20, E() ) ); return ( 8 ); }
    case 172: /* RES 5,H */
    { H( res( 0x20, H() ) ); return ( 8 ); }
    case 173: /* RES 5,L */
    { L( res( 0x20, L() ) ); return ( 8 ); }
    case 174: /* RES 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 175: /* RES 5,A */
    { A( res( 0x20, A() ) ); return ( 8 ); }

    case 176: /* RES 6,B */
    { B( res( 0x40, B() ) ); return ( 8 ); }
    case 177: /* RES 6,C */
    { C( res( 0x40, C() ) ); return ( 8 ); }
    case 178: /* RES 6,D */
    { D( res( 0x40, D() ) ); return ( 8 ); }
    case 179: /* RES 6,E */
    { E( res( 0x40, E() ) ); return ( 8 ); }
    case 180: /* RES 6,H */
    { H( res( 0x40, H() ) ); return ( 8 ); }
    case 181: /* RES 6,L */
    { L( res( 0x40, L() ) ); return ( 8 ); }
    case 182: /* RES 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 183: /* RES 6,A */
    { A( res( 0x40, A() ) ); return ( 8 ); }

    case 184: /* RES 7,B */
    { B( res( 0x80, B() ) ); return ( 8 ); }
    case 185: /* RES 7,C */
    { C( res( 0x80, C() ) ); return ( 8 ); }
    case 186: /* RES 7,D */
    { D( res( 0x80, D() ) ); return ( 8 ); }
    case 187: /* RES 7,E */
    { E( res( 0x80, E() ) ); return ( 8 ); }
    case 188: /* RES 7,H */
    { H( res( 0x80, H() ) ); return ( 8 ); }
    case 189: /* RES 7,L */
    { L( res( 0x80, L() ) ); return ( 8 ); }
    case 190: /* RES 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 191: /* RES 7,A */
    { A( res( 0x80, A() ) ); return ( 8 ); }

    case 192: /* SET 0,B */
    { B( set( 0x01, B() ) ); return ( 8 ); }
    case 193: /* SET 0,C */
    { C( set( 0x01, C() ) ); return ( 8 ); }
    case 194: /* SET 0,D */
    { D( set( 0x01, D() ) ); return ( 8 ); }
    case 195: /* SET 0,E */
    { E( set( 0x01, E() ) ); return ( 8 ); }
    case 196: /* SET 0,H */
    { H( set( 0x01, H() ) ); return ( 8 ); }
    case 197: /* SET 0,L */
    { L( set( 0x01, L() ) ); return ( 8 ); }
    case 198: /* SET 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 199: /* SET 0,A */
    { A( set( 0x01, A() ) ); return ( 8 ); }

    case 200: /* SET 1,B */
    { B( set( 0x02, B() ) ); return ( 8 ); }
    case 201: /* SET 1,C */
    { C( set( 0x02, C() ) ); return ( 8 ); }
    case 202: /* SET 1,D */
    { D( set( 0x02, D() ) ); return ( 8 ); }
    case 203: /* SET 1,E */
    { E( set( 0x02, E() ) ); return ( 8 ); }
    case 204: /* SET 1,H */
    { H( set( 0x02, H() ) ); return ( 8 ); }
    case 205: /* SET 1,L */
    { L( set( 0x02, L() ) ); return ( 8 ); }
    case 206: /* SET 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 207: /* SET 1,A */
    { A( set( 0x02, A() ) ); return ( 8 ); }

    case 208: /* SET 2,B */
    { B( set( 0x04, B() ) ); return ( 8 ); }
    case 209: /* SET 2,C */
    { C( set( 0x04, C() ) ); return ( 8 ); }
    case 210: /* SET 2,D */
    { D( set( 0x04, D() ) ); return ( 8 ); }
    case 211: /* SET 2,E */
    { E( set( 0x04, E() ) ); return ( 8 ); }
    case 212: /* SET 2,H */
    { H( set( 0x04, H() ) ); return ( 8 ); }
    case 213: /* SET 2,L */
    { L( set( 0x04, L() ) ); return ( 8 ); }
    case 214: /* SET 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 215: /* SET 2,A */
    { A( set( 0x04, A() ) ); return ( 8 ); }

    case 216: /* SET 3,B */
    { B( set( 0x08, B() ) ); return ( 8 ); }
    case 217: /* SET 3,C */
    { C( set( 0x08, C() ) ); return ( 8 ); }
    case 218: /* SET 3,D */
    { D( set( 0x08, D() ) ); return ( 8 ); }
    case 219: /* SET 3,E */
    { E( set( 0x08, E() ) ); return ( 8 ); }
    case 220: /* SET 3,H */
    { H( set( 0x08, H() ) ); return ( 8 ); }
    case 221: /* SET 3,L */
    { L( set( 0x08, L() ) ); return ( 8 ); }
    case 222: /* SET 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 223: /* SET 3,A */
    { A( set( 0x08, A() ) ); return ( 8 ); }

    case 224: /* SET 4,B */
    { B( set( 0x10, B() ) ); return ( 8 ); }
    case 225: /* SET 4,C */
    { C( set( 0x10, C() ) ); return ( 8 ); }
    case 226: /* SET 4,D */
    { D( set( 0x10, D() ) ); return ( 8 ); }
    case 227: /* SET 4,E */
    { E( set( 0x10, E() ) ); return ( 8 ); }
    case 228: /* SET 4,H */
    { H( set( 0x10, H() ) ); return ( 8 ); }
    case 229: /* SET 4,L */
    { L( set( 0x10, L() ) ); return ( 8 ); }
    case 230: /* SET 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 231: /* SET 4,A */
    { A( set( 0x10, A() ) ); return ( 8 ); }

    case 232: /* SET 5,B */
    { B( set( 0x20, B() ) ); return ( 8 ); }
    case 233: /* SET 5,C */
    { C( set( 0x20, C() ) ); return ( 8 ); }
    case 234: /* SET 5,D */
    { D( set( 0x20, D() ) ); return ( 8 ); }
    case 235: /* SET 5,E */
    { E( set( 0x20, E() ) ); return ( 8 ); }
    case 236: /* SET 5,H */
    { H( set( 0x20, H() ) ); return ( 8 ); }
    case 237: /* SET 5,L */
    { L( set( 0x20, L() ) ); return ( 8 ); }
    case 238: /* SET 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 239: /* SET 5,A */
    { A( set( 0x20, A() ) ); return ( 8 ); }

    case 240: /* SET 6,B */
    { B( set( 0x40, B() ) ); return ( 8 ); }
    case 241: /* SET 6,C */
    { C( set( 0x40, C() ) ); return ( 8 ); }
    case 242: /* SET 6,D */
    { D( set( 0x40, D() ) ); return ( 8 ); }
    case 243: /* SET 6,E */
    { E( set( 0x40, E() ) ); return ( 8 ); }
    case 244: /* SET 6,H */
    { H( set( 0x40, H() ) ); return ( 8 ); }
    case 245: /* SET 6,L */
    { L( set( 0x40, L() ) ); return ( 8 ); }
    case 246: /* SET 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 247: /* SET 6,A */
    { A( set( 0x40, A() ) ); return ( 8 ); }

    case 248: /* SET 7,B */
    { B( set( 0x80, B() ) ); return ( 8 ); }
    case 249: /* SET 7,C */
    { C( set( 0x80, C() ) ); return ( 8 ); }
    case 250: /* SET 7,D */
    { D( set( 0x80, D() ) ); return ( 8 ); }
    case 251: /* SET 7,E */
    { E( set( 0x80, E() ) ); return ( 8 ); }
    case 252: /* SET 7,H */
    { H( set( 0x80, H() ) ); return ( 8 ); }
    case 253: /* SET 7,L */
    { L( set( 0x80, L() ) ); return ( 8 ); }
    case 254: /* SET 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 255: /* SET 7,A */
    { A( set( 0x80, A() ) ); return ( 8 ); }

    } // end switch

    return 0;
  }

  private  void execute_id_cb(int op, int z) {

    switch ( op ) {

    case   0: /* RLC B */
    { B( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   1: /* RLC C */
    { C( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   2: /* RLC D */
    { D( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   3: /* RLC E */
    { E( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   4: /* RLC H */
    { H( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   5: /* RLC L */
    { L( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   6: /* RLC (HL) */
    { pokeb( z, rlc( peekb( z ) ) ); return; }
    case   7: /* RLC A */
    { A( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }

    case   8: /* RRC B */
    { B( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   9: /* RRC C */
    { C( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  10: /* RRC D */
    { D( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  11: /* RRC E */
    { E( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  12: /* RRC H */
    { H( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  13: /* RRC L */
    { L( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  14: /* RRC (HL) */
    { pokeb( z, rrc( peekb( z ) ) ); return; }
    case  15: /* RRC A */
    { A( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }

    case  16: /* RL B */
    { B( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  17: /* RL C */
    { C( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  18: /* RL D */
    { D( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  19: /* RL E */
    { E( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  20: /* RL H */
    { H( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  21: /* RL L */
    { L( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  22: /* RL (HL) */
    { pokeb( z, rl( peekb( z ) ) ); return; }
    case  23: /* RL A */
    { A( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  24: /* RR B */
    { B( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  25: /* RR C */
    { C( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  26: /* RR D */
    { D( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  27: /* RR E */
    { E( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  28: /* RR H */
    { H( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  29: /* RR L */
    { L( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  30: /* RR (HL) */
    { pokeb( z, rr( peekb( z ) ) ); return; }
    case  31: /* RR A */
    { A( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }

    case  32: /* SLA B */
    { B( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  33: /* SLA C */
    { C( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  34: /* SLA D */
    { D( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  35: /* SLA E */
    { E( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  36: /* SLA H */
    { H( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  37: /* SLA L */
    { L( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  38: /* SLA (HL) */
    { pokeb( z, sla( peekb( z ) ) ); return; }
    case  39: /* SLA A */
    { A( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }

    case  40: /* SRA B */
    { B( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  41: /* SRA C */
    { C( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  42: /* SRA D */
    { D( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  43: /* SRA E */
    { E( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  44: /* SRA H */
    { H( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  45: /* SRA L */
    { L( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  46: /* SRA (HL) */
    { pokeb( z, sra( peekb( z ) ) ); return; }
    case  47: /* SRA A */
    { A( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }

    case  48: /* SLS B */
    { B( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  49: /* SLS C */
    { C( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  50: /* SLS D */
    { D( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  51: /* SLS E */
    { E( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  52: /* SLS H */
    { H( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  53: /* SLS L */
    { L( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  54: /* SLS (HL) */
    { pokeb( z, sls( peekb( z ) ) ); return; }
    case  55: /* SLS A */
    { A( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }

    case  56: /* SRL B */
    { B( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  57: /* SRL C */
    { C( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  58: /* SRL D */
    { D( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  59: /* SRL E */
    { E( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  60: /* SRL H */
    { H( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  61: /* SRL L */
    { L( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  62: /* SRL (HL) */
    { pokeb( z, srl( peekb( z ) ) ); return; }
    case  63: /* SRL A */
    { A( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  64: /* BIT 0,B */
    case  65: /* BIT 0,B */
    case  66: /* BIT 0,B */
    case  67: /* BIT 0,B */
    case  68: /* BIT 0,B */
    case  69: /* BIT 0,B */
    case  70: /* BIT 0,B */
    case  71: /* BIT 0,B */
    { bit( 0x01, peekb( z ) ); return; }

    case  72: /* BIT 1,B */
    case  73: /* BIT 1,B */
    case  74: /* BIT 1,B */
    case  75: /* BIT 1,B */
    case  76: /* BIT 1,B */
    case  77: /* BIT 1,B */
    case  78: /* BIT 1,B */
    case  79: /* BIT 1,B */
    { bit( 0x02, peekb( z ) ); return; }

    case  80: /* BIT 2,B */
    case  81: /* BIT 2,B */
    case  82: /* BIT 2,B */
    case  83: /* BIT 2,B */
    case  84: /* BIT 2,B */
    case  85: /* BIT 2,B */
    case  86: /* BIT 2,B */
    case  87: /* BIT 2,B */
    { bit( 0x04, peekb( z ) ); return; }

    case  88: /* BIT 3,B */
    case  89: /* BIT 3,B */
    case  90: /* BIT 3,B */
    case  91: /* BIT 3,B */
    case  92: /* BIT 3,B */
    case  93: /* BIT 3,B */
    case  94: /* BIT 3,B */
    case  95: /* BIT 3,B */
    { bit( 0x08, peekb( z ) ); return; }

    case  96: /* BIT 4,B */
    case  97: /* BIT 4,B */
    case  98: /* BIT 4,B */
    case  99: /* BIT 4,B */
    case 100: /* BIT 4,B */
    case 101: /* BIT 4,B */
    case 102: /* BIT 4,B */
    case 103: /* BIT 4,B */
    { bit( 0x10, peekb( z ) ); return; }

    case 104: /* BIT 5,B */
    case 105: /* BIT 5,B */
    case 106: /* BIT 5,B */
    case 107: /* BIT 5,B */
    case 108: /* BIT 5,B */
    case 109: /* BIT 5,B */
    case 110: /* BIT 5,B */
    case 111: /* BIT 5,B */
    { bit( 0x20, peekb( z ) ); return; }

    case 112: /* BIT 6,B */
    case 113: /* BIT 6,B */
    case 114: /* BIT 6,B */
    case 115: /* BIT 6,B */
    case 116: /* BIT 6,B */
    case 117: /* BIT 6,B */
    case 118: /* BIT 6,B */
    case 119: /* BIT 6,B */
    { bit( 0x40, peekb( z ) ); return; }

    case 120: /* BIT 7,B */
    case 121: /* BIT 7,B */
    case 122: /* BIT 7,B */
    case 123: /* BIT 7,B */
    case 124: /* BIT 7,B */
    case 125: /* BIT 7,B */
    case 126: /* BIT 7,B */
    case 127: /* BIT 7,B */
    { bit( 0x80, peekb( z ) ); return; }

    case 128: /* RES 0,B */
    { B( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 129: /* RES 0,C */
    { C( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 130: /* RES 0,D */
    { D( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 131: /* RES 0,E */
    { E( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 132: /* RES 0,H */
    { H( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 133: /* RES 0,L */
    { L( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 134: /* RES 0,(HL) */
    { pokeb( z, res( 0x01, peekb( z ) ) ); return; }
    case 135: /* RES 0,A */
    { A( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 136: /* RES 1,B */
    { B( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 137: /* RES 1,C */
    { C( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 138: /* RES 1,D */
    { D( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 139: /* RES 1,E */
    { E( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 140: /* RES 1,H */
    { H( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 141: /* RES 1,L */
    { L( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 142: /* RES 1,(HL) */
    { pokeb( z, res( 0x02, peekb( z ) ) ); return; }
    case 143: /* RES 1,A */
    { A( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 144: /* RES 2,B */
    { B( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 145: /* RES 2,C */
    { C( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 146: /* RES 2,D */
    { D( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 147: /* RES 2,E */
    { E( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 148: /* RES 2,H */
    { H( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 149: /* RES 2,L */
    { L( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 150: /* RES 2,(HL) */
    { pokeb( z, res( 0x04, peekb( z ) ) ); return; }
    case 151: /* RES 2,A */
    { A( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 152: /* RES 3,B */
    { B( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 153: /* RES 3,C */
    { C( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 154: /* RES 3,D */
    { D( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 155: /* RES 3,E */
    { E( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 156: /* RES 3,H */
    { H( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 157: /* RES 3,L */
    { L( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 158: /* RES 3,(HL) */
    { pokeb( z, res( 0x08, peekb( z ) ) ); return; }
    case 159: /* RES 3,A */
    { A( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 160: /* RES 4,B */
    { B( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 161: /* RES 4,C */
    { C( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 162: /* RES 4,D */
    { D( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 163: /* RES 4,E */
    { E( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 164: /* RES 4,H */
    { H( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 165: /* RES 4,L */
    { L( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 166: /* RES 4,(HL) */
    { pokeb( z, res( 0x10, peekb( z ) ) ); return; }
    case 167: /* RES 4,A */
    { A( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 168: /* RES 5,B */
    { B( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 169: /* RES 5,C */
    { C( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 170: /* RES 5,D */
    { D( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 171: /* RES 5,E */
    { E( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 172: /* RES 5,H */
    { H( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 173: /* RES 5,L */
    { L( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 174: /* RES 5,(HL) */
    { pokeb( z, res( 0x20, peekb( z ) ) ); return; }
    case 175: /* RES 5,A */
    { A( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 176: /* RES 6,B */
    { B( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 177: /* RES 6,C */
    { C( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 178: /* RES 6,D */
    { D( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 179: /* RES 6,E */
    { E( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 180: /* RES 6,H */
    { H( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 181: /* RES 6,L */
    { L( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 182: /* RES 6,(HL) */
    { pokeb( z, res( 0x40, peekb( z ) ) ); return; }
    case 183: /* RES 6,A */
    { A( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 184: /* RES 7,B */
    { B( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 185: /* RES 7,C */
    { C( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 186: /* RES 7,D */
    { D( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 187: /* RES 7,E */
    { E( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 188: /* RES 7,H */
    { H( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 189: /* RES 7,L */
    { L( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 190: /* RES 7,(HL) */
    { pokeb( z, res( 0x80, peekb( z ) ) ); return; }
    case 191: /* RES 7,A */
    { A( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    case 192: /* SET 0,B */
    { B( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 193: /* SET 0,C */
    { C( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 194: /* SET 0,D */
    { D( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 195: /* SET 0,E */
    { E( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 196: /* SET 0,H */
    { H( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 197: /* SET 0,L */
    { L( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 198: /* SET 0,(HL) */
    { pokeb( z, set( 0x01, peekb( z ) ) ); return; }
    case 199: /* SET 0,A */
    { A( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 200: /* SET 1,B */
    { B( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 201: /* SET 1,C */
    { C( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 202: /* SET 1,D */
    { D( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 203: /* SET 1,E */
    { E( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 204: /* SET 1,H */
    { H( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 205: /* SET 1,L */
    { L( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 206: /* SET 1,(HL) */
    { pokeb( z, set( 0x02, peekb( z ) ) ); return; }
    case 207: /* SET 1,A */
    { A( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 208: /* SET 2,B */
    { B( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 209: /* SET 2,C */
    { C( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 210: /* SET 2,D */
    { D( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 211: /* SET 2,E */
    { E( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 212: /* SET 2,H */
    { H( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 213: /* SET 2,L */
    { L( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 214: /* SET 2,(HL) */
    { pokeb( z, set( 0x04, peekb( z ) ) ); return; }
    case 215: /* SET 2,A */
    { A( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 216: /* SET 3,B */
    { B( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 217: /* SET 3,C */
    { C( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 218: /* SET 3,D */
    { D( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 219: /* SET 3,E */
    { E( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 220: /* SET 3,H */
    { H( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 221: /* SET 3,L */
    { L( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 222: /* SET 3,(HL) */
    { pokeb( z, set( 0x08, peekb( z ) ) ); return; }
    case 223: /* SET 3,A */
    { A( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 224: /* SET 4,B */
    { B( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 225: /* SET 4,C */
    { C( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 226: /* SET 4,D */
    { D( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 227: /* SET 4,E */
    { E( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 228: /* SET 4,H */
    { H( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 229: /* SET 4,L */
    { L( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 230: /* SET 4,(HL) */
    { pokeb( z, set( 0x10, peekb( z ) ) ); return; }
    case 231: /* SET 4,A */
    { A( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 232: /* SET 5,B */
    { B( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 233: /* SET 5,C */
    { C( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 234: /* SET 5,D */
    { D( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 235: /* SET 5,E */
    { E( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 236: /* SET 5,H */
    { H( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 237: /* SET 5,L */
    { L( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 238: /* SET 5,(HL) */
    { pokeb( z, set( 0x20, peekb( z ) ) ); return; }
    case 239: /* SET 5,A */
    { A( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 240: /* SET 6,B */
    { B( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 241: /* SET 6,C */
    { C( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 242: /* SET 6,D */
    { D( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 243: /* SET 6,E */
    { E( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 244: /* SET 6,H */
    { H( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 245: /* SET 6,L */
    { L( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 246: /* SET 6,(HL) */
    { pokeb( z, set( 0x40, peekb( z ) ) ); return; }
    case 247: /* SET 6,A */
    { A( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 248: /* SET 7,B */
    { B( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 249: /* SET 7,C */
    { C( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 250: /* SET 7,D */
    { D( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 251: /* SET 7,E */
    { E( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 252: /* SET 7,H */
    { H( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 253: /* SET 7,L */
    { L( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 254: /* SET 7,(HL) */
    { pokeb( z, set( 0x80, peekb( z ) ) ); return; }
    case 255: /* SET 7,A */
    { A( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    } // end switch
  }

  private  int execute_id() {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case  0: /* NOP */
    case  1:
    case  2:
    case  3:
    case  4:
    case  5:
    case  6:
    case  7:
    case  8:

    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:

    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:

    case 39:
    case 40:

    case 47:
    case 48:
    case 49:
    case 50:
    case 51:

    case 55:
    case 56:

    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:

    case 71:
    case 72:
    case 73:
    case 74:
    case 75:

    case 79:
    case 80:
    case 81:
    case 82:
    case 83:

    case 87:
    case 88:
    case 89:
    case 90:
    case 91:

    case 95:

    case 120:
    case 121:
    case 122:
    case 123:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:

    case 135:
    case 136:
    case 137:
    case 138:
    case 139:

    case 143:
    case 144:
    case 145:
    case 146:
    case 147:

    case 151:
    case 152:
    case 153:
    case 154:
    case 155:

    case 159:
    case 160:
    case 161:
    case 162:
    case 163:

    case 167:
    case 168:
    case 169:
    case 170:
    case 171:

    case 175:
    case 176:
    case 177:
    case 178:
    case 179:

    case 183:
    case 184:
    case 185:
    case 186:
    case 187:

    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:

    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:

    case 226:

    case 228:

    case 230:
    case 231:
    case 232:

    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    {
      PC( dec16( PC() ) );
      REFRESH( -1 );
      return ( 4 );
    }

    case  9: /* ADD ID,BC */
    { ID( add16( ID(), BC() ) ); return ( 15 ); }
    case 25: /* ADD ID,DE */
    { ID( add16( ID(), DE() ) ); return ( 15 ); }
    case 41: /* ADD ID,ID */
    {
      int id = ID();
      ID( add16( id, id ) );
      return ( 15 );
    }
    case 57: /* ADD ID,SP */
    { ID( add16( ID(),SP() ) ); return ( 15 ); }

    case 33: /* LD ID,nn */
    { ID( nxtpcw() ); return ( 14 ); }
    case 34: /* LD (nn),ID */
    { pokew( nxtpcw(), ID() ); return ( 20 ); }
    case 42: /* LD ID,(nn) */
    { ID( peekw( nxtpcw() ) ); return ( 20 ); }
    case 35:/* INC ID */
    { ID( inc16( ID() ) ); return ( 10 ); }
    case 43:/* DEC ID */
    { ID( dec16( ID() ) ); return ( 10 ); }
    case 36:/* INC IDH */
    { IDH( inc8( IDH() ) ); return ( 8 ); }
    case 44:/* INC IDL */
    { IDL( inc8( IDL() ) ); return ( 8 ); }
    case 52:/* INC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, inc8( peekb(z) ) );
        return ( 23 );
    }
    case 37:/* DEC IDH */
    { IDH( dec8( IDH() ) ); return ( 8 ); }
    case 45:/* DEC IDL */
    { IDL( dec8( IDL() ) ); return ( 8 ); }
    case 53:/* DEC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, dec8( peekb(z) ) );
        return ( 23 );
    }

    case 38: /* LD IDH,n */
    { IDH( nxtpcb() ); return ( 11 ); }
    case 46: /* LD IDL,n */
    { IDL( nxtpcb() ); return ( 11 ); }
    case 54: /* LD (ID+d),n */
    { int z = ID_d(); pokeb(z,nxtpcb()); return ( 19 ); }

    case 68: /* LD B,IDH */
    { B( IDH() ); return ( 8 ); }
    case 69: /* LD B,IDL */
    { B( IDL() ); return ( 8 ); }
    case 70: /* LD B,(ID+d) */
    { B( peekb( ID_d() ) ); return ( 19 ); }

    case 76: /* LD C,IDH */
    { C( IDH() ); return ( 8 ); }
    case 77: /* LD C,IDL */
    { C( IDL() ); return ( 8 ); }
    case 78: /* LD C,(ID+d) */
    { C( peekb( ID_d() ) ); return ( 19 ); }

    case 84: /* LD D,IDH */
    { D( IDH() ); return ( 8 ); }
    case 85: /* LD D,IDL */
    { D( IDL() ); return ( 8 ); }
    case 86: /* LD D,(ID+d) */
    { D( peekb( ID_d() ) ); return ( 19 ); }

    case 92: /* LD E,IDH */
    { E( IDH() ); return ( 8 ); }
    case 93: /* LD E,IDL */
    { E( IDL() ); return ( 8 ); }
    case 94: /* LD E,(ID+d) */
    { E( peekb( ID_d() ) ); return ( 19 ); }

    case 96: /* LD IDH,B */
    { IDH( B() ); return ( 8 ); }
    case 97: /* LD IDH,C */
    { IDH( C() ); return ( 8 ); }
    case 98: /* LD IDH,D */
    { IDH( D() ); return ( 8 ); }
    case 99: /* LD IDH,E */
    { IDH( E() ); return ( 8 ); }
    case 100: /* LD IDH,IDH */
    { return ( 8 ); }
    case 101: /* LD IDH,IDL */
    { IDH( IDL() ); return ( 8 ); }
    case 102: /* LD H,(ID+d) */
    { H( peekb( ID_d() ) ); return ( 19 ); }
    case 103: /* LD IDH,A */
    { IDH( A() ); return ( 8 ); }

    case 104: /* LD IDL,B */
    { IDL( B() ); return ( 8 ); }
    case 105: /* LD IDL,C */
    { IDL( C() ); return ( 8 ); }
    case 106: /* LD IDL,D */
    { IDL( D() ); return ( 8 ); }
    case 107: /* LD IDL,E */
    { IDL( E() ); return ( 8 ); }
    case 108: /* LD IDL,IDH */
    { IDL( IDH() ); return ( 8 ); }
    case 109: /* LD IDL,IDL */
    { return ( 8 ); }
    case 110: /* LD L,(ID+d) */
    { L( peekb( ID_d() ) ); return ( 19 ); }
    case 111: /* LD IDL,A */
    { IDL( A() ); return ( 8 ); }

    case 112: /* LD (ID+d),B */
    { pokeb( ID_d(), B() ); return ( 19 ); }
    case 113: /* LD (ID+d),C */
    { pokeb( ID_d(), C() ); return ( 19 ); }
    case 114: /* LD (ID+d),D */
    { pokeb( ID_d(), D() ); return ( 19 ); }
    case 115: /* LD (ID+d),E */
    { pokeb( ID_d(), E() ); return ( 19 ); }
    case 116: /* LD (ID+d),H */
    { pokeb( ID_d(), H() ); return ( 19 ); }
    case 117: /* LD (ID+d),L */
    { pokeb( ID_d(), L() ); return ( 19 ); }
    case 119: /* LD (ID+d),A */
    { pokeb( ID_d(), A() ); return ( 19 ); }

    case 124: /* LD A,IDH */
    { A( IDH() ); return ( 8 ); }
    case 125: /* LD A,IDL */
    { A( IDL() ); return ( 8 ); }
    case 126: /* LD A,(ID+d) */
    { A( peekb( ID_d() ) ); return ( 19 ); }

    case 132: /* ADD A,IDH */
    { add_a(IDH()); return ( 8 ); }
    case 133: /* ADD A,IDL */
    { add_a(IDL()); return ( 8 ); }
    case 134: /* ADD A,(ID+d) */
    { add_a(peekb( ID_d() )); return ( 19 ); }

    case 140: /* ADC A,IDH */
    { adc_a(IDH()); return ( 8 ); }
    case 141: /* ADC A,IDL */
    { adc_a(IDL()); return ( 8 ); }
    case 142: /* ADC A,(ID+d) */
    { adc_a(peekb( ID_d() )); return ( 19 ); }

    case 148: /* SUB IDH */
    { sub_a(IDH()); return ( 8 ); }
    case 149: /* SUB IDL */
    { sub_a(IDL()); return ( 8 ); }
    case 150: /* SUB (ID+d) */
    { sub_a(peekb( ID_d() )); return ( 19 ); }

    case 156: /* SBC A,IDH */
    { sbc_a(IDH()); return ( 8 ); }
    case 157: /* SBC A,IDL */
    { sbc_a(IDL()); return ( 8 ); }
    case 158: /* SBC A,(ID+d) */
    { sbc_a(peekb( ID_d() )); return ( 19 ); }

    case 164: /* AND IDH */
    { and_a(IDH()); return ( 8 ); }
    case 165: /* AND IDL */
    { and_a(IDL()); return ( 8 ); }
    case 166: /* AND (ID+d) */
    { and_a(peekb( ID_d() )); return ( 19 ); }

    case 172: /* XOR IDH */
    { xor_a(IDH()); return ( 8 ); }
    case 173: /* XOR IDL */
    { xor_a(IDL()); return ( 8 ); }
    case 174: /* XOR (ID+d) */
    { xor_a(peekb( ID_d() )); return ( 19 ); }

    case 180: /* OR IDH */
    { or_a(IDH()); return ( 8 ); }
    case 181: /* OR IDL */
    { or_a(IDL()); return ( 8 ); }
    case 182: /* OR (ID+d) */
    { or_a(peekb( ID_d() )); return ( 19 ); }

    case 188: /* CP IDH */
    { cp_a(IDH()); return ( 8 ); }
    case 189: /* CP IDL */
    { cp_a(IDL()); return ( 8 ); }
    case 190: /* CP (ID+d) */
    { cp_a(peekb( ID_d() )); return ( 19 ); }

    case 225: /* POP ID */
    { ID( popw() ); return ( 14 ); }

    case 233: /* JP (ID) */
    { PC( ID() ); return ( 8 ); }

    case 249: /* LD SP,ID */
    { SP( ID() ); return ( 10 ); }

    case 203: /* prefix CB */
    {
      // Get index address (offset byte is first)
      int z = ID_d();
      // Opcode comes after offset byte
      int op = nxtpcb();
      execute_id_cb( op, z );
      // Bit instructions take 20 T states, rest 23
      return ( (( op & 0xc0 ) == 0x40) ? 20 : 23 );
    }

    case 227: /* EX (SP),ID */
    {
      int t = ID();
      int sp = SP();
      ID( peekw( sp ) );
      pokew( sp, t );
      return ( 23 );
    }

    case 229:    /* PUSH ID */
    { pushw( ID() ); return ( 15 ); }

    } // end switch

    return 0;
  }


  int global_tstates = -tstatesPerInterrupt;

  /** Z80 fetch/execute loop */
  void execute(float time) {
  
    const float timelimit=1.0 / 15;
    if(time>timelimit)
      time=timelimit; //avoid maxing cpu, slow down emulation speed instead

    int    local_tstates = global_tstates;

    int ticksLimit = local_tstates + round(time * clockSpeed * 1e6);

    //trace("delta: " + inttostr(time*1000));
    //trace("ticks: " + inttostr(round(time * clockSpeed * 1e6)));

    int lastticks;
    if(PROFILE)
      lastticks=GetTickCount();

    while ( local_tstates < ticksLimit ) {

    int instruction;

    if(PROFILE) {
      int now=GetTickCount();
      if(now-lastticks>15) {
        trace("Instruction " + intToStr(instruction) + " took " + inttostr(now-lastticks) + "ms");
      }
      lastticks=GetTickCount();
    }

    if ( interruptTriggered( local_tstates ) ) {
      int intTime=tstatesPerInterrupt - interrupt();
      local_tstates -= intTime;
      ticksLimit -= intTime;
    }


    if(DEBUGTRACE) {
      trace("pc: " + inttostr(_PC));
    }

    REFRESH( 1 );


    instruction=nxtpcb();
    switch ( instruction ) {

    case 0:    /* NOP */
    {
      local_tstates += ( 4 );
      break;
    }
    case 8:    /* EX AF,AF' */
    {
      ex_af_af();
      local_tstates += ( 4 );
      break;
    }
    case 16:    /* DJNZ dis */
    {
      int  b;

      B( b = qdec8( B() ) );
      if (b != 0) {
        int d =  getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 13 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 8 );
      }
      break;
    }
    case 24: /* JR dis */
    {
      int d = getSignedByte(nxtpcb());
      PC( (PC()+d)&0xffff );
      local_tstates += ( 12 );
      break;
    }
    /* JR cc,dis */
    case 32:    /* JR NZ,dis */
    {
      if (!Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 40:    /* JR Z,dis */
    {
      if ( Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 48:    /* JR NC,dis */
    {
      if (!Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 56:    /* JR C,dis */
    {
      if ( Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }

    /* LD rr,nn / ADD HL,rr */
    case 1:    /* LD BC(),nn */
    {
      BC( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 9:    /* ADD HL,BC */
     {
      HL( add16( HL(), BC() ) );
      local_tstates += ( 11 );
      break;
    }
    case 17:    /* LD DE,nn */
    {
      DE( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 25:    /* ADD HL,DE */
    {
      HL( add16( HL(), DE() ) );
      local_tstates += ( 11 );
      break;
    }
    case 33:    /* LD HL,nn */
    {
      HL( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 41:    /* ADD HL,HL */
    {
      int hl = HL();
      HL( add16( hl, hl ) );
      local_tstates += ( 11 );
      break;
    }
    case 49:    /* LD SP,nn */
    {
      SP( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 57:    /* ADD HL,SP */
    {
      HL( add16( HL(), SP() ) );
      local_tstates += ( 11 );
      break;
    }

    /* LD (**),A/A,(**) */
    case 2:    /* LD (BC),A */
    { pokeb( BC(), A() ); local_tstates += ( 7 ); break; }
    case 10:    /* LD A,(BC) */
    { A( peekb( BC() ) ); local_tstates += ( 7 ); break; }
    case 18:    /* LD (DE),A */
    { pokeb( DE(), A() ); local_tstates += ( 7 ); break; }
    case 26:    /* LD A,(DE) */
    { A( peekb( DE() ) ); local_tstates += ( 7 ); break; }
    case 34:    /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); local_tstates += ( 16 ); break; }
    case 42:    /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); local_tstates += ( 16 ); break; }
    case 50:    /* LD (nn),A */
    { pokeb( nxtpcw(), A() ); local_tstates += ( 13 ); break; }
    case 58:    /* LD A,(nn) */
    { A( peekb( nxtpcw() ) ); local_tstates += ( 13 ); break; }

    /* INC/DEC * */
    case 3:    /* INC BC */
    { BC( inc16( BC() ) ); local_tstates += ( 6 ); break; }
    case 11:    /* DEC BC */
    { BC( dec16( BC() ) ); local_tstates += ( 6 ); break; }
    case 19:    /* INC DE */
    { DE( inc16( DE() ) ); local_tstates += ( 6 ); break; }
    case 27:    /* DEC DE */
    { DE( dec16( DE() ) ); local_tstates += ( 6 ); break; }
    case 35:    /* INC HL */
    { HL( inc16( HL() ) ); local_tstates += ( 6 ); break; }
    case 43:    /* DEC HL */
    { HL( dec16( HL() ) ); local_tstates += ( 6 ); break; }
    case 51:    /* INC SP */
    { SP( inc16( SP() ) ); local_tstates += ( 6 ); break; }
    case 59:    /* DEC SP */
    { SP( dec16( SP() ) ); local_tstates += ( 6 ); break; }

    /* INC * */
    case 4:    /* INC B */
    { B( inc8( B() ) ); local_tstates += ( 4 ); break; }
    case 12:    /* INC C */
    { C( inc8( C() ) ); local_tstates += ( 4 ); break; }
    case 20:    /* INC D */
    { D( inc8( D() ) ); local_tstates += ( 4 ); break; }
    case 28:    /* INC E */
    { E( inc8( E() ) ); local_tstates += ( 4 ); break; }
    case 36:    /* INC H */
    { H( inc8( H() ) ); local_tstates += ( 4 ); break; }
    case 44:    /* INC L */
    { L( inc8( L() ) ); local_tstates += ( 4 ); break; }
    case 52:    /* INC (HL) */
    {
      int hl = HL();
      pokeb( hl, inc8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 60:    /* INC A() */
    { A( inc8( A() ) ); local_tstates += ( 4 ); break; }

    /* DEC * */
    case 5:    /* DEC B */
    { B( dec8( B() ) ); local_tstates += ( 4 ); break; }
    case 13:    /* DEC C */
    { C( dec8( C() ) ); local_tstates += ( 4 ); break; }
    case 21:    /* DEC D */
    { D( dec8( D() ) ); local_tstates += ( 4 ); break; }
    case 29:    /* DEC E */
    { E( dec8( E() ) ); local_tstates += ( 4 ); break; }
    case 37:    /* DEC H */
    { H( dec8( H() ) ); local_tstates += ( 4 ); break; }
    case 45:    /* DEC L */
    { L( dec8( L() ) ); local_tstates += ( 4 ); break; }
    case 53:    /* DEC (HL) */
    {
      int hl = HL();
      pokeb( hl, dec8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 61:    /* DEC A() */
    { A( dec8( A() ) ); local_tstates += ( 4 ); break; }

    /* LD *,N */
    case 6:    /* LD B,n */
    { B( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 14:    /* LD C,n */
    { C( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 22:    /* LD D,n */
    { D( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 30:    /* LD E,n */
    { E( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 38:    /* LD H,n */
    { H( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 46:    /* LD L,n */
    { L( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 54:    /* LD (HL),n */
    {
      pokeb( HL(), nxtpcb() );
      local_tstates += ( 10 );
      break;
    }
    case 62:    /* LD A,n */
    { A( nxtpcb() ); local_tstates += ( 7 ); break; }

    /* R**A */
    case 7: /* RLCA */
    { rlc_a(); local_tstates += ( 4 ); break; }
    case 15: /* RRCA */
    { rrc_a(); local_tstates += ( 4 ); break; }
    case 23: /* RLA */
    { rl_a(); local_tstates += ( 4 ); break; }
    case 31: /* RRA */
    { rr_a(); local_tstates += ( 4 ); break; }
    case 39: /* DAA */
    { daa_a(); local_tstates += ( 4 ); break; }
    case 47: /* CPL */
    { cpl_a(); local_tstates += ( 4 ); break; }
    case 55: /* SCF */
    { scf(); local_tstates += ( 4 ); break; }
    case 63: /* CCF */
    { ccf(); local_tstates += ( 4 ); break; }

    /* LD B,* */
    case 64:    /* LD B,B */
    { local_tstates += ( 4 ); break; }
    case 65:    /* LD B,C */
    { B( C() ); local_tstates += ( 4 ); break; }
    case 66:    /* LD B,D */
    { B( D() ); local_tstates += ( 4 ); break; }
    case 67:    /* LD B,E */
    { B( E() ); local_tstates += ( 4 ); break; }
    case 68:    /* LD B,H */
    { B( H() ); local_tstates += ( 4 ); break; }
    case 69:    /* LD B,L */
    { B( L() ); local_tstates += ( 4 ); break; }
    case 70:    /* LD B,(HL) */
    { B( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 71:    /* LD B,A */
    { B( A() ); local_tstates += ( 4 ); break; }

    /* LD C,* */
    case 72:    /* LD C,B */
    { C( B() ); local_tstates += ( 4 ); break; }
    case 73:    /* LD C,C */
    { local_tstates += ( 4 ); break; }
    case 74:    /* LD C,D */
    { C( D() ); local_tstates += ( 4 ); break; }
    case 75:    /* LD C,E */
    { C( E() ); local_tstates += ( 4 ); break; }
    case 76:    /* LD C,H */
    { C( H() ); local_tstates += ( 4 ); break; }
    case 77:    /* LD C,L */
    { C( L() ); local_tstates += ( 4 ); break; }
    case 78:    /* LD C,(HL) */
    { C( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 79:    /* LD C,A */
    { C( A() ); local_tstates += ( 4 ); break; }

    /* LD D,* */
    case 80:    /* LD D,B */
    { D( B() ); local_tstates += ( 4 ); break; }
    case 81:    /* LD D,C */
    { D( C() ); local_tstates += ( 4 ); break; }
    case 82:    /* LD D,D */
    { local_tstates += ( 4 ); break; }
    case 83:    /* LD D,E */
    { D( E() ); local_tstates += ( 4 ); break; }
    case 84:    /* LD D,H */
    { D( H() ); local_tstates += ( 4 ); break; }
    case 85:    /* LD D,L */
    { D( L() ); local_tstates += ( 4 ); break; }
    case 86:    /* LD D,(HL) */
    { D( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 87:    /* LD D,A */
    { D( A() ); local_tstates += ( 4 ); break; }

    /* LD E,* */
    case 88:    /* LD E,B */
    { E( B() ); local_tstates += ( 4 ); break; }
    case 89:    /* LD E,C */
    { E( C() ); local_tstates += ( 4 ); break; }
    case 90:    /* LD E,D */
    { E( D() ); local_tstates += ( 4 ); break; }
    case 91:    /* LD E,E */
    { local_tstates += ( 4 ); break; }
    case 92:    /* LD E,H */
    { E( H() ); local_tstates += ( 4 ); break; }
    case 93:    /* LD E,L */
    { E( L() ); local_tstates += ( 4 ); break; }
    case 94:    /* LD E,(HL) */
    { E( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 95:    /* LD E,A */
    { E( A() ); local_tstates += ( 4 ); break; }

    /* LD H,* */
    case 96:    /* LD H,B */
    { H( B() ); local_tstates += ( 4 ); break; }
    case 97:    /* LD H,C */
    { H( C() ); local_tstates += ( 4 ); break; }
    case 98:    /* LD H,D */
    { H( D() ); local_tstates += ( 4 ); break; }
    case 99:    /* LD H,E */
    { H( E() ); local_tstates += ( 4 ); break; }
    case 100: /* LD H,H */
    { local_tstates += ( 4 ); break; }
    case 101:    /* LD H,L */
    { H( L() ); local_tstates += ( 4 ); break; }
    case 102:    /* LD H,(HL) */
    { H( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 103:    /* LD H,A */
    { H( A() ); local_tstates += ( 4 ); break; }

    /* LD L,* */
    case 104:    /* LD L,B */
    { L( B() ); local_tstates += ( 4 ); break; }
    case 105:    /* LD L,C */
    { L( C() ); local_tstates += ( 4 ); break; }
    case 106:    /* LD L,D */
    { L( D() ); local_tstates += ( 4 ); break; }
    case 107:    /* LD L,E */
    { L( E() ); local_tstates += ( 4 ); break; }
    case 108:    /* LD L,H */
    { L( H() ); local_tstates += ( 4 ); break; }
    case 109:    /* LD L,L */
    { local_tstates += ( 4 ); break; }
    case 110:    /* LD L,(HL) */
    { L( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 111:    /* LD L,A */
    { L( A() ); local_tstates += ( 4 ); break; }

    /* LD (HL),* */
    case 112:    /* LD (HL),B */
    { pokeb( HL(), B() ); local_tstates += ( 7 ); break; }
    case 113:    /* LD (HL),C */
    { pokeb( HL(), C() ); local_tstates += ( 7 ); break; }
    case 114:    /* LD (HL),D */
    { pokeb( HL(), D() ); local_tstates += ( 7 ); break; }
    case 115:    /* LD (HL),E */
    { pokeb( HL(), E() ); local_tstates += ( 7 ); break; }
    case 116:    /* LD (HL),H */
    { pokeb( HL(), H() ); local_tstates += ( 7 ); break; }
    case 117:    /* LD (HL),L */
    { pokeb( HL(), L() ); local_tstates += ( 7 ); break; }
    case 118:    /* HALT */
    {
      int  haltsToInterrupt = (((-local_tstates-1) / 4)+1);
      local_tstates += (haltsToInterrupt*4);
      REFRESH( haltsToInterrupt-1 );
      break;
    }
    case 119:    /* LD (HL),A */
    { pokeb( HL(), A() ); local_tstates += ( 7 ); break; }

    /* LD A,* */
    case 120:    /* LD A,B */
    { A( B() ); local_tstates += ( 4 ); break; }
    case 121:    /* LD A,C */
    { A( C() ); local_tstates += ( 4 ); break; }
    case 122:    /* LD A,D */
    { A( D() ); local_tstates += ( 4 ); break; }
    case 123:    /* LD A,E */
    { A( E() ); local_tstates += ( 4 ); break; }
    case 124:    /* LD A,H */
    { A( H() ); local_tstates += ( 4 ); break; }
    case 125:    /* LD A,L */
    { A( L() ); local_tstates += ( 4 ); break; }
    case 126:    /* LD A,(HL) */
    { A( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 127:    /* LD A,A */
    { local_tstates += ( 4 ); break; }

    /* ADD A,* */
    case 128:    /* ADD A,B */
    { add_a( B() ); local_tstates += ( 4 ); break; }
    case 129:    /* ADD A,C */
    { add_a( C() ); local_tstates += ( 4 ); break; }
    case 130:    /* ADD A,D */
    { add_a( D() ); local_tstates += ( 4 ); break; }
    case 131:    /* ADD A,E */
    { add_a( E() ); local_tstates += ( 4 ); break; }
    case 132:    /* ADD A,H */
    { add_a( H() ); local_tstates += ( 4 ); break; }
    case 133:    /* ADD A,L */
    { add_a( L() ); local_tstates += ( 4 ); break; }
    case 134:    /* ADD A,(HL) */
    { add_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 135:    /* ADD A,A */
    { add_a( A() ); local_tstates += ( 4 ); break; }

    /* ADC A,* */
    case 136:    /* ADC A,B */
    { adc_a( B() ); local_tstates += ( 4 ); break; }
    case 137:    /* ADC A,C */
    { adc_a( C() ); local_tstates += ( 4 ); break; }
    case 138:    /* ADC A,D */
    { adc_a( D() ); local_tstates += ( 4 ); break; }
    case 139:    /* ADC A,E */
    { adc_a( E() ); local_tstates += ( 4 ); break; }
    case 140:    /* ADC A,H */
    { adc_a( H() ); local_tstates += ( 4 ); break; }
    case 141:    /* ADC A,L */
    { adc_a( L() ); local_tstates += ( 4 ); break; }
    case 142:    /* ADC A,(HL) */
    { adc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 143:    /* ADC A,A */
    { adc_a( A() ); local_tstates += ( 4 ); break; }

    /* SUB * */
    case 144:    /* SUB B */
    { sub_a( B() ); local_tstates += ( 4 ); break; }
    case 145:    /* SUB C */
    { sub_a( C() ); local_tstates += ( 4 ); break; }
    case 146:    /* SUB D */
    { sub_a( D() ); local_tstates += ( 4 ); break; }
    case 147:    /* SUB E */
    { sub_a( E() ); local_tstates += ( 4 ); break; }
    case 148:    /* SUB H */
    { sub_a( H() ); local_tstates += ( 4 ); break; }
    case 149:    /* SUB L */
    { sub_a( L() ); local_tstates += ( 4 ); break; }
    case 150:    /* SUB (HL) */
    { sub_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 151:    /* SUB A() */
    { sub_a( A() ); local_tstates += ( 4 ); break; }

    /* SBC A,* */
    case 152:    /* SBC A,B */
    { sbc_a( B() ); local_tstates += ( 4 ); break; }
    case 153:    /* SBC A,C */
    { sbc_a( C() ); local_tstates += ( 4 ); break; }
    case 154:    /* SBC A,D */
    { sbc_a( D() ); local_tstates += ( 4 ); break; }
    case 155:    /* SBC A,E */
    { sbc_a( E() ); local_tstates += ( 4 ); break; }
    case 156:    /* SBC A,H */
    { sbc_a( H() ); local_tstates += ( 4 ); break; }
    case 157:    /* SBC A,L */
    { sbc_a( L() ); local_tstates += ( 4 ); break; }
    case 158:    /* SBC A,(HL) */
    { sbc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 159:    /* SBC A,A */
    { sbc_a( A() ); local_tstates += ( 4 ); break; }

    /* AND * */
    case 160:    /* AND B */
    { and_a( B() ); local_tstates += ( 4 ); break; }
    case 161:    /* AND C */
    { and_a( C() ); local_tstates += ( 4 ); break; }
    case 162:    /* AND D */
    { and_a( D() ); local_tstates += ( 4 ); break; }
    case 163:    /* AND E */
    { and_a( E() ); local_tstates += ( 4 ); break; }
    case 164:    /* AND H */
    { and_a( H() ); local_tstates += ( 4 ); break; }
    case 165:    /* AND L */
    { and_a( L() ); local_tstates += ( 4 ); break; }
    case 166:    /* AND (HL) */
    { and_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 167:    /* AND A() */
    { and_a( A() ); local_tstates += ( 4 ); break; }

    /* XOR * */
    case 168:    /* XOR B */
    { xor_a( B() ); local_tstates += ( 4 ); break; }
    case 169:    /* XOR C */
    { xor_a( C() ); local_tstates += ( 4 ); break; }
    case 170:    /* XOR D */
    { xor_a( D() ); local_tstates += ( 4 ); break; }
    case 171:    /* XOR E */
    { xor_a( E() ); local_tstates += ( 4 ); break; }
    case 172:    /* XOR H */
    { xor_a( H() ); local_tstates += ( 4 ); break; }
    case 173:    /* XOR L */
    { xor_a( L() ); local_tstates += ( 4 ); break; }
    case 174:    /* XOR (HL) */
    { xor_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 175:    /* XOR A() */
    { xor_a( A() ); local_tstates += ( 4 ); break; }

    /* OR * */
    case 176:    /* OR B */
    { or_a( B() ); local_tstates += ( 4 ); break; }
    case 177:    /* OR C */
    { or_a( C() ); local_tstates += ( 4 ); break; }
    case 178:    /* OR D */
    { or_a( D() ); local_tstates += ( 4 ); break; }
    case 179:    /* OR E */
    { or_a( E() ); local_tstates += ( 4 ); break; }
    case 180:    /* OR H */
    { or_a( H() ); local_tstates += ( 4 ); break; }
    case 181:    /* OR L */
    { or_a( L() ); local_tstates += ( 4 ); break; }
    case 182:    /* OR (HL) */
    { or_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 183:    /* OR A() */
    { or_a( A() ); local_tstates += ( 4 ); break; }

    /* CP * */
    case 184:    /* CP B */
    { cp_a( B() ); local_tstates += ( 4 ); break; }
    case 185:    /* CP C */
    { cp_a( C() ); local_tstates += ( 4 ); break; }
    case 186:    /* CP D */
    { cp_a( D() ); local_tstates += ( 4 ); break; }
    case 187:    /* CP E */
    { cp_a( E() ); local_tstates += ( 4 ); break; }
    case 188:    /* CP H */
    { cp_a( H() ); local_tstates += ( 4 ); break; }
    case 189:    /* CP L */
    { cp_a( L() ); local_tstates += ( 4 ); break; }
    case 190:    /* CP (HL) */
    { cp_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 191:    /* CP A() */
    { cp_a( A() ); local_tstates += ( 4 ); break; }

    /* RET cc */
    case 192:    /* RET NZ */
    {
      if(!Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 200:    /* RET Z */
    {
      if(Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 208:    /* RET NC */
    {
      if(!Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 216:    /* RET C */
    {
      if(Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 224:    /* RET PO */
    {
      if(!PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 232:    /* RET PE */
    {
      if(PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 240:    /* RET P */
    {
      if(!Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 248:    /* RET M */
    {
      if(Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }

    /* POP,Various */
    case 193:    /* POP BC */
    { BC( popw() ); local_tstates += ( 10 ); break; }
    case 201: /* RET */
    { poppc(); local_tstates += ( 10 ); break; }
    case 209:    /* POP DE */
    { DE( popw() ); local_tstates += ( 10 ); break; }
    case 217:    /* EXX */
    {
      exx();
      local_tstates += ( 4 );
      break;
    }
    case 225:    /* POP HL */
    { HL( popw() ); local_tstates += ( 10 ); break; }
    case 233: /* JP (HL) */
    { PC( HL() ); local_tstates += ( 4 ); break; }
    case 241:    /* POP AF */
    { AF( popw() ); local_tstates += ( 10 ); break; }
    case 249:    /* LD SP,HL */
    { SP( HL() ); local_tstates += ( 6 ); break; }

    /* JP cc,nn */
    case 194:    /* JP NZ,nn */
    {
      if(!Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 202:    /* JP Z,nn */
    {
      if( Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 210:    /* JP NC,nn */
    {
      if(!Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 218:    /* JP C,nn */
    {
      if( Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 226:    /* JP PO,nn */
    {
      if(!PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 234:    /* JP PE,nn */
    {
      if( PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 242:    /* JP P,nn */
    {
      if(!Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 250:    /* JP M,nn */
    {
      if( Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }


    /* Various */
    case 195:    /* JP nn */
    { PC( peekw( PC() ) ); local_tstates += ( 10 ); break; }
    case 203:    /* prefix CB */
    { local_tstates += execute_cb(); break; }
    case 211:    /* OUT (n),A */
    {
      outb( nxtpcb(), A(), local_tstates );
      local_tstates += ( 11 );
      break;
    }
    case 219:    /* IN A,(n) */
    {
      A( inb((A() << 8) | nxtpcb()) );
      local_tstates += ( 11 );
      break;
    }
    case 227:    /* EX (SP),HL */
    {
      int t = HL();
      int sp = SP();
      HL( peekw( sp ) );
      pokew( sp, t );
      local_tstates += ( 19 );
      break;
    }
    case 235:    /* EX DE,HL */
    {
      int t = HL();
      HL( DE() );
      DE( t );
      local_tstates += ( 4 );
      break;
    }
    case 243:    /* DI */
    {
      IFF1( false );
      IFF2( false );
      local_tstates += ( 4 );
      break;
    }
    case 251:    /* EI */
    {
      IFF1( true );
      IFF2( true );
      local_tstates += ( 4 );
      break;
    }

    /* CALL cc,nn */
    case 196: /* CALL NZ,nn */
    {
      if( !Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 204: /* CALL Z,nn */
    {
      if( Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 212: /* CALL NC,nn */
    {
      if( !Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 220: /* CALL C,nn */
    {
      if( Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 228: /* CALL PO,nn */
    {
      if( !PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 236: /* CALL PE,nn */
    {
      if( PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 244: /* CALL P,nn */
    {
      if( !Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 252: /* CALL M,nn */
    {
      if( Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }

    /* PUSH,Various */
    case 197:    /* PUSH BC */
    { pushw( BC() ); local_tstates += ( 11 ); break; }
    case 205:    /* CALL nn */
    {
      int t = nxtpcw();
      pushpc();
      PC( t );
      local_tstates += ( 17 );
      break;
    }
    case 213:    /* PUSH DE */
    { pushw( DE() ); local_tstates += ( 11 ); break; }
    case 221:    /* prefix IX */
    {
      ID( IX() );
      local_tstates += execute_id();
      IX( ID() );
      break;
    }
    case 229:    /* PUSH HL */
    { pushw( HL() ); local_tstates += ( 11 ); break; }
    case 237:    /* prefix ED */
    { local_tstates += execute_ed( local_tstates ); break; }
    case 245:    /* PUSH AF */
    { pushw( AF() ); local_tstates += ( 11 ); break; }
    case 253:    /* prefix IY */
    {
      ID( IY() );
      local_tstates += execute_id();
      IY( ID() );
      break;
    }

    /* op A,N */
    case 198: /* ADD A,N */
    { add_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 206: /* ADC A,N */
    { adc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 214: /* SUB N */
    { sub_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 222: /* SBC A,N */
    { sbc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 230: /* AND N */
    { and_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 238: /* XOR N */
    { xor_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 246: /* OR N */
    { or_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 254: /* CP N */
    { cp_a(nxtpcb()); local_tstates += ( 7 ); break; }

    /* RST n */
    case 199:    /* RST 0 */
    { pushpc(); PC( 0 ); local_tstates += ( 11 ); break; }
    case 207:    /* RST 8 */
    { pushpc(); PC( 8 ); local_tstates += ( 11 ); break; }
    case 215:    /* RST 16 */
    { pushpc(); PC( 16 ); local_tstates += ( 11 ); break; }
    case 223:    /* RST 24 */
    { pushpc(); PC( 24 ); local_tstates += ( 11 ); break; }
    case 231:    /* RST 32 */
    { pushpc(); PC( 32 ); local_tstates += ( 11 ); break; }
    case 239:    /* RST 40 */
    { pushpc(); PC( 40 ); local_tstates += ( 11 ); break; }
    case 247:    /* RST 48 */
    { pushpc(); PC( 48 ); local_tstates += ( 11 ); break; }
    case 255:    /* RST 56 */
    { pushpc(); PC( 56 ); local_tstates += ( 11 ); break; }

    }

    } // end while
    
    global_tstates = local_tstates;
  }





    /** Reset all registers to power on state */
   void reset() {
    PC( 0 );
    SP( 0 );

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    exx();
    ex_af_af();

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    IX( 0 );
    IY( 0 );

    R( 0 );

    I( 0 );
    IFF1( false );
    IFF2( false );
    IM( IM0 );
  }

  private int readBytes(byte[] data, ref int position, byte[] dest, int offset, int count) {
    if(count>data.SizeDim1-position)
      count=data.SizeDim1-position;
    for(int i=0; i<count; i++)
      dest[offset+i]=data[position++];
    return count;
  }

  void loadSna(byte[] data) {
    int position=0;
    byte[27] header;

    readBytes( data, position, header, 0,        27 );
    readBytes( data, position, mem,    16384, 49152 );

    I( header[0] );

    HL( header[1] | (header[2]<<8) );
    DE( header[3] | (header[4]<<8) );
    BC( header[5] | (header[6]<<8) );
    AF( header[7] | (header[8]<<8) );

    exx();
    ex_af_af();

    HL( header[9]  | (header[10]<<8) );
    DE( header[11] | (header[12]<<8) );
    BC( header[13] | (header[14]<<8) );

    IY( header[15] | (header[16]<<8) );
    IX( header[17] | (header[18]<<8) );

    if ( (header[19] & 0x04)!= 0 ) {
      IFF2( true );
    }
    else {
      IFF2( false );
    }

    R( header[20] );

    AF( header[21] | (header[22]<<8) );
    SP( header[23] | (header[24]<<8) );

    switch( header[25] ) {
    case 0:
      IM( IM0 );
      break;
    case 1:
      IM( IM1 );
      break;
    default:
      IM( IM2 );
      break;
    }

    outb( 254, header[26], 0 ); // border

    /* Emulate RETN to start */
    IFF1( IFF2() );
    REFRESH( 2 );
    poppc();
  }


  private int loadZ80_page(byte[] data, int i ) {
    int blocklen;
    int page;

    blocklen  = data[i++];
    blocklen |= (data[i++]) << 8;
    page = data[i++];

    int addr;
    switch(page) {
    case 4:
      addr = 32768;
      break;
    case 5:
      addr = 49152;
      break;
    case 8:
      addr = 16384;
      break;
    default:
      quit();
    }

    int        k = 0;
    while (k < blocklen) {
      int        tbyte = data[i++]; k++;
      if ( tbyte != 0xed ) {
        pokeb(addr, ~tbyte);
        pokeb(addr, tbyte);
        addr++;
      }
      else {
        tbyte = data[i++]; k++;
        if ( tbyte != 0xed ) {
          pokeb(addr, 0);
          pokeb(addr, 0xed);
          addr++;
          i--; k--;
        }
        else {
          int        count;
          count = data[i++]; k++;
          tbyte = data[i++]; k++;
          while ( count-- > 0 ) {
            pokeb(addr, ~tbyte);
            pokeb(addr, tbyte);
            addr++;
          }
        }
      }
    }


    return i;
  }

  private void loadZ80_v301(byte[] data, int position, int bytesLeft ) {
    byte[58]        header;
    bytesLeft -= readBytes(data, position, header, 0, 58);

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - 48K + MGT
     * 3 - SamRam
     * 4 - 128K
     * 5 - 128K + IF1
     * 6 - 128K + MGT
     * 7 - +3
     */
    int type = header[2];

    if ( type > 7 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesLeft;
    readBytes(data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_v201( byte[] data, int position, int bytesLeft ) {
    byte[23] header;
    bytesLeft -= readBytes( data, position, header, 0, 23 );

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - SamRam
     * 3 - 128K
     * 4 - 128K + IF1
     */
    int type = header[2];

    if ( type > 1 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesleft;
    readBytes( data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_v300( byte[] data, int position, int bytesLeft ) {
    byte[54]        header;
    bytesLeft -= readBytes( data, position, header, 0, 54 );

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - 48K + MGT
     * 3 - SamRam
     * 4 - 128K
     * 5 - 128K + IF1
     * 6 - 128K + MGT
     */
    int type = header[2];

    if ( type > 6 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesLeft;
    readBytes( data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_extended( byte[] data, int position, int bytesLeft ) {
    byte[2] header;
    bytesLeft -= readBytes( data, position, header, 0, 2 );

    int type = header[0] | (header[1] << 8);

    switch( type ) {
    case 23: /* V2.01 */
      loadZ80_v201( data, position, bytesLeft );
      break;
    case 54: /* V3.00 */
      loadZ80_v300( data, position, bytesLeft );
      break;
    case 58: /* V3.01 */
      loadZ80_v301( data, position, bytesLeft );
      break;
    default:
       quit();
    }
  }

  void loadZ80(byte[] data, int bytesLeft) {
    byte[30]   header;
    int    compressed = false;
    int position=0;

    bytesLeft -= readBytes(data, position, header, 0, 30 );

    A( header[0] );
    F( header[1] );

    C( header[2] );
    B( header[3] );
    L( header[4] );
    H( header[5] );

    PC( header[6] | (header[7]<<8) );
    SP( header[8] | (header[9]<<8) );

    I( header[10] );
    R( header[11] );

    int tbyte = header[12];
    if ( tbyte == 255 ) {
      tbyte = 1;
    }

    outb( 254, ((tbyte >> 1) & 0x07), 0 ); // border

    if ( (tbyte & 0x01) != 0 ) {
      R( R() | 0x80 );
    }
    compressed = ((tbyte & 0x20) != 0);

    E( header[13] );
    D( header[14] );

    ex_af_af();
    exx();

    C( header[15] );
    B( header[16] );
    E( header[17] );
    D( header[18] );
    L( header[19] );
    H( header[20] );

    A( header[21] );
    F( header[22] );

    ex_af_af();
    exx();

    IY( header[23] | (header[24]<<8) );
    IX( header[25] | (header[26]<<8) );

    IFF1( header[27] != 0 );
    IFF2( header[28] != 0 );

    switch ( header[29] & 0x03 ) {
    case 0:
      IM( IM0 );
      break;
    case 1:
      IM( IM1 );
      break;
    default:
      IM( IM2 );
      break;
    }

    if ( PC() == 0 ) {
      loadZ80_extended( data, position, bytesLeft );
      return;
    }

      /* Old format Z80 snapshot */

    if ( compressed ) {
      byte[0] moredata;
      moredata.SizeDim1=bytesLeft;
      int addr   = 16384;

      int size = readBytes( data, position, moredata, 0, bytesLeft );
      int i    = 0;

      while ( (addr < 65536) && (i < size) ) {
        tbyte = moredata[i++];
        if ( tbyte != 0xed ) {
          pokeb( addr, tbyte );
          addr++;
        }
        else {
          tbyte = moredata[i++];
          if ( tbyte != 0xed ) {
            pokeb( addr, 0xed );
            i--;
            addr++;
          }
          else {
            int        count;
            count = moredata[i++];
            tbyte = moredata[i++];
            while ( (count--) != 0 ) {
              pokeb( addr, tbyte );
              addr++;
            }
          }
        }
      }
    }
    else {
      readBytes( data, position, mem, 16384, 49152 );
    }
  }]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="util">
      <Source>
<![CDATA[int isKeyPressed(int key) {
  KeyTesterResult=0;
  KeyTester.CharCode=key;
  @CallComponent(Component : KeyTester);
  return KeyTesterResult;
}]]>
      </Source>
    </ZLibrary>
    <ZExpression Comment="init emulator">
      <Expression>
<![CDATA[trace("Loading rom...");
byte[] RomBytes;
getBinaryProp(RomFile.FileEmbedded,RomBytes);
for(int i=0; i<RomBytes.SizeDim1; i++)
  mem[i]=RomBytes[i];
trace("done");

trace("Loading game...");
byte[] GameBytes;
getBinaryProp(GameFile.FileEmbedded,GameBytes);
if(GameBytes.SizeDim1==49179)
  loadSna(GameBytes);
else
  loadZ80(GameBytes,GameBytes.SizeDim1);
trace("done");


//fill ram
/*for(int i=0; i<mem.SizeDim1; i++) {
  mem[i]=0;//45;
}*/]]>
      </Expression>
    </ZExpression>
    <ZExpression Comment="timing test">
      <Expression>
<![CDATA[/*
int start=GetTickCount();
int ticksleft=60000;
while(ticksleft>0) {
  ticksleft-=4;
    int pc = PC();
     int t = peekb( pc );
    PC( ++pc & 0xffff );
}
int end=GetTickCount();
trace("Time: " + inttostr(end-start));

quit();
*/]]>
      </Expression>
    </ZExpression>
  </OnLoaded>
  <OnUpdate>
    <ZExpression>
      <Expression>
<![CDATA[execute(App.DeltaTime);

App.Caption = intToStr(App.FpsCounter);]]>
      </Expression>
    </ZExpression>
    <Group Comment="input">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[Keys_1_5=0xff;
Keys_6_0=0xff;
Keys_H_ENT=0xff;
Keys_A_G=0xff;
Keys_CAPS_V=0xff;
Keys_B_SPC=0xff;
Keys_Q_T=0xff;
Keys_Y_P=0xff;]]>
          </Expression>
        </ZExpression>
        <KeyPress Name="KeyTest1_5" Keys="12345">
          <OnPressed>
            <ZExpression Expression="Keys_1_5 &amp;=  (~(1 &lt;&lt; KeyTest1_5.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTest6_0" Keys="67890">
          <OnPressed>
            <ZExpression Expression="Keys_6_0 &amp;=  (~(1 &lt;&lt; (4-KeyTest6_0.KeyIndex)))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestEnter" CharCode="13">
          <OnPressed>
            <ZExpression Expression="Keys_H_ENT = 254;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestL_H" Keys="LKJH">
          <OnPressed>
            <ZExpression Expression="Keys_H_ENT &amp;=  (~(2 &lt;&lt; KeyTestL_H.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestA_G" Keys="ASDFG">
          <OnPressed>
            <ZExpression Expression="Keys_A_G &amp;=  (~(1 &lt;&lt; KeyTestA_G.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestP_Y" Keys="POIUY">
          <OnPressed>
            <ZExpression Expression="Keys_Y_P &amp;=  (~(1 &lt;&lt; KeyTestP_Y.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestM_B" Keys="MNB">
          <OnPressed>
            <ZExpression Expression="Keys_B_SPC &amp;=  (~(4 &lt;&lt; KeyTestM_B.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <ZExpression Comment="kempston">
          <Expression>
<![CDATA[JoyState=0;
const float threshold = 0.25;

float axis=joyGetAxis(0,0);
if( (axis<-threshold) || isKeyPressed(ord("<")) )
  JoyState |= 2;
if( (axis>threshold) || isKeyPressed(ord(">")))
  JoyState |= 1;

axis=joyGetAxis(0,1);
if( (axis<-threshold) || isKeyPressed(ord("^")) )
  JoyState |= 8;
if( (axis>threshold) || isKeyPressed(ord("_")) )
  JoyState |= 4;

if(joyGetButton(0,0) || isKeyPressed(17))
  JoyState |= 16;]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
  </OnUpdate>
  <OnRender>
    <Group Comment="gl texture render">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[byte[6144] video;

for(int addr=16384; addr<(16384+192*32); ) {
  int y = ((addr&0x00e0)>>2) +
       ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}


if(VideoBitmap.Handle) {
  glBindTexture(GL_TEXTURE_2D, VideoBitmap.Handle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, VideoBitmap.Width, VideoBitmap.Height, GL_RGBA, GL_UNSIGNED_BYTE, video[0]);
}

if(AttributesBitmap.Handle) {
  glBindTexture(GL_TEXTURE_2D, AttributesBitmap.Handle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, AttributesBitmap.Width, AttributesBitmap.Height, GL_RGBA, GL_UNSIGNED_BYTE, mem[16384+6144]);
}]]>
          </Expression>
        </ZExpression>
        <Material Name="SpeccyMaterial1" Shader="SpeccyShader1">
          <Textures>
            <MaterialTexture Texture="VideoBitmap" TexCoords="1"/>
            <MaterialTexture Texture="AttributesBitmap" TexCoords="1"/>
          </Textures>
        </Material>
        <Shader Name="SpeccyShader1" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  vec4 vertex = gl_Vertex;
  vertex.xy *= 2.0;
  gl_Position = vertex;
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D tex1, tex2;
uniform float bordercolor;
uniform float flashtime;

const float sat = 0.9;
const float[8] rLookup = { 0.0, 0.0, sat, sat, 0.0, 0.0, sat, sat };
const float[8] gLookup = { 0.0, 0.0, 0.0, 0.0, sat, sat, sat, sat };
const float[8] bLookup = { 0.0, sat, 0.0, sat, 0.0, sat, 0.0, sat };



void main()
{
  const float sideborder=0.1;
  const float topborder=0.135;

  vec3 color;
  float u,v;

  u=gl_TexCoord[0].s;
  v=gl_TexCoord[0].t;

  if( (u<sideborder) || (u>1.0-sideborder) ||
    (v<topborder) || (v>1.0-topborder)) {
    int bor=int(bordercolor);
    color = vec3(rLookup[bor],gLookup[bor],bLookup[bor]);
  } else {
    u -= sideborder;
    u *= (1.0/(1.0-(sideborder*2)));

    v -= topborder;
    v *= (1.0/(1.0-(topborder*2)));

    int specX=int(u * 256.0);
    int specY=int(v * 192.0);

    u=(specX >> 5) / 8.0;

    vec2 uv;

    //get attribute
    uv = vec2(u , 1.0-((specY >>3) / 23.0) );
    int attr=int( texture2D(tex2, uv)[ (specX>>3)&3 ] *255.0 );
    int ink=attr&7;
    vec3 inkColor = vec3(rLookup[ink],gLookup[ink],bLookup[ink]);

    int pap = ((attr>>3) & 0x07);
    vec3 papColor = vec3(rLookup[pap],gLookup[pap],bLookup[pap]);

    //flash bit
    if( ((attr&128)>0) && (flashtime>0.0)) {
      vec3 temp=papColor;
      papColor=inkColor;
      inkColor=temp;
    }

    //bright bit
    if( (attr&64)>0 ) {
      papColor*=1.1;
      inkColor*=1.1;
    }

    //test pixel
    uv = vec2(u ,v);
    int byte=int( texture2D(tex1, uv)[ (specX>>3)&3 ] *255.0 );

    int lit=0;
    if(byte & (1 <<( 7-(specX & 7))))
      lit=1;
    if(lit==1)
      color=inkColor;
    else
      color=papColor;
  }

  gl_FragColor = vec4(color, 1.0);
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable VariableName="bordercolor" ValuePropRef="bordercolor"/>
            <ShaderVariable VariableName="flashtime" ValuePropRef="frac(App.Time)&lt;0.5"/>
          </UniformVariables>
        </Shader>
        <Bitmap Name="VideoBitmap" Width="8" Height="192" Filter="1"/>
        <Bitmap Name="AttributesBitmap" Width="8" Height="24" Filter="1"/>
        <UseMaterial Material="SpeccyMaterial1"/>
        <RenderSprite/>
      </Children>
    </Group>
  </OnRender>
  <OnClose>
    <ZExpression Expression="MemSampler.ValueArrayRef=null;"/>
  </OnClose>
  <Content>
    <File Name="RomFile" Comment="Imported from spectrum.rom">
      <FileEmbedded>
<![CDATA[78DAED7BFB4314D7F5F8CCBE17D817CF010CCCEEA08EBBA20BE2324558E5251A9425A092E8A8C194A8890145121EEA86A4ADA9E923266DD3E6FBE9A76A9A863C45F3F063FA30ACEB52C6714454D03525B09A5D92EE67251851A361F89E3B60DAEF7FF0FDA1139C997BEFB9E79C7BCEB9E77167F34DA76972D2CB9BACEB59CB469628F6DE48984417B4DDC21EEC9CD08411B7A1ED5DB740EAF7596BD9A0F70F89E3416B0B4B595AD8DD1F93F2899C25BE7EE153599F2730768F0BD44F3C8D457615B05E5FE2E4D405D0471024FE55602C520AB8290BE0E744F33951D7231A2F8BC4E2CB9498C8E0542E0C709F56559C5A5E515EFAC81B95DCD2B395AEE51517AB8BAB4A4B2BDE285CB5EA7CE1C5558527D714AE78A3D855E25B53786645E9D9EAE5678B5D1756159E2DAC3E5B587CA170D5D915674B1F3E87E63D74BEBAEC6C61D185CAD2527EF9D9D5D5E7AB5755BD51BCACEA8D0AD7C5A2E5675DE70B2B4EE5FFCDF9B7FC132B9657F8562D2B3DBBAAB77A55E9B992D2A5E4D2B3C5851797BAAA56165E5CE95AE32BAD2AACF6B92A4B2BC83F16AF705597927F5C595A55E65B535AB57CA9BFA8B4F45CF1F2AAE215BEE5157C656165E9F9A52B0AAB7B8AAA96972DBBB8BC028060EE9AD2F3AED51757545601672B562CAFBE58BDCA75AEAAB4F05449E12A4F5529B4AA7C15A5978A5C5525A5E78B5D15AB9657ACF6952C17AA4A85A5AEF3652E72552FDCAA579F5C5E5109785C85A7109215A5172B0B5757C3CC872F56BACA7D12FACA15AE8B55ABCF5617AEF155155694B8562E5FEB5BDE5DBCE2424955E1A5E215A585E7AB4A57ADAE02B955FA8B963DE258B8AA6C4DC583AB7373AA9616AF2C5FCE2C282D7958BFC2F583EC9AEAB5A4AED29EF550E1B553C35F7CF4D7BFFDA5F3C8D1AE8E374FBCFFC19F837F3A19F8F013CF71F73FAEB0FFB36BCFE54F0FBFF3EEE0E743CF7E3CB0BB7FFD67C7FCEB2EC5A8550AA5262A5A6BB86A5D2CF49CE137BC97692B98377791E5EFF95EA76F3EF76877DEB9B36F9DBE70B1EFFCDBBDF3E68335E2A21869991F4AA7F59BF7C4770D68F87CFBDDEA8DE4CD4C1E63426DF93D22DD2326F7EC5A5B23129CF04B599719637937A9A616DA489963728F59C1FE8DBC2EA4C9CFC1C0097A5E183A4ED0B3014411E6DD3D1B9B298792CAD3B2CDD444857A620D1E1416C803CDD91A7682C7AF73687061575E140CBB897F162562BBC4D9E7448294F32D5D66A52CD99DCBED12F398F9BABB2E392DEF7671E630AEA0E530948825BB39F31C19BF84BEC9AFA5A32678FB862E455737C975FF8913ED977577FF5B4E269B57C9F82DF40591B1AB0748454FB7861B70C043E4CC7699F803FACFA29D3E165277B72B7AAE1B38450FBF05FAC937068CA285568964977323E75CC27DB3872FE00BE687E42E153668EE930F6AF396B121C66030DCD26018A688D19113FAC5CA9303F2EBC60B62898BDF4C6ADB3EA4B5AD2B5307BF5A1933F8D53D6E346B76973CE77FB7FD2E7D5C71C8C0985F61DD1DE406AA825ADA9274E01372157582AC6CE9CEBF315371759B427557311063BFD71DE333D72B04558EF0D182510533B6B779B44B96C508BF4E13A3ED96D161C5704E7BF1EA03EDB83267E10E3923BC96E6837F81CA47DA3EEC49F57E2CEF8DDA273B17BB775FD46F1F7D7A5F6C7F52FABED4FD85B27D19E7AA4FEF9BF7DF8EA3FB98C9E5CE7DC5934FECDCE7EAC056ED63612DFBB6C6DFCAD8F7CC985129DCCBC85BC4BE70F7C51981734161CCB6E949DD1D2D0F825BAC0C9ADBD3F967410BBF8BD1C40DDABE71CACA8CE205F1BA41F5462639AE9C79E3B242351FF53875AA5CF4C4F58B340D5EB512841233588FED7E7FB313CFF5CE546E236EB6F22D46D1AE5015213895931C5576E6F30927E395A983942ACBF9EC6762FAB9B6FC93A242B5C82872E3F7050FB8D1D03D46D61B33C6C56B12BE71421FE20D7A43E42D99EBD32E614469BF6B4E5018451BF8C26F856B4A7B58F57BF4F8C2D97DDC3E9C418EA93804D4DF225EB4DF84B773ADD7E5AE5998EA0891AE21D576C3E0D31861E04DEF77B5A6BBE208F5A01B7BBF6B904AD5A83E9887039E734EFE389FA03A72FEB41296D4F621797AB788238CE79C8905E44487A2678AFFB74324FD4DEB7C57487D4B7341CCE5C6F29AD881E1EC2656F8F90CC13E93CEC74D187475D032BDE576FF604015ED2463E38CDF0D3AF04990BCF9D664B4566E37201052D6AB6F394A47E151D860304085234786C42FC8E53024CA4FBF386344F880E6BFB5479B3184B0804EE8C54FBE28D12028F7607334BAC550833BF44E9CDF41E3F983CD5878449C435E1911AEA786BD6BD5E23B64FABF905D4F1D744463838E985433B664F069DD60939E58297692AE7F812C23C918C4183484D00CC2203C3F63489C4BFF7B9F62043A011718E7E08EE8C1ED31D28B6E70BBFED1AD830E4C4E9488A769AD444CDF4E24A1992711EA7F4D42B00089591F6123EBAAD9DC48D5E0D3D1834D31D67216BD1A069B8C6189E0766D106439A81D0C9A4C5867AEB0463918B0DF708A029E38E1A892EBDB41858327464999FE96A8B0FB4D5D5A9F1015E3190CF699BF9E4C5645B9F349796BBB2B2EE50445E231978CB7F856F243A7EE5200E68972695505A7351A5176FA982638587F77F0F17B831BA207D7C4ECFE98D645AA9859B45A82241F0880C9A906EB75838FEB838301242F592E8977382781A7CBBD2953B38208282E2E2E4CC44C210BC3D218AD49892597AC1494E9886C07ED04E471B6A5B60A9B5C2E1F84B441F83279D0BA910569D8062BA20797C6F8D0807B625C589D488D35F7513BA9460AA8E63A27BD324D58828369D3B04230D913F40128C2410D561806971AB596721638DD1DEA22A380694B113BE188C2FAEEA3B84FE5B6A33DDC179CC22CC83401A40C37CC494E890381C9524EA4DAEC9A6058389E1C20FE5798AB25AEBA5D627B4F10F4E416DBE9999FD01A1F0C7AC2C4D7A161F12019DBD71FA440D8A42AC97E3B40C803C4B073B22F9C9F8BE69E228D1AE01A6183058781598DA61F1AD067AD66AFF9348CDA86164CC8D1DDD317A9AE06EBD8C8FAFA6157043CFD30A98F0B3A2740F79DA6435AD0F3042FBB2E5C4C98320EE1A402765AF633C689295D38270703DE938AF6EAA6DAC626B2A9767BDD5CB2694B5D3DB9BDB16EE74EB2B6BE957CB2AEF5B0AEB2B1617363ED53790775154F3FB5A9AE91AC6D6CAC6D8566F196DAC6DAC79AFEADA7A8B5A96E67DE41411E2D92E7FD51A28AD92A12F63A7374D446885E1B92835E7974458D71CEAAEAAADC4AD7C60DEBD9756B5755C7382D9F9026888E15A456A1973989E3A45CA9377BFDBABC97D9F109470DEE2485BAE8B1EC97590E419D14F47AB3B03A46091040AAB5A0206424D63A1713DB4C2F44651B5822DAF4541421470D3D6B7D8805E3E04C37B5427B9455CFD6EC1113AF982CE49C92079DE92F3331DD32974439D199B8FFCA81B4FC3205086DE9C9D5311327B2AEEC8D0112BB81C67305A1F49E1A00EC065616C52490773821235A9A9882E0494DA4F8A7ACE5C72C17297E918D143FCF5AF602B33B4A2DED533C93F191F29FB2D61FB308BA2752FE226B450015A5560010DB990271BF7D5699C0440331D32B2C510601537046F3C48190C185EE5F1FD52B9A291D798F1BF8935DDB9DE08B94EF82950AC6189029341C6CD8BC88E5F78A2429E3BB67610D73E6CCD17AC2AD054E33A9574A6BA455FD82A0EF6BFDA4FFCCEA983E5F10A4AB9A4C6770457AFA019753D321C12821AD389B1BD6A41C3CFC76AC86898BA70AC81BE19968ECCC67D1018F8EE2344EF2471B3544683784A590FCD6C39B23EB5E62DDEFBEFEEE045FF30CAD09FD9DAF2165D719683D0EAD3B7C03B4D4CD5C7016768D50987E838D0B85318CD64902CEA56716C5A4849E0591A6C4BD601FEF1397D172F1F9CB6DA2FCB293ECF75FF2F771E3E17CDE4DD1F70AC83BE13191BC9C32502849B4CBE4D7F5B748CA92E940594C6A17341EA7132736643E40AF7562B00D22BB162381BFC9F52A26165691A54E627FF6CF59EB4B2C5AFBF8F44EB91333BD5390FC3EE70FFB61C7F845922E15AFD285B748B19E5E24F953647F01CB4BAC20EA26966629F4669FF05FFAEF65601A5E9B52A122C3B13BE228E35D0FD7BEF3B1C6866DDB3EED8D11654CFBC4DEAC81E47391125F19226E7D990D0A2B752DE3E627D9A52DF9CDE67DEC09469EA322044C3F56407E199878BA06514226038CED15FC3A78747BB84EEB2F2403A2159B27EAF500617E9925656EC3E1D0EAC3CD9CD0A933E7B3FC61BE1B90038B4289DEDCB536EF17AC9250EB495B33188FF1F684234B262D1C36066C8A0EE4394D6F191733B77073126185386AD90334EC7B855FEBA465032E60AC443F050FE0105770DC4C98B1759261C74A3A00BB812512BE329089C7697E19ED77EF3FA25449D0D66B7CC19690BA858C099B87EF248771122B881C81F7C9E47059480D1274B5A8B0C811955A1BBA437E16C8F0E84841F8A95E02806EDCF72F24D3C0BA55EB1D585CE4880957271784EE94914169D63F60D6A627E3F2A6A52487E4A9393A72C4A33773485105B72A37876BB7CC4157C94A0EACA106A96FB8A12D44DC5AB299FB467504C23E848A9B7A4F206377484D46EDE9261B161F08DDF9F166E308A1FB0616ADD248E3C66F9D8A0BF7EE21293CBDB4B3AC99327E0752FBA5E4B65A44F98190ECC2BD1A61553A1325C10943FADE98CFEEBD70C71ED6431AACD2F0B17C1C9FF2D9BD74FBBDB60BF78C5FEBC8AF386B011B343F6B0C467616B06084E389D8C48649730F267C2C1F33338620F8D22C51CD648A46260F97613550D0C6C827F85CF7E93423C06F847FFDD675B076F55E88101E6A3BB58388422DE814AA1263E322D5EB580E54637ECD80BC317473DAC79FA8FC78BBBBF7A275394CCCAD3FF95BA3509F2CFC26B1EDC3D3BF350651C26E8EC2B45274167E6B042BB81684588827066C130B0DC26A6222C700F19682CBB28E0D0809891C42436ACCCB59C1904C3C35E1C08CC40342969150BAA11847501CB4701CF37E990C1CC35F2010B0140075CCDDF52D972BFCC614A94AA63C977D252B373D49A584BE168DA4964A19483A8B9138D51129D286999044A50B98066EC3C0AEF9415698017C2739312FE43E2014FA2DEF7306D0C9E3F421E06112095334EF4F01617AED86A0B0DF6483C400B89970A8B100A0936D38F5800939C1FA9E3CA9583B3C0E9DF5A7EA75E076EC55A2D19E29AAEC516521DCD592DE1D4B5849ADF909D6A939DC4CE845FDE5019DB9903DD10C252206D33EFF9403D376398DFCC3249E3FB1E38249672254793A16F69AD505E2828D94CBA17DCACBFE00FF0E5B5F04BF80F4BFD924E9DFFA3C1B44A2080B7B88B0102060FC5A18E0F37EC6BEC2CC2255BB265EADB4A78193146E6AFB88AFFE6D7568B191752FB284AC4F922B24067E5DC0F23C2C7416C6596B595B4764DD2392B27B22EB6AD9CBD6C758CE2DEA711576E6CB643725EAC831EE1B27E0F880F547CA3F821C8361ADBB587F99530D55C8E24819265D9B9E74C86C7F25EF76206DD9550B69F942FA1B9B3F520C33AA19D602331474B2E523D6D4E9C4DFC2C291E3610A3A6DF8122C520CE31FB0662CDFE260AD1FB00EA7ED5B9B0D788DAC9930E7B1F7CCC7588B0BE625E00930EF48D866A961294B350B499BA39DB23CC23A74147AA9652D8FB1963AD6C964FF82CD7E89CD5EC69A29A545CB4E2CEC9E5878DADC9D6032B2B81E7C0BA8F32CEC41E4FD8427759D262661DAE9136AA9EF3749C29144296608730D42522A32463256B29E2560DE4287098995188477CB7A56B897DC72F4E4FA8421514743D4B12F3DD5A913EA75CEE489575D1060809888C021A5C48517539F41B6045015A7047D5E1E9B3F0E4E76A22977A26996259A35E398259105E2A08FC38003F13456264631B26EB5309AE0242FB5985E8E03663B4D0EC473A4BC941552539C7997262A742A0C5E615722AC74AAA8A51562023A2DD3E172CCB49D3597B0BC9BC6B591E3C0C92470F107EF7BB1ED2EBEA2F4E15564F3D6A62D0D4F37914B5DE7D7D4366EADDDB4AD8EAC6F68221F6F78BAFE8BEAA73741FCDABABD896C6E6CA81F71015CC3E3E453754F35347E3BDD80F1BABAEBD32961534303B969EB8874E253F13DEA3257F5EA93A5F53F44E08F6FDD16AC5EE5AA247736D536D53D55577F7379FD33B5DBB6FE1092C7CD4F4FB59BEA3603AE8629FC8DB5F59B83150DF53BEBE08FDC5A4F1615562FF716559516969399243ABB221BEBB6D7D5367D33CD103AE2BA8F13A8C16A6A9F0204646343C353B0AA4672DBD6FA2916009974BEB5D455F53DAFE86CEBFEECE5F35DE40FEB9ED9FA58F07ECF630DDB1A9EBE31457C6B7D5303E4C828298E5415AE4408EB1BC8CD0D0D5F544F2FAD89DCD6B0F3FBF5ED6C6AACAB8D2CFD97584A4ABB2B21737EAA0EA5CE758D8D0D375641F20D736A7FB8B57EF354CFDC83CF92593F60B2C9EAADF58F6DABDDDA4856D5EDACAB6D7C6C0BB9A2E90BA711C7306F5C5CA478396B5D0F99DFEA84206C6CA8A5828F6E058748AAA66A084F6BC1119A46C592DC864A977E080B01D8471E5F1CF203B6C87170A061CF76DB0EDB4E5BE398F7F5D89BDAB78CE537B5A712AA9F339C4AA8426F95EDBDB138A6C2A2311C434F23F26FF524CA933F17420997E9BBBD6A7F10020345119A34FB8FA4F70DD49AB0303731E0E75EE84E6C9885DA6D1F422D9F940ADE2FD9F2104A31DE4441A3C29C9928FC23F15C22B621F9AB7255756C652AC2DF3DBD674204A2B3175ABFF42267899FE520720451A928FC30D15AC7825BE1C683E672D6A9071AD79033BA66D7F687B5E146DB4EAA0FB2D72FC37D63D05DB2529E1CE6302C6C7A29119570B7D7501B38707D5249457922C5B5AC274C7156E45C202A4CFB17ABE462AC929709424E6ED9C20638E43EBDC164CADDD1F30945DE013F9E9624E049A013D3D53F869319357E31410B8133BC83DACE0561C15AB4D0B0393109565AA1C2B45F952BABE595788043475B4606C4D22D579B8DAC0BC6609E8D1BC519C0D972944E0C4F4F7787C5725A2356C316AF247B85F549A8AA41C7542D47D111892F2534E432B72102F63144C28384A9A98CC2D2704295A6226469C66800EDAF0970C4FEC84EC88B1D3223648C92ACA55C714ACEF66E3089C8BA6D2C922463E9076B3275C9C291AA6BF0E6918A592DA30F83F06C91EA6D2C11B16C63ADDB5014A6F1B0B08090D26DA79C903965400113EC334FE18943C27692891F121701F77349153AE92034E8A4442E7C3E7DE6D1125ABC79AB450AE76938A41597A464FE56DE932CF854F2FABB3DC17EF3369451F441CD1C2907C0F6E44427AD3461181F37B133D32D2EF19CF309740AC80ACC646F5B07ADBC840AB6FE302CEA5594DBBF8A421E2DE307A0B286D5914AE762C143406C0DBB856304C43D5A1516729389E13E4ED47751D2E5E6FC2863E7FFCA4F4CA5DB6BFA1D1884DCC0449394A2FB3948A20059575E21CBAB69457731918868FDC159CEAFA1A3F9CFF3D1312D2D7316F703AD3E0E6C3418A6A632AC8094C2809972BB3AEE10BA4E6D3EF35DA4A8801EF38E2608A99976BB6866E6C2125E15793A43CC23F552620581C2BE868E879CC342468DE73DC15E57643FC18E01DCC02530B66A76D57A0FC8E61C525598B8E93EDE45B96D9F70283F5BCFEAB1849E91BF908A0E8E426B861EC082EBC43C500C4F2AF8421A421A792D21970B82409924BE818E7FE1EEDF9317E34ACC2ED3C726516EFB3D4245A1B490D2F649DB0A76953098EC6B995FD63ADF25875D190E24F7478E04D056B2018511B46DEA586151A6F07A26A3307F7D597BE5C5195E5F627FB0936F21C947B7A64D129A7EB0A860388DC489EF046B32FEFB49B8EB6FC16D0F44C1401F7794FFEBA7A73A3FFAD5CBAFFCE67753D7B3CFCDDB56BF7DD9AFD72C2EB425A5E73697181EB115673E94F754916E395B92B01E2F90A9B0CD692A5EF9F50C282FD2B0EB33302A5D51A03AA352CA1F5060EF3EA014D295FB48A56CAEF28354EC7F4CF24369CA6F9334587B9ADC95866D4C93BF97863DA9D362FFB0A8B0BC7465E401E5EC3479519A56F93C85BDA75772E9CAF1A468B834D81DB95649526AE9D2606D692AECD716E5A3E9AAB951982349850513A3B05F2545CD95EEF00FFE405D27208BE8CC2E630BB2F358021F113E4D84C07DF7C519432A0C4CB10D7412363F931A748DB40E9C0581B9CCCB52B4155A426E6D62DD94A589C5AB527D2EC84C63CCF80CE437B4C1212537F4093A49E450E121EB8D9FE0A3DCE40E6B11CBEFA6E3CDE2A4A51439341BF25FA979252CB1000C119E747207595C064EB18536F44E7A60CFF65857B3CEAE37BB3A45FC2C069A895497B214F2E9C99465351B06ADD6A46128A9489868D49DA653E3859F25D39ADE4498DAE5F1A0B4E8CF621EF47B5F9C6178A05CBB397AD72F777CF45C2FECF64F3D67AEA786610DC83FFA38E1037AC2918BD93560DB6749A2173FF3EA1C90CD33A4AE13B98E319B79077BAC391C296E642D2B59CE23AC41FE82CB5BC48E0BF732C626D6E0EF849690197CDBC9492B4236DE7AEB403E193F46BC8D9C0C381BED08C0218C5DBDD1D36F3DC44D78B891BF3BB552279D4DC709DF99012F6C75CB2FD02E77AB0F87DE4125B57D261D2795E02B75E6FDACFBD69DE609BEE6D89070D54C1CF02A55B05005ECCCDF23918D1E64B85E0D921E1D352A63C2C25739573E4CF5CE491505C48574B84BA8E0367A8819ED92E1C3E0E327AD10506C6E5E84E45BAB66547A1D8A46C151998C0984F5519123D652368C6AEE35BA78AA51B8F2C0B989A50CF4598AD8BC3236525203D13FED1B5FA47C352BEC7D2052BC9AF530A6915BE4715A3E427C39E2C45FC92E61B95E931BAC89A040C3B95D4BA98A4871118B767010CABA4022E603E579CE11C3A0828A93F3665857A2AC319D02CE4687AF1ABA640CD0BD6CDDC29A0C5832D800F578D8BB33AD171B0D0C5F7560325C9E8B29980E8EC9E5468474E9E87DCE103AB2AC61DDE25C5A9BF605706697F5EA84660CB43704A93CF85F548B082D183A39E79042611A89F423CE3D753D758418777E5116F9C484C9BC3F4B86E0202535A808E050A4384A2A22E52D6CA4F81996B3D6B3136B1C448C049488ED16BFB6CF4587B98D519CF093B4482BBACB38A13F9349A065919271801B434D883CE08CF09EDE2861731A046EA1340DBAEE23FF80F545D6954BE7CD502342C1008986291B4BEE8B54D935D68F90C387152584A186E9F3A0E2C5874AB6F0577D138FEB32AE2D4039BA4FAAE2FA11F6780CA66B99A8B0B9124B66E491C6CBF3E4DED518A2AA4C2F59C979027D6DA2938E5E742D8CE6F840BAFDC15E1570F30C846C3AA6E5503E89CB51614A5F476911277D64B9EC14E12E59A8D279D6FB833418BA25FC62AE3D7144CC2095D03A3622D264FE88388726A1FFFC8B33C26844161E0983B549598F430F3B042C65589C43C68D8805A47EE4FB9D75180F2D419F52203ADB67067ABE9A8AE953F11C768330948EF436249492B44EA820E97BC277E9E8F98D38A747F0A63B7597B821F13D5227B4CE80A6A0A69C8984517C9F8C95B602F4BC96E64CBAD47AA9E51227DC309F830CE11CD08501B445CF8CD94E5ECB6C391ADD93127789B80D28D177FC3C0EA510F1C073145A76B45375895089B3BB84F1F411E083C43D9F722295DB852874201228BB3AAF4F84AAAE431294C689A30A0FAA2C870C173C24AC009DB14192719C91EBCD65E810D799BC5F2AE1A463376FFDD4DA4090FA1158F2903807F957EF0766F1346942F60E9B46441C4337A14362EE344FF59E0082A73F30835B0717C61FE3AF43DECABBC9681030782C995E7EACF9B643D76A30D8954E4BACAD199D44F0B96E722E6CE9A993803C73502A4015D27940EDFD22140A54297A7C62068B857787051306CC2092074C91F2E759E01A113CCCBBF913E40CE9042000DB11D5A430657AEB8103279220AB45F57F2E0AE2C207567046805052E2690F890E0A006A48BC4AC7E4ED608547668057EF011F0A9EAED72865FB901D89E5B0E96F982FA37D7C0B7473031CBEE8BF2C0E2DBE3C3E3236C08D8326C6902AC64117356397DA2E7103A6B318FDC0800CEE6B44BC4D85930AB55AA570B589327B622BF85E826953A9192584521503BD5009F7C6995F62450D13EDA6D547E6873268BCC5D52A6CB338D57F3E000FB53A5459E6D4FCF9C0E183879BA916EE409B41D54ECA0DAA25305D030E5A66FF5B2B60005010B781B88CEC42637FFB820834A64EA7B397B19CB373FF956F33CA3AD273D33BD2DF0ADD796B732B8CBF15FAFB5B6A75436B48CD810D0BEF58CA146EB57122847BE94CD411B4405D1229DEC34A434ED1609C28734F54D4F085247E907F8894BD35BFD9FB59B4104F95F9E0F688E72117F23F40498FF7E827C1A2E7FEEBDBDFA8B580718BCFD995103F8843A37F641C3F1AF581FFDD93E11BCD0A2860ACDDAE41C1C1E3FD8765F424DE2593E3C3862E3C6B18FE0E7A64CC44CE26585C43106E81CD963DACC74B6620DDA0B0E36DCEB84FC6F7BA223DCB6EC75432067ABB641E5996358007AC8661A575189FE2418DE8C0A8445C16C0951E190E3C9C94EE5783C3F2D71559E93E19D9253B29F30415C357158600EE910DC398427ED20AC8644C8AF89CE74A33CCC7993C90109D39DA658057B7F4EA330C07198F92CE27E2470359D71457BF50C83DB22F1457AF290C27658C0F6264C090757FA21C85227CF8FE643923FC4F86C7D80D4C7E8F5B8EFF3FA3A097D12C3A271BC395415C696550105085BEEB56D865CEEFC611187467A59F926581343C20CB2C4596E1903CD50BE245BA6E3D6E576DEDEFDC48A88FF66C29EC4FC41E6D49FF0923FF2BA3FEB5CBEFF1110A57BFDF63DDC3B6FCB8AC35FF278C8ED615B8C01CFCAD467F1F477FD31B05899CCF657E7526D464ADE77F3C4B855568BF129A30B9A83B0DBBC4427E030DD1C2212FAD022F39E55B506682A85B1DAC09C3935BA503EAB736B68688EB4B6A548FFAFA83298769453E9952E052A9E3A994C36F9306E36D8FC7E36CDF0F1EE6762C111530692054798C1796796157C342D0A139200123965F7F78B31B2CD7328376CDBB618B7D6BCD9F6A3A7EFCE64BA742EF7CFAEEDFDF3E8B8D78273386A8208A4D8699642ADCC0B183E734DD0EF4BBA9D83860FB8E9B122DF48DE83E54E71CE3DDA73EB07A6367A3346BDA39C6CEF6FE6D369A4447CA9F61055BE6E821434E6EA222A7BD10C3DAB36587E4590C445F14BFDD1DB47CC0D84C6811B8020C3E67C4EB9D85AF358E88D469DDEC690A74BAF04B991E23E38434B95D9FB05158201F476B1D8B45879682445FB0CC3CB570E688F7B399E8AD7DE608B10CBDF0961162B1F0D3B9F63562A13D1F651994F05F7387A603A0434F852136EB951D91222851D049236429847E083C9B9EBC4B091F2D001F88022B110FC9E5957933203D05072E76310A34482CC03FD38A99F46C1C42DB619A1CE884441DFF5A21C6D3F1106F55C6EE7FB8C421BB8C3F2A5E6764FC273E49BCA0EF1829C74D12AAAC23C4D72ACC65FECD6C54B9AB2ACC9159DAA57D6DC799BC8ED304E60301EC1223A48A7F8694A5BDD68FA4A4DD155A5C36BA8821B4BBEEC7684913B7F85DA48C3FE6213CFDAD12F684D0E26E8D4B344259374668984B6212D4BEDF4A2CD87A33BDD653F37D1BBA0BCE3ACFE40B7FE77A4E73BCEFEFDD3D984AA38992C995D2A542F25A3832953C40EE304EE2C85863514A61047D0F4D650FE3537A97943506346E2173080D958D0C64B860C6082A4A6DE0F57D90087A206F2282C2BB7468E838A981E740C627744CC006A99E948612973ACEBC4BF7F545AAD7B3301A044A454819894B68B50D3AA8448C0AF67F9FA090B600522054A7FF52E0BB344CD2051173BA9100348913D09843CB7A93FB50E5628D66AF59A2D9FE1164B201E808400B592DD0313377D1C7C55B43536B0E86D25D234191A6697E4CCCA04DFC57C8940CE896C81F1D216E8DA0342B2F86EDA091AC4E3E34A710894CD31A1AE6275D442EFA1940E8593AF313D292F4C28DC573183BFAFE9F122792F4DD5BE409FAE6ADF613A42A05E14B084805BB8738CBDFE90313A1B5FC9784AEAFAF2F38848641CC7702BC91DFCE01FB6E71CEE951DA7DEBD132249A69C1F06FB57C42C74A871692080002ADDDCF6F2563A8C83A28C0BB168441467D7D9DF95C6719DF4A96433AA2CF974AF9306CA221EF722B4C5ECAEFA0A394F4976164A7B5E13091111C0A400821F956BA8ADF41AA2057CC1FE140A0DBC43364F6102AF1890D660C0B8E045AC52E528B64FD9078860EFA82C275EBB5B070C6CA24470B37AD5AF0491F02DDC7838026AEA87C4A29B291804989A1610E81C38B474B15958785A35604A006357E86F60988E40E9236375517221BACECEF1CF799700CF83B43278D098275BCF291A0D4D24A36B9E949220ED802D0186974E8D1ADC07D68EC5AB20D9D14829763D454C75DD25AB2B20FE146C94D277AF1096F2FF08061354BBF2CD9416DA740725C677F504A68D0368C45A5445FCBD15C5A190882FB68FB1C0BF471615424230E7B84B7ED5712D23928A65059456F00139583B640F1F668D1C898C444BB8E2222A05B0676D6E92E5BAB546DA0AC3CDC0FB352075465B469CA246F9171B146B0955867178C1CBE4506847FDAA04864202A63409B5882363CAD32A9B06462044022E58D88EC52D2DE72B42778BBDFB76A3DE52023C7D17961E01AFA82669795ACBC1686EA421639E2E90BC05B8F746663B3D9DC419FD06DF304E472B9F7CB64E710E07B731C2686B53E1BD4E0D03DCD290C787C72F459079D208FD99A513F0752937EBAB3C6B6C1E6465203C739F5932C52C31F155E9D03090823FD2A061D50F3DF4290344366BC8394CD538647664D82B95C21AD015F063ACABE690DA3F4E54BD0DA5F463CAD5B66611435271904DBEF0B96ACBC2FB1664F747434D292A7856ADEF464AA03D0D13207E9891C97CEB60BD0CF355233175F160B179F13D75D166BE1B18B134F91C9260C1B19C83A8B9151E1C59127AEBC9F1526468BCABDB64C711E6D1016C183A447602E6321A2D013FC3BD4F9A387A02A1E122C994CF4E8F01BCA2E8581192146C5525A2ED675A92647441BAD14334999429ACAFBD0D9577FA607D077DC7D3F4B812A51AF2B53B45F16F31623CE2E0FD85D2A0C7DFAEADCF8D0B232E19875142AEA71A03406442E8FE26F0005F44BE931B5C12E9B9F3F8E7E1D12BD70F40D668C5F6CD78D8F7A86318562814C1960C668CDF86896821923908170B0BBDD6FBFBC9172EF7BBB86D36341070672DAF5F6CBCD54DBBEB79B290716E0461988C2CAD1D70DB3199811EC0F2F159ECDECDCCFB71695EFEA0B7035490736BA3A259E724653C8FFF313C56C14BD2F8F2B15B47C2C971BE346B31C5874562EA693314EFB25CECA38332F8D1EF49E82CCD51FF48F66CD3E29BF8A4346E7EE20CB00B5CAD8D641AA3EA4B5D52A4DBFBFCF4FD48C5E65DC036EC1935993F71EFB4AF67B6C9BE0CA84791E7900656DC1EC436C41D2817CF3BBB01FF73607BCBDF306DAC5194C1CCC18509799DF63F736B7444A600EF14A58F8F37C3F7F778F7FA0BD8CA7F8583F1F0737F33B10E3DD2FCD6EB6E9C83BC6914EF39BACE910ABD2461AF493910652A18B21A362E32672764CE434EA317E098D53C691BC77D901A8DA2716EE702A264E341085A3B2AB8C84DFD9FE9B79187FD72F0CCE9F70EF80C244E50722048963B25DC2CFE66F6C835B8DCFEF318E990FB1AD13153BB4CD809BB8300E4D68A9306DE198CD7D166B06B98B518BED1AE398035700ED89ED3B4005FE803F52FE2E0BC02DA2965188DF31B33ACE8C2674EEBF5B35BF8C8869859CC94DE984D104E3CDD68E1E8573DE25A7DD78AF90085526A870E1C1F9CED24B0FB676DCF8D1FC4889CB990955BBED920AF3A6A6F437CCC2D6AF9A332779CE23C92BF6F4716E07D6D143419D28DA7A7CE049B485AE5C9B7B3EF065BCD3EAE182E310199AA9D60A1F0A11E19A0DFDD41A6A03682CE0F1A3B7B100D7D1239AED89BE323F9FC9A7F0A97E7433DEF09C1314F62E7FE73CAC66BD1F361837A32BBECB3F83C4E3FD5C58A8CF09A71C2367F55341E42B511189D007C2DAF02F0DB00FA30F483E17FC501F67EB137E950D26D41F14FE6B7E59186EAEE376794B61787C3FA801A43F16680E6EA94DF687230F8677FFA221FD7D7F38906E4755FEE0FC1C9AF2EF09B5FBA9661B9DBE2B52B278631B2CADC6BF0BEED2AB5D9DEECF39FD7E96BFC6DFE95D9DE5531977AF8430368789E24D4976793223337E0385C0573997A9C320220EB8B6F443EEF16C66F85A21DC5BDE7605C0CB87034C54DB8724EE127E99D9C7218E3B852EFB65C476185EC2CCDA2030DBD211D9E40FC23F959930D995C9FEC85ABF9F9FC13F307D23F8643F9F9C6EFC22EC0FFB3D8196E748BCA36071D2E2F41B4BB3EC5B3AF249C9C8DAFC24DBEC6FF1DB13DC1DCE761AEFF4BF2EDC9BAF6E66E6C12A89392A520289554B462FDD16D2978CFF242E25D9634027A4DA9FD8EECFA18920E587DAA525894F4C6F067FD048ED0CF481D571BD4A603F8CF8676E86EFAF02B1EF0767ECAFDDD2A91A228C49BCC9CF9B78A37F8E3FF2849F3146AAFCF06737486BEA20341D531DB98ABBE7B3C6E9C0C687FC8F548EF104FCA185BDEC2DC87283DD3C6757393027493C24BE4CA26F36CEF6376DC76CA4DCD97ED8463AC0334DDA9C04B1C03EB77F7EF7CBC8DC6C36D8996D34AEE3EFAA34FBDB19C5DA446C3FAD2EE3F3C0E6EE4AC2770F1CFC3A52D21FB695F10CFA8F563A309BF15E484D6BCB9C93FC6CE3776F3687FB38E1D5ECB0BBA30B69B213E4D6AC7A191C92E6C322DA58FDB06A5F5839C7FE1DAF456A09A3AFA2B6ED7D1C76045B7204C3EDD8D872C395D7E135EA25477ECEA10506FB697B67D6434CEAC28C858BFEEDBF787BE6FFD3FEFDC2CF17FE35A7D4519FB3D5F1F9C226C7C7B9EFE45EC95DC014335773E3724F393A1D0F32AFE43C91F35ECE9F723ECC4977700BF1855D0B0E3AF63ABA17B439540BBFCDF92FC78F72E3B35F5FE0CAFC6DF6F29CD49CCC1C438EF0E9C296ECCDACFF9A3F525DC7FADD54B0E346FB829AD0A350EF19BA7737B485D209BD48D8357EFCDEE4AAF55ABFBAC174297B9674886BAE5B70AD1FDCCCE32C37960738086F3F54C3E84012B298E96C1161E520118A1CE1363D094F30866B3E77A84BAD76C5B8438B4919E5EEAE8C752A5FA6E2D0CFB73CD7C084CA3A953DB171C4DD8E9EF17ED8FA42CF82BEB102E2864BAD7E0E7DDCE4FAAD5B58F403FFAE050140EA0F9A7DD97EE1F6028043F6170C4F0D8751AE1AE054CA948A70EC0E2ACE783BCC95091B166419BA64074F660D2BAE7AA0C4EF5E206C5A6080C8B2F07A40CE70AA49428576AB0A8378164DB584DA8FC1FE69B67160C1CF66065A8ECE9FDAA208A61FB2468A4FB41D98EE7A2D2DD24228E011858E755E4B33DB32833E0E921EF4CD944A816A80D10EEC6792C5047B427EC10B2FBC20BE658F41BFC07CCE65C715902EF46A83BE3237750CFDD7E20974E54A649C532C11CA4EEAB04D1D7462CD543395D49C0EF7E60087BE10842FE71223D2CBB90EE2F3A997FED4CED8D4D83EAE6540C3D7907881C1AE190F0AF9397DE13168AB0DE382C14E2C30A09CACDF8732BADD1F5F6B21A38F7A68C5D86222718C883B4AEB525E65B464243A8EBA6623863C631D523231FE0F7CE1D8F8C56F73C60C17F185DCF70882FD3E6DC9CADB5004C00E9DCA09A79FE8E0FBDE6430B94F3A43D79331D385378086B9DE287456D9D27DED80C48BFC7600956DFDA80A73E8A6BE7065A0EF89EAC0F7C7C953E5B4385D7911071136CB3A16FD6460EA6765C2B54CF423B2BEA9CFAAD2C16478EA33F9F90369080AC184122075B7CB636E233E10B8F7D385D2A7701A4F410A1CB3814AC0B836B30B03A482F273FE0DBB920ED424FBB9B8B894D4D40E72D40F9D63B07338F47F980C2B670FE35D0AF93023E5328A3C86CBCAEB920FC386971F02CB1A2DC81963DE5934479135DB2B4767443F8D733C5CF7F87FB7D42D79FDD16C6EC47CBB33233CFFC891F8EBEEBFFCFAE1B13CF79DDE6B287121D58C7CAF5DDBAB64D4AFDA159192666E547610A1CB429F4C7AB507212772B4A393A81C0693E359395FAF38734690E7621AFC901C677246F19CAFB31A93EE28F0D7E5AFCBB372B249C5EBF29F9BDE8BD7AEB9F2A747EC3E76FF3B7FD8DE507B88BFF2EA1B59073E1A3928B2DFFD33B5F8B423D2F17BF786AFEBA9F65F41DE88D8BF6EF9F647F58A2CC8F1807FF8CF7A489E95DB85292043044A0E4C960A603F80DE614C95BA403EFA83ACA9C3B0BDF121363DFA8F2F31D7BF4A78EC2FD4F5577442648C5A9FFA4F0512553A4E2A194EF86DB65B7C8ED18F1E4AC595598E3FE253280EE2D3387E6EFC204EBFFA8B5F3CFC83BFAEFBDDC41F30C7D3073FFBF2A3C78A4E853ED63A4E7CE5D899BAFE7F2F7FFED889AF6B0F7D1823F10B130FC953E943066546166A5BFE2847FC65D9B1B4D799511C9EEA990AC67BCA218357ED413C17531DC295B2430C37F99FEB3FD77FAEFF5CFFDF5CD8FDCB081766C4B08C8CA976863B03FE304CE3A49D514E0DB6E9871AE3ACA500471BAD2579D06F9C825368E0526018891090D011AF716AE2E1A981A7660A463305ECBC4F8B20E0265368107CFED207AB36E5431F0D780022BF4896BFC48D9E31B222E8D710F43237E0712FD92DB5F397EC2E424F379A6F4470F9521BEE4E59BEB412E94F7A20020086F843E42506A0A591E6293418E0CD7F70CD862553F3DD454518B6BB08F0EF46ED254B10DE9692A2A2921689FE12C497F45C228D57A071691ACC736AA6F897C964123F25CBB62F2B81FE25E88279458FAF95E08A36553DB8B448A227C1216A53F88AAA1E9C6EA379F94BF2A5F58A46493358D1343C7A641053CFB5A01F68101900FF7C092DC1B99158819E1EF1A387F52E21A5F56F4768B6C3F2995512DCD43589CDB0B490081E6314F925809F24F32D1624C7192449CE00F14137EAC798921624A7182331351F752B18585F4B49490912B7DD6864001E6628804192B6DBE98C29BB32C600FC9655706148A0123CE02B2961A6DA2D9200103ED5145D6447CC1246D182F89D9E5F320D5F5242D3887E09A0A3D19336D22553E3881F6C37AC7F375ABF5D5ABF46BAD0FA63A4F5C7D3D2C2F38B5E3B74E8B5A2FCFF0B5E9D65D3]]>
      </FileEmbedded>
    </File>
    <File Name="GameFile" Comment="Imported from JETSETW1.Z80">
      <FileEmbedded>
<![CDATA[78DACDBC0B5C54D5DA30FEECBDE7CE30176E8E1798CD451D517344430E226C11BCA7A332DE526750405004420C4C838D4959A792CC3C75EA9CE62D3D2FCDA9B453A927532635139124EF27A3C652F2CDB0E966A438F33D6BED01D13AEFFBFDFFBFEFF7FD3E167B3D7BAFEBB39EF55CD79E19133BC5D155F7FA36FFFD19B17C9A3236EAC5E4F983A7C6A52EAAD808C07474CC864097A7A3A33F040020D0D1D1179FF1A6ABA3C3747751F783549A0B019FEFCE8E3EBCF1DDD99116FDA6A3A7EBCE8E1EBCF1DCD99116FDA62301BD3BFEFE0DDCDDAF8B0EDF0F214017A9F937377795E6828F2EA81F42001FA9F937377795E6828792B01F42000FA9F9373777952E830022FC8F60DDDD43747428499641B2EE29C28208DC8D2769EB236D7DB7D711165CE5DDC4206DBB48DBAEDBC40A0B92F22E8293A601D2F4F67E8407374BDAD3DB5B195C5FA0F7FAA2BB4BA2C9532CC978A96B7890572496BACD4941F2067A9337BABB249A3CC5928C97BA86075955E2E8DB8C1CDCDD40EFDD8DEE2E89264FB124E3A5AE380AAE98ECC4809E3B13BD83E0530F6F4577974493A75892F1F4B99C8C2707FF916A7F175801D2F0B276747C0B05A47869FBC2A505A4B8402A6E072CD542C1F9B4B43428BC6E2A2C80F569E05C5F757E3DADE9E8F04A2DD61717389D50F5B9A96A3D580B70546DB1B5778B0C703AABC9181F9B0A8B490B8575BD93B6C8E819C3E9742A14B0F4880951482E8082E4E3CEE43B67F1F9D2D6AF47DCD3FCED30200DD2063CE81B106C1140780A2C16B9BCA34307A74E9DEAB92C980D0C3E7474A8E114907FCC2C96E1A7060E4C901E3A3A34B48676183E9C7448200FB76B20D83E4176AAA70F8E2675C20EA4A257A750183204C719289301A8D509098475D56A522697779718705495EA94FAD49053587A4A4DC7C5BE5A8AE1295A337CF89DE53461CD9021588E6BEF5D8C156A35162790C63A42195A780ADB2366A4B01FCE2793912521434CECE810829087EC6C8542261B3F5E2E9F30212B8B607B770921F170604DAF6F7B735300C24243E511A1A1111CE11B06141082398106324B9A008116D891BB2397F0A30664291AE85C04B07BD1BE45CD8B3A171D5BF4EBA21B8B7EC192AE45240DDFB208D88E0E15ECEE07D0AA84F9C8BEB1707F6C1F41F0DA62A362FB70299042E8AD2194D7105968C80D047E523718A6FDA43E1C39A7567F387236B9B389A01902B792EEB55AAD3AC05690FA5D5CDCCED41FAC3A8269EAAF9E51A3C6FC2109AB6023848ABF848AF4AEA343C193A177A6722B56578EA48F228809A2B4EEDED778F0CEBBC05E60EF836F670114A5FF18FA71C897B68F43BEB2C5F4F94CF371C8255B34C27326165220B4EF8FA17B867791956E1C3A3C7FD4FCC11D86505043DD00C380D9FD1FECCF8543FA6F67F8BF79ED26BAC1034EC885A5B00CF2201F0A6039EFE473F9A5FC323E8FCFE70BF8E58253C815960ACB843C215F281096A3ACE63A973A9739F39CF9CE02E772D129E68A4BC565629E982F1688CB5D4E57AE6BA96B992BCF95EF2A702DF7383DB99EA59E659E3C4FBEA7C0B3DCEBF4E67A977A9779F3BCF9DE02EF7228842258012BA11856410994F2857C11BF825FC917F3ABF812BE5428148A8415C24AA15858259408A5CE426791738573A5B3D8B9CA59E22C150BC5227185B8522C1657892562A9ABD055E45AE15AE92A76AD7295B84A3D859E22CF0ACF4A4FB16795A7C453EA2DF416795778577A8BBDABBC25DE5222012848E87844B10CCB320CF967394CC809C8E289586B55C85020A424932950DBCA48C58FB181FB931F1D9AFCF248FFFD7F2ABDA6992473366B673CFCDAEB0FC437AFE7AF37C512B9603886638145D786E53C3EA28289A286E06D97CF037811FE1C3F653682A1BCAD3C7FF56A3E7B464EF66CBEA2949F53915B5EC1D31A7E6A76CEF039D939FCBC29D3A72FE097AEE5EFCBADA828CCAFE4E7AC2AAA28E4F91A7EE41F5246F373664ECC99377E76366F9B3D736AF6849C39FCF48A3CFE9EEE34694D515E3E3FAFA8B8782D996059697171FEB20A3EB7B898C7C1F8A28AFC55ABF9DCF2D2352579B4A0B074CDEA7C7E697E4169793E7F5F515E49D1F2C20A7E7529CE5E5E94CB57E2407C717E05BFB6740DBF1C218E89B7E5D823EF1EBE57FAEF5737854E1B44263F8F4721E6738A56E5E34D2ADEAE9A94BB2A7FE683F9E5A47C0C96E44A797649457E393FA11457945BC12F2F2FCAE38B4B97E556149596E0A8FC9CD2F2F2B5C3F88AF2B538B4D4A67735288169C5DD786731D1306FE01D036036479BFB98CDFDF5E6FE66BD19FF63FAE3F3ACB451BFFB3F5DFAFFC370FC9F250CA785C9F70BC905B3D2A40696348B2579F82CFA6F49B65868E1A0B4E1D3D3865B8451B38451C385645E481EB7765C60AE73AEB3A040C4BF0227BD77CE9D3E1913AAC7B902FE65654D9F4E4BE71614CCC206B366399D5827C48260640426D00FADE6AEB6D83FD6E1420E1D7BAC2DF6EF752D871E3D76ECB143004698ACE35BC46DB199938DF0A20E5AE66E8DCD9E4CF2C9349F4673F145232C60441C26B56AD1918149558BFC6FA7B067DF291DF4D7EABAA44B75F7C58C18B0D61F96223F1B36D3F4F33A63CCE49667B6AD3D32DE184D6EDA626D0B5AD21E6B8BA7E961FF22FE7BD355C6FF4B4755BBDEAFE77F56347654354FE29353172C68AFF12B2DC3CFAADA4D7ABD7E66EA9C05E456F9D6CCD4B9F44E8F7736A94CA9BCF856ECA5BA034D6DCDE06F6B66F0E2F18AF507078E51F97596F018833FD4121A63F287589431BC5F7970D2636DABA16D35D3B69A6F5B1DCB98001BF0379B76267D5C9774B12EA9A52EE993BAA4E6BA246F5DD21775E9CAA4E375E9AD4927EAD26393F88DB1EF2C8E3B5517BBBE2ED91A4FFF076D4F0DBC5A9AF4795DF3F561FCCDD82FEB9A8F74D3BC0FA1792C3CCF0087D0B9D098BB903143F244B211391B8D4E1BA5BA11E6F7DB6399E83F65C9F4AB2DE9FEE196547F822559077E9525DC3FC4A2F70FB3A8FC728B52673071E903C3D6B533B8F0B7662A2076E446F599E6CC28C1C2464D56A85A5EDCF649F843FE8507B336E1343FEEEC98FFB6E1663BCFCBD3195C59ECCDBA9657B61DECDAB413F7AAE5EA13B7F199893B7AA98EA0E48882B6BEDD786159BBF94852CBE7DB18FF4EA426E367781D16A6F9BD3802FFFEA1F04DB17575C69A3A464197F967232C44A58683F11BAF7B96DF836C25D2E7B6589F6884DA74555B0934EF1F143164C8108625DC38837980F6252C318EBF187BA2CE78AE8E516249CBA8A762C166646C4C402931AE28EA7823D8102F44B4AE07C7CF459DBF63EDCEA4B37587DE783CF5785DACCBB6E7E8241D5CFE30F5621D92A9DDE988FA0B72EF0717E3E30D579A5AFEF8782C2C31C222061D0BC4B9CC084E069D935D2D9EFAD42FEAFCDCE1534FA59EA8F35F3CBD6BABF47CF43902D9E31B9F6B19FD5CCB81675A7EDDDAF2C9B3B1E03482407B62753BAB8F3D59B7BB32B5A56E8F25721C321099392516161999454C80A924532DC27DA6B3B6C5D6D419D7DA740ABA96F575C6329B8E236B69AE4B43AEE31790066DA3656DD5327F2A3FAD2D59666D1BCDB55573FE647E5C5B32676DAB06FF489E6F1BCDB45533FE51BCA5AD5AEE2F43516E4B06BE2D9919D9962C2F338505EB5379159659B16E24E3F777543914351D556FB733D83ED58B337AEB2CA18A5BB8BF66BFD932C508A060A5077ED800FEC708DE97FA559D5F73F8EA13A6F658985FDDAE3CE5AF3EC2B52BE7551F31B5EFFD4765FC7AFFFD7C4753EFFDFF5C3CE54FFDA4CE1F38C63CA9684491088EAE699EC8ABAAAF719526B6F9D1E619FCE89D383BEE531A4A5D7BB51EB92FD6F1685FDC45A5F2EC808EAC47E7E1480B190E4EF9A3796EE13593E17A28FF23E3FF0E35C5CC837FFA63BBE19A41398FA2874F54E447B49BFF81427A28EC715A7C0C7982DFE81F701021EE6A2B815FD529099BC77E5DD7D697F1DF24A8B51D004B98DF8CADDB0EF831DF99F4156127C5175225D35319B85D89E3A44977E993902E4666BEB4D18E11EDB8F9CAEBCA79D39AD5245D37EC3CE5BF66CA243AE6FABA71FE0CBE35F6785DF59E63539FBC37F65C9DF184C4F18872B7DAD0138E27526A14FE12BB7932D5C746E74BB127A45B14C1998A0D9AEBFA524E73965F6E145EEA2E1EE1D8C90840669B4067EBC18B88B256797D12E2D77EE33A9B74624152EB82A4EF1624F91660D51119CEE53FCCFFAD2DB6A24E27331E1328675691FB93E41E0D5F94C2E05FDBAEBC2E241D9B9F466173101E0FC296203C1984A782F074109E991FCAEF8BE4F7A2F16959F9541B8A617A59D2E2A75AA6917B477A15DEEB6001F276AC4B6490026F4D53A8A2A03A2C3EC270A32D5E7BF0BEA790C744D2AF5AA96CF13C558DC6412F4192E315FF70BB68F932F55FE21E4B48E23971526A8B58196FE84A6D13F71C4DBC20A67E2AA2E63CF285232A804593520F8B957D0D5D4DEDDC4CDCAFDA232E4794D8AFAD12DAE29B52CFD68D6BAE3976FA69C2C40C3F27F54C5DBBFFAC0AF5D3A3957EDFC95D5B5B5E7A3AF51FE28163EF3F1D4F32AC4F4B3A537756F583F1E98EAC341C6E9E8EA752D0BDEFD8C21F766CD7D37E8345EE0F3DF8FE6664C7761D3F30F1146E32F46D9E7EF0E4D6D47DE2014B783C05DA54977860E8C1D34F1F3818C4E2D8FB9B635BEB9AC9C39E63BB9F4EF31B78365D8B864AF97BD39DA83BA2428BD5EE2BDDD91CF9F1A2E5A9A75097BF5B8A96AB295D819D9AD25992937686761FB6C415D1223A47534C4022816500995B7B724FFD4EAC437A1EB0C8E20FF08AD4B3E259CEC1F8A9805CE75F75484AF0EF8EA040352BAF33AF3A145F7754E9AFFF823728B1D76FBEEA208F08523F4635A941CB834DB911AF3A74B0AE3DD19F6851E8644421AC6B8FF4475A14CDFFA2DAA1B5AE9658BAD88DEAEAA4D63AC65F1D544E7DC8A0CD932C7A3A5A321DAD79B9653862D23C931FB413F72389A837449B2E850F4FF7A195207427EB25EBFCB809476F678F4A0D8E9207E658667DEA491C503E2EE924D2E7933AE47D3FF009B85178872C34EEFA7F5CF3A202E98BFC7380D7323C29DCC3738C37806D1E6E371F7B62AB7AA891C706C8214771BEE621B593DAF516353EF73D70744FC76CFCC78DA8221E054767398986C6224FBB3DE31E3E1607A3B3FDE55AE36F66B3046753C7C79309FFBA15A79346FFBDE9F006F3034787E2A43B710E3271D3C58BE901A4CDA19F1F4789AA25162570B49D3BB6FB19E4B451CFF8D96335CFA04F556DE1D184201FE8CFB2FEADD691988BFCD09D26CB11D61F668D3BC29A62683D4FEA23ACC6B3EC1E5E9B2E9A5458BFC5CA1E61DB2A99F69AB603CA83BB9FC139AE89285F8776D391F9782C38CB636D25F89D29A56DD52CD1B50A8BBCED5ED6E44473556B5A884D8EF0D7492FBFCB3A3DD844894D46B3263485906B1A4386556183769345459B1311AEE6DA1E95B55572D8D81A4A0665ADBAB66A0529A9967564B555CA8C2AF4740E1DAEEFB57AE5B1B79FF573C7B66FF1CB2CB96D4BB8A80DFD24ACEA4AD729DB99EB8B961BCD3834D3AE3F92D23E6966757BCA6B331F887FA02F5E3861BBCE2223B73A6274DBFE066DBBD976AFA36DAE7CD086B6128E8EB33BBEA01415F5C13DF587DE7E96D240D976AF4C37CC84EB91E97E42D4FEC98733221B1465837F3C8A32366DF71EC4F64B5844089755BAAE5D54223268E401ADB15FC9736DF7CAABAF2B2BC3FB2D1F88ABAC4CA86EFB9B1C67490E2490471CE1562C6C684B5623F62CA141B25CBC550D6D8F72A5B70A18E4FE3DBC015D88BF5932DBAAD528236DCD2147DA0EA8F9517833D132BC6D22A22FD7317E598A1E9D52438A5AAEE3FC420AAB633B269CACBBF5F0590372D465D420174D38837C77250ED3F62853DA7C6BD0234BA2E056DFE6FDD57B2C8327A1835E6D31B635CB15784DB420DA9CE17B931E1F74785563C1682C209D0FC82C8AB6D1EA43BBB72076C87E9A3409AD474D5914A77494D5E6999631FAB637013D2D765CEC5954CDA957C59968EEFFC92BABFD5A2B9BACADC68152C22C86641F11FB4EC492A83113489B7FF0994AD4B2ED9DBB2B715FE32BFB564A5793E4D0CF68FE27F163857FF265D5B8FB4716CD4B5832B01FA5F738E2B5210B223525EF8AB5B60D355D23BE28DD38477AFD3393D6A1220E45E7E973D4419FD7511F1C35D36E531CBA7975EDDC116E66BFF6CEB7C2AA89FA6E571D71CEBB1C7B51A43EFCC561FC862685A1797C3F8BEC6F9E7EBB2B8785DFBE1F9E10BEBE5DC91BD69F552D7FF8085FDAEEE565EB8FA8961B5A7736A5FE9788BE0FAAFAEBE6767FD2A9BA8BC40DFA2658D6EEED2EB9DA5D623EE2C2B2F4C549A7A5F8861087B6F896B4D8892544FB8758E5D432D01EA4FD226C4F9AA1895D4F43912365CB17E710B37B74121A863D7C7875B3B25999903083B83F610F0C1B60B8D154DDAC6FD69322A699315D254E593C4FACC61EFE5E2408DA0EFCBB2E3AA8976651C578FC1E2B1BE38D7A29B6A450C74842139B9D1D57B23856A98C7B7A7113C5C6AF6845D4BE40AD89E3C57AB0CCFFBE6727FAD0A8576F97E2F00C8EEEA0FE3CCF36FF18858E4EEB066680A1A5701B19EEFDC5719F2D6E427DAA00EA231C117A346E3F626EF908D4D0ED9C523989568FBBA66D68D74E22A6DB0C3A7D4BCCB678BCFA0621AE409CD9FD60EA4BEC381FB21615B2026F514889793FB6BB9E985EB10D754329353B881D9902D17C1BE315827834AF88DABDEE9AE85018E85A67A2966A2B60DE2A4526880FC78C044DE186FF6AC272125EC70F78E8AC6A1E725CD320254A1EC6580A95E43C3555A37663F260E79239A7FC913C378738D2AAB5FE24A445B82A94FFA6A5699B27DEF42F6A48E517CCCDCB3D3D015F9343E79FD7FC4AF39F27ECE5D92853C72CC32FE3F86B4D34869A1F8CA1BA9D5653C72E1A6034CF3B0660FA453A481CFBFFDEE9FBB061FFAF9FBE332C27932B3A3A22940AB98C6399FFBD93F824A8F11FE21A6F35DE0AD0F4EBADEF03BF4A09EF03376BFC35FE8F7AD57F1FF836D085B53F06BE0E786F057E24F547683D6D1190EABFC7EBDBC0F7B7025FF7AE6F0C04B0C9AF58FB5F012F9D21F0628DBFA36340F624FCEBE88883F16B21F321E0C6822C0D09A554F6FC939772E3C7436626701C909DB8B3520E33160ECB9E91651B6F9F93BD61AA423D65C60475F6AB53B5EAA9B3D55845CB0F07CBB32EDF59AE98A6554F3088BD138F6972E6A67B37AA4534AD139E4A7B70CCB795D7004AAF7FF7CB77BF9CB9FFC2BE33F77F71B3A3F2DA2FAB1E04A8BC36E65B0E380FE3459EF62A45736746D798E288E7F53E9258811514CEFFAE5E21B077D67765F8C714446CF9B7FD0358EF8CA8EF5D9F0669500DA3211DA189DE57C32F7013EF1E8412A8043D26B3180A7A510F0ABCEF2F92144D9F14A0C4D1398FD2CB099C17E711C9BDD2AB2FD3EFC23BA7C2AB2C031FF8984E68854EBC73927BAE4BE9575C874EE6534EC73D298D1F026690C6378B199E1A6FA9D30CF78B659E911E697CD6A3F4DC1E5FE70BF5711E1CDDA9F306C7DFC5F882E39FA7692F7D728217A4050E83F5BD16F81D7C817725B8C46B43A785561D7346B7DC1FE31FE631FD68FC41E8B7E798AB6F5AD29F85B06AFF63166DCBC218CF436F1FFC3026CDC49EF3245E13AE267E23C4BD225CF554EFE15190E4F10FBD9A76506E4E6D13C61D3B107D486E6E1930D4830177CCB8C71CFEE1296CCCA043AFF4356AE08CA54FCBCC98AB5F598C574F0CBB9A7849B86A51E0E007FFD4F7EAFA77B179DC2521E9A27031EE4BE18343A3FAB58C89AFF60F3B5E15ED3F86D9D0CB2D5BD5172DCA739F1E8C39E4888E625AE4E63D47CFF99FE3AF47F23F9AAEA0BD7F4938B49E6F39361E4D9DA265238BCF43CF1DF7F3C78A62AFF37E27DFBF8519EA979D9C1A733916D2FAC6F1C2BAF68CA4BF0992DE54031707C0C323C96C02886CA3AD954D0497AC717E6BD82070AA1A9D1E762008DA4681424DA3B08BCD87BC9F1A7917BB024445E3A05DEC50D25EF486ADC2F6070CAD6105E0B9DE58E6414B50C61C088F662E8100EF833AAC18ACDA7F82276C301864BB806765E064DF835DDD308CCCFF1EDFCA6AB0EE25DEC97C032EECA7A9FD8A401D196717F3BE219A690711DE9747331D6023F5CC5528C3FA3ED8DE0ABBE531612BA0BEEB1F622BB6DB05EF6BA3C3F2C12AFB0788619741E87A03613CD4CBF6082EE632B422B3C4305F61BBBD867EB5F45967AAFD06EA61AFBE4F6D3EB2EE4E4D8C8487CAC4942053BDC92A997C9C7FA7362C2C1BCA64EF393DB8DE6DEC7BF59EB069507FE33DE79BEC54D8257BAF7E6FD8541064EF412BB6DBA542C814E038FB201CC7B1C23E630CD24D50EC31103A7B647BB01DAEBF93C044B0B27BC08578B5C2BBCA285C1F42990ED7D30AFBC154BB1CF1DB07F2DA4B88CF7E50D42E23E3217D97E37C6FF0AD48772BFC13FA6F540076D800B50548A7370C31B86F4EF69F50463FAD80835BE11DE85FDB8E83BC23EB8FC4AD877758F2EC81774C842822BC191923C34106C07840220A5D2F810B89879B83482AA05EF1126E263241E74B865644C686E344607F84DA01B18488EFA8236ABF2630AA7F2C41FE1DB976FC7F111812967B8940431FE64B02FBC4B0F1B051B6AB6C173B089EA470086CA530015EA2300EB65338105E271089E18277C363B0BD1376D9CA2811DE8410867C7EE0406824B39C71C21EADA97629CEFF4F5681EBF3C04EDC6CD2EF7DB591254CF23AE28FEB52214422D5C34E650412CF096F288D617920FA5F2F73B12BC129FBBBCD85ED9E671132CB087D408FE3F094F9E87C5131CC0A64A2378D31B584F807C2A2101FDCA490306C87CCA98EC17EADA41EE12E7817423A3AAAC89B4F05BCD1D1F106FC807F9DF87715FFBE3839D336ABEBE68DFCFCCBF7FF7A63D1970B16FCEB5F3FCE3D5B787CFAF4A6492525E4831267664C3D7366C67DF715CF3974E8D0030F3CF0FDF7DFA3232064B67D7E918CD63771744AD3DBEB269AFB0E88CA7BE1E5975FEED7B23BADF56F6D63763F1437A14151F05153DC8F6F976DCBFF6EC55FA63CB365EBB63F2DFCE30B2F3E7470E096A5B959CB5FBAD495B968FBB35B9FDBF6A7E75FF8F38B2FFDE5AF51A947F7A076CE00BD55AFD5737A3801234095D199E1CBB866FEC27C417F537F53AAEF4E19DFDD5DCFED641A99CDCCE61A4C934EE84FFCB6BF2C2366C4D8118B37EB362B7FA79EBC8E7A1257BE59141B376FDE5CD7D1315244DDD5B8F9ED5DBB447C1AF13B2FCA5590E8AE09D404D667ACCF20B0260058422E62FC2733C364EF87F9A7F9EFA9793FC3BF3EF0434D53CDC0B4AD4936B52007EA2C78F5BE3E57F4BEA8425D5954A174DFE78ACAD0E78A41051006A3C5717CCDE49A93FE8AAE71E9353303CFFAB7FB87A469A6B3F5C8613CD95A968D635FCB6938FF4045DCA763DFBCE7EF09BFF217F8F34C0EFB04601DCB3215707E56CEEC1BF19F7FFDF7985F4DFF52FD4B9DA37882CCCDB2DCD3682573D84F39BFF18FD35E1B7A735B67F17939F66400E552F89FFAF3B237BFDDF7B057B9FF5D976CEC7A80E85D3CC257B26EEDC1E7CF78192F1BF38E4B76B3C6251BF70E2FEB5F0530EE9D57B2A41E7BBE25F5A99F8DDBEF558E5DC3CBC6BD0FD0BF0CE1FE57B26F56BAE4E33A48FDD8352EF9AD46979CB488DE0B30B62261A3D4E31EEC4F2865328D396E4998B3256FEA6B43DD43574C2DDA929030EAB8C944E8085EA52FC5B4FA78DEA029CFCE9E767AE899C4D3C74E864DB994A00DFF4955A544074AE93599567FBC7D60D37327EDA7EDA79F3B39B0A9E952F8EA769349E9C55A5079CD9F59072DDF7274EAA9C4D37FCF193A7BDA946713068D3A6E31997D8C570BDD2906776A14F2E66A31179307FF4441145498B41E99A8C4A4F50CF08E2DB35A9D26A7495079B4A24C94B106D6C059191EBD272F6755A6E83ED36A4D0A93C2C05A391E8B51C6BB53154C86E3D0C57CCC3CCA3CCAE11FCB103F5A813EB2C006029FAF236ECCE7EB020181257EAB0234100DC9E272E190EB81D6BD858B460F4B8D8A0E795A7E886D678A612FD8945E73678425AA504A1196DEF7E64EA517F5EB5EA6986D971F0A793A2A7A58EAA2D17B0B1F683DE45A2E248BD1387A35BC0001A8456882044C99986AE16BD80187F0FA1AB9C32C0E12FEE0B17ACCA21AD06F15045E3478CB5C368FD565F396111C955E75BDAE4C57A670F63FEF5488E840BAE41ECE25F72A01984E368F7B89D3A2E755CFA858998C55313AA546AEE534729D528BF48E3584F14F0AB3C511A8271C2249E4D36D8BC5C562C00318CB3D229B7E34DE10E10AF18478FA784902C8F0F5DFD57F57868F3037CF18BF541D965B581FEB93779204A0EF0AA908A9D0930FA981CA2A3BCE8E64A6A2FE7D9FA92609800BB01D6C0717484167AF1A56895942B1B09E5F0FEBB5EB93BA8E07AC5D9E1A288614D039CD5BCDAAFEBCD1D6DF6676995D35C217C217E2CB620D7AA1FD41079CA8443F53715E96A53B5C73F03BCF779ECD9E4AF4404952783811BC8C0FD33F9848E65DE6067343F953E84FA19DEA4E2529DD05C8795140D63D93AEFB654FA367BFE73DCF7E6121AE3E03B4442B9571CF6BAB46754EF2397C8DBE03AEFDCE859EC54286A8A3BE986740556CD74CBFC3FF72A0F13BC75CC79BF139E64ECE433645077D3C7D7CE15D217E4CE7E457E5E7D86FD86AE64928537A4CD6F84D59599BE2EAC3EBC337C56565C56F3259D16D069A4452CFAB266CDC98B9297E53FCC6CC091B7915A9D78BD1AD2AAF4C507ACCBEF4AAF569D5EB03FE80DF0701B1C657D395D169F629C9271481D4A77556AD5FDF1510BBD0BBEE4412D78819DEDBF52A5EE352F1212E8361E0648D6B5CD5C4C34A0F2BCA05BD37425479BAEBFF9002201734AEE8B2A8D63EAD1A17A9676D0A9E410661C4EC6718F1F15748DEF2B694E20F874D0EDD45EAC8F5F82BA40DC9EFAE8FBA2B910F59CE46611F056F0B2A180E72F1CE94E10308E51340DBAAF559F08E71DE99089BB1AD20848CE6AC5AADDC02F3EF4C1C5A126618C8B9E3EC7150E39D80119F20F75086C61425DC890F077A8F4A08E7C37995A0F728C5BBF151E1DE86408848FA8778F55EF55DF8A09AF94C6275C2F277638389EB8E9E3E0938022F074E044E05BEE80AF802DE1A0F652C39D898F3DC4BCA99E673810BC86781CD7E6517D7892112E58ECD9E2FBC17BE9F17D81CF8025320D055D39951968112A14389F1338147021F61B923F022855F7C1460FC2866B899C8AF3A5F74677AD79C8FF3FFB67DF0039B1B7FB17F57F2E09C632903A2AA427C2CEABE505F3F0C5D673D9937E8C3FF7CFBC4E27DEE4AC78DF219290306A448F521BEC8AA8C2E9B36FF6F1F7DFDFDE603356DBF0C4B5DB864581AE9CFFD8FFD89A5472C232151EC835A2F0A353ED201A539116AA0142F13A2C98984E9E49E1A8F5CE4885DF79A3D1AD1ECE9EF317B4C222EC3CBD8D806A64CEF43527B304A4569665D4A9FC2879715FDC114C801372C62BA90D456E47D3FDE35305DCCFB78E1040370363BA44286D80FE747D1C0BB48BCC6212626710046CA1A3152D0897A9F02E737E3CC7A2F617DBD53EFD53A15C0785897DCC6B9383FE30212E5FAB84EC6C67572E7119AD0FD2EC3D972E00A2EB010AC4C27CEEE478CFC701D2FAC271FC35500D9AFD08E0E3D4A0AF298C0093305CC793DFF180F4ECEC7B4422BD78AF951EE2873148E861C8D25F961E6307FB8A32304C7E9820A180D3F4105930C37D887205576838C4C16BC1EE693910971FB2091FB603EC830581CAC22E4942359E598AB45B557DD8AF915F541B568BC62F41837909191A24C19B2711553C63AD92AB68CCD65ABC82954B8D00779D62EDC70DD12CC2E95282773A85AE5E87845ED1A674B6F50E2B6B039608108D29C1DCD54715DF21CBD5B7F9AB9019B18128123EB6B70FBC9F577980B57193B7715C5B31AE2300171966CD040AF33B002CE815B3CE70978AA210BB2C86CC384184421D165F70DF5394423F022393B0B31285D7A5F68A1E6FDC8F51A6FA490284480852C853DCA5CE1BA58B7DCC136CA3B19037A7AE4F3A0AE481BF257A63C5B9EAD3C18BA54FF555ACDBAC6EFBE7AF3CB49073FF678BC1E38E63A633BE6CA16B233FFF3C396FCD22FD73F94DAA8FF4EF795F2A0E24B1DCB814C44E5E18A14FA38FB38CDDEF0FAE18523AAA4B4736D8D1F29C823EDAEC86DF2F3F2F3CA4EF5D1A877FABC2FA53FEDAFF13F883894D0331BE8CE09654811A988161361B073D6AE69ADF5A2FBCAD6BDCF88EEF3CF20C34EDB35D49980B59C476B353C9F1451B841487CD778347BFB337F964FCEB46B2C39619B42CB380FC6C8398A4BA14F849C64D47DECD14398C7FBDBE17170879E549C8604AC45E653A18CD8A865488374A4FECBC88C668FCE63022741450F11621ACA29C608A2591CE14106F571BBD015A09E364A98C889A1E4440995518817BD0F624DBBE05B465410CB27C3F1CB3020F642197A1D555883861DC56C2CF8645849FCBC28F4F4D2D1C2FF15E720A90699610022261325C5DBC715CE9BBDFD9D83EBF51E29E1C245EA4D8B18D179181C9DF1C179E612E7A3A9936940BD20A277B791494297EE214C7E6637BB16E5444A2588134F8E92FE13FDAA4A781596C23014A089F0215CC392CB48FE3482FD2E6632D70559AC965D7FEFF989BE3B6A8D307AF4C4891F7E78EDDA8E1D972F3FF8601A39C3A4476DE9825588830C4FD83BA1778CC879144ED489E7EF5DC4CB6AFCE7D6FC63F0B93535FEC8AA81DB59C1B88968645ABF57AA7FF3EAA5FBDEBC4AEA35364694A1E77A67FF8E0B0DCF765CB8DD5FC607EBAF48F517F634455ED843FB678EAF9781318B84455FDCCCE832779A3B473EB962EE5B4FFDF5D7505FF4DEE4E2057F7E72243D02F4993B0301A93E31E781A7FFFAEB53DF47EF4D9A3EBFDFF4A4EE7A6904526F7D72F18DA7DEFAF382B0C926D3B0D11F7DA5F46EFEDE7183D41A37DD5341FA2FB941FA874DAE8A21E34772890722974C6DB877D1136FAE5AF4C2AF258D6DCBEE99B2A056B661E891B02EED2DA1E156CE430D91B3535F5F332B75F7CB2FDC7AF0C8BE2D15B57F1ECF2F3B9D31B9D17AABB1F1BB6FCEB9B30B4F4FDE28C804C606611A419B1817D1C06F8CB0C8F95B8D819BAF9F737F9298B3212B9351C9A61AE236A81A22649A7A46207BA345E7BD46A8166F815F0C880194A34488A0978A5E1C84BACCAD66578690E1CAF06678EE151245391A0039323BB9C0C3152A7F525ED1B7EAAFE83BF53E39AA0E46605D6A01449C41447DFB29738BB9C1FDC4DDE0FC5C1797C3360475184F2E199A3ABB30141DDC9D2E077AEE761C5F4625241DC6A3A3CF02EA2B57A4278E77D8125D06722F908FFEEAC088AE3E2E40601BE4395C832C2BE41BF94FAC4A4EC6173095319B581A3B62D8E9664EB371F287D91BF43E0767E6C18022B7016A89262E15F6896B847EB826108916250B10195BB26B71D9182F7156FBC04F7DF78EC8E94BB056757444C238AE5A7E8E5B811442654E3E406F403FA6DA73D535D763A18536220B2320FAF9C49F229FD7904FF1EB09B9902448BA62DD7BCA6FC9B851C05E67DAD83799F938A764B5D2E034DC83C6371516C26298091320568C43651001E158A7A0071321A20E9319ED96D1637062F087611FA189126D6588079D032F1A5F97DC256F95F96456D6C492C04F5058713F9CB08BC3800B8DEF15A690A960D2182D3C0A9B30EC1B8806A64201A1A0F144431F4C51E23D629A681573C188F36F4713730F8ECFB5A22B61431BE991BB425C7A5ECB9B90ED707E51EB6445726C8DC1632B1AC8320CF8AF709B142AD6C01850D5913DF1D2050E45C3BC08D342780F7E8083CC461CBA0A3DBA7AA8A2E1167AB8B108A57017600C760C155E1704F11ED079A25DA889BD668876E9301E50A227ADF3003F14E26D06A712642A854999A2EF52A660C87314D5207A844CAB4CA53AADF1808ADB059F3125908EEE5E3AC2CF68B80B187EB2EC5B702F2ACFCFA8F7EF35EF1DF76D8DFFE1EB377FB9F94BCDB59ACF89F42ABD44F791403EB48CBCBCC8F8E961FFBAEB63BFCDF8CC9CA2F791201E68ADDE17D369AECA583FB66BCC4F63BA32BECDF8D67CFE372DF692FEEBFC95D7C7DCD19F048BAF3AE7388778A25C6836CA90B34FB389DC65EE4B2E975BAA2C23D829AC73ADAF79E662BDC2CA5DA1F597B86FFAE4E99C325ACF393927E389710DF5CE7DE7D515D96736C47117B13F96DEDD5FF9139B283FC3927A2F57C1A5280DAC4CAED36C8C3CDC276BE8A511DEB02CD506E5B0485BE2767B967B6336447B88C463FDC7B4FE12D68B4A59E4ECC4D7ED02D6CBA20F834CA918B1DD71DA9A971991E4341FBEB3BF16A318258CD86E9B1B97303B27E3529FBBFAF7DD48BECE85E6D54DFD1C20CAA5073E79D7F3BF83D89775930361B677A6B26390C0E714E6F3330B0AF8E945CBF24B96E563314F62D4ACC0E7C59BC2041944C5053605C825EFDCF4D7FDFBFFBAA953C9210F5AD19E4E18151885EE2A8E3ECAA165CE39647270994C69D54B972EADA6A7239A27B4D1C306073A3A56A2EF96487C8444546C84E0EEC037E855D9ED0877D87BF0C82C2FCA5B8E2884065108DCDA77B6DC294C8CAB8CDB44AE11DCC6C9567229394E1B9A34E6E0D1618C209B3873ADEF57E65B879CF9C8C1C9041709BFC9572A20421519A17B324094191738414E15DCEE9D810C824746EB22A259DC223D261764928BC250E06E903E9D0F10614015350A245229797B495E7E39FDA2C27DF9CB7373CAF3F3492945F5DCDB6B562D32A96499FBDD8B5FF951A360264E593136B52B66E595EE6F65928360032844576D668229CD947688630822BC2151D7AF7F800C623DA442050F146ADC6E77AF67548504AABBCB23402A272390E27E773607DA9C530BB4810A6E0325D1C12174453C3FBE822E66626969055F5A70C7C2789EAE4BE6FBB5D1AC3558B2A2FEFEF737DCEE37ED764549454A0CB9941EE4012D5AC2007913BED9C1B11E97E05A14171B17A192B12A2A55AC52AE52DDABC6169320874C4E995022BA8B640DC14205B84829F28F1BD96121E1082DE588ACF2A20791CA21141B851BF9256077DB43CB9495953036E4E1AC88C408F58A97542AB947282BD35654CA33D74107603B3BE372B0D0E450721ECA10724E311C518A0C8B8AECA33245246C0E90E97E8B89849E02DC2E9237F4543544E618C6E744DA1B121BF80D0DE484B937B44010923D4E74A1E95390B1E812E6E42F5B535E54B1969FB426B73CAF9B63648100C112D7A23BF2DCAEE4473D1D0182A6D22BF0069D8C65324B618FB48EFD0E0EAE2C5131349892691444A69FE6FEC8FD49F64CA0077D29C3F5C9EC40A0216B4210E604A100BDEBB55A2B043B318C2C2252667031D946A3CC88D0688CA070243E471A483D9647BA50E44661A29D8896C82EA928CF458D41BE5C3339372F7F3559DA68B288575D111B6C9AF116F9B27DFB52F6EDDBF7C8BEA4C645F3AD96F928B8826030C8640C43B9E6230711540DE8E464330C1B8CDBC30E61C562F2AD56342B392497E750B975BF263D05D957CD4F58B36C6569E9E0D5FC8CFCD5153888445519D774DE9A1CCF44059C3A1F97F6518AE2E0E890AC4D2156558FD60A908F53304F39581471DEF4DA85EAEAB4852A494F0EAE2F95A76D0F90297A0BCD6DC00804A8C954FDDC5491C95514BD86A0E8A9EF14C1DB2229BF4B6235BF23B1E40B81534A5693EF4CDD96C535252B49395DDDCF371ACD8322E20CBF238D02BA6E32D45A94AE379770F413206AA596C371D5AC5AAE569914C38645F51FF12CB6184AA21225DCB211926678E476BB9D46248D63E9491FE71B4BAAF5E4DE46CF95A80411170FF5C2CC123E1735356E7D214FBE264571A5728A952AD25263FEF1A2D33A4C10A7AAC334E64B2A954A9B392467D063F18932BD9C95A96CBC204ABB30C32143BA5BD3664ED8F0E8A52E8D2A94E85F754CFFC7C685A7EBD2B202E4CBA048A88E8E6C107AD8BCDB5A4C2C2F2DA9E0B34A4BCB498985CC3C29E0AEC46477A7A2147D60551FE1A9548DF008BB6CAFE7FCDD4EA9F3A583C549B50306C4F4CFA80A84A8412E69E73184ADE96B230B99E6DF645AF078AC74B30CEE6E2D3539B7B898DC934DFA2D0A599B5E7B6D5F6363E31225F6B46AB51C47D1D8E150D04D8AD09029171CEB17EE08CFCE4A8B0AC002820BE5B41C827D04B14A18C2900312033EA1D9CCA17CA3FDF1A84185CEF7890CE423ACB75ABBF908D1224A3CA7B4AC1B2D196234DF6A30A8A2765866DBED535E7937F3F1A961A34DA3673F7327EF9C70B0A86262868F59B76AC95E4F28D0994CCA7B36F533656F0C90CF05D1131903808CDA4819911683643D51C720AA321A42E18006E96BBB5371076953F26E8E78BC667AC02F9035114532730D9A1FC254C545AB9676EB7A1913A378A8DF954257A632D0956232F0C032B58AF9BCB069838C1045E21F228000CEBD07162FBC373152A30535960C9FDE377C7E44809E33513F40D5EDF1E8240DAF52903C8C649954D1B06E05260D5E3A4C68B8EE80228451E80281C2068648AA5BA621C8CFCE5FBD6C4D3E9FBD7A557E797E715E2E29331004FBA0BED48E4C3A7C54760DF601B9EC9F7C79F828B9FA90FAA8EFDD9D6E52CE3CBF845292A14CA89812D00F8B184C0878983D1E2AD73F8F8533C19DB93D717B62A6DB7DF0F5C4D7130FFE4F1029E89E327815BF7A4D793E3F65308AE6EAFCFC1294D4A2D5C1AF57DE730F1555AD28F0B6C939B3ED730A0A0A00AF82E9B3EC39F6487BB65D1B24B3016D3C98124CC3962CF9BAC040CF996575DC1FE5CFB22F842AB2F3D272B0CD14A072C3BADD74EFFF37604D00FFFC6E9E9F97CFAF5AB3BA822FCB2F47BC56211BCC5A5354BE32B7A0383F7F39AF2048A48CDAD776DCFE42DBB5D0C1D7E1B34F649562B67069465656D6B58012F1B736E4C51929EF263818F636AE467D12992C54C518D208E7CEFAFF4345A27BED65843F899ACBCCADA828CE5F955F52B19A7CA99332AAE8F1EEAADF7AB652073535CB562EABA9E1A726F69B5CBC62C826CAA89916B70625D61E80E10EB924263D1886510961919AB267E52F50F19A001A81BACEAD12A9D04E78EE82F541B8AB1B6A04FA757582AC86A86782E9ECD2D202224B59D4AB401C5BE7BFF479CB2063A752E5D3B7664C447212921E575285EDF3F9E88F3D30D71CD473A35F22966B722CD6C956631829898B620C01C9F61A50128821F568A88F14CC1B7ADD077362DA20F8D46F072DB3114B6F5F68EBEE12F4B924C5AB90D47A69F9F2D28A0A64D7F14B97E6AFEDE530FD9020B0B0293ACB6DCC32BAB38C99186ABCF04275661A3281D7DA703AEE717D991DF6A1B671C3A525FDE03035F1A6840B17124C26D348EA634C554D334C0FB9CF344339536B0B9B65720954FBF6060AC9D4D05D405F5443C72367154A298B242BE85D7047260F1A0635F24A71717969E92A3E3BF7B683822E6C5C1649FAACAC80D188CE6C202866415943CAD79208C164FA3A32A41FA17C7871A2DCA21C3234D244759E864CD49D19A8270F77FA8060BFB384D86D298451DD89D8BC5E9E5392BBE18D9DBCDB6E8F37C66D32666D8ACBCAB4E4B8731A7222EE21666B179AAD908901E2B4226ACC2E87165E7510B52593BDF9E62B9999D7A222FA1364634D165DA282320AF5ADBBB310E088AD639EB3DB6D60879E7239ECB0D751D2D360D52E1048BCAC7E948E39A59499A715552C2BCC2F598D0E067F5F6E5109F93277517965EE5AAAC34291756984950A918D9130EBE6ACFB4C0BF7F7AD7E212141EF11ADBC56C5B12B7DEE2AEA70830EC3821A8716ED94E0F275763D3490ED133980F45E28BBDFB068DB62D9926D8E10EA23E5448EB71112139F2427924A63A26488A5908584D4AA602B15610B1A766AA814E6DCC6BAC7A2F99987EB6A6B6B99FB32772C4C4858B82393EEFAA43BFDD2B30E25CEC70B2E53945A253345517F911BA94ED25B236894C8D088F5F73230C8732209C22EC9FE4692383612FD03645F1B0DBA83910D96624B379558375D0A610D425CC2112414EC415D8AC4E581FD3B76ECC8442DA0CEAC4F2097847AB75B95E943CADADD892AD8863AEEA843498395BE7DC8411520EEBA9111D6FEB40B47035DF2E33839D495A2CF24DC8B02BB4DD267543504F3EE32AA4822EEACC3DCBED04DA83BA1B4380F5902AD1A79D2057982445788F196D953A70C19B87DCB4C3E2EE27C7F4B96ECB6AC21FB963D597EE3BB3706C68E3699C94CC98631B214EE0F2AAAEB08536AFE1BD08F0259EFC2EDC13A190D692579949A19EEE82BBB630849F910D124AA829F477E1F213377753E29A1E4BF7FFB763BF95192410B060EFAD790B339DBEE521A7242EEFEC093630127379C9CB884DDA9287E2F538048E76725A09140A204DC0428A13B53907858E976517A13E69E50985B965FDCCDDBA188CA94A8868130B041681388E6B0BB2D164B4FCC85F3ED0F00DD1094A0B71C4A5473066B4AF19123C58601FD6223B1D4F082715FD8A7CBB5798A82678834BB240AFD1EB04AA0EB8EA73BC1BFED1E092FBC4014B88D30BE8A9F58548E149F9E5B925754B2BC47525153888BB72E16757176B06FB243DCD9EADA1D2FBCB0A3B69A1C3C69AD568F4792D626879EEAB5E8FE715188F384BE581CF1FBF4261229C8E86FCB106F5943B88F01A91C7A974BE7503DE5185A1A243B2F89AB28F18AAAE77C6106F9918C55B9E5D4E6AFEA39910AEC989D901927C846412246D0AF644376E60B05FFF1726DC142F40650F32D7A8FDD1158289D4260C0C8409383C35D79FD4DE68D37D8D7E7C70C20F34CDC34A979F28C299F4CDC3AE94F935FA24AF6B661A927D956923D47ED79AD8A3AD332524205802AF90D3470E63750BF2208093F2DA46615D56E2F886E121569696199B9256B734B78E99C4DB25293E1156C3A119E8D9A3A64E0942DDB076ED5ED5828A5BBE2FB3C870A57234FC9DEB06143568A393AC1841DF39EC87FAAC0303F0A9B2CA71EAB3DC74DC16C094CED76A2E65416AD5A851CC1DB4A4B8B891852376908C952B3B2F665914B8A2C394EAFCFC80804A459FF456958C6F336DBA64D9B9263069295CDD0065DA7DFD723946A62501EA54330F2C942022C144CA5BEB54BE3EEA548B6C3EFEA93DE6A0583D2023491FC9A326A437B544BF709AF3C1058F8C2FE85690BF5A38C59C7C915E8F615CBF60E98F1115D328DDBAE2E51D0639A5818443C924132EA6CBB7EE3F0DD6676DC47DB40DC4B62D37964DEFFAF10E442F03798A411ED0BE78CBF8F4729E5A7CECCE49795E72E5B999F27853365E5A5CBCB735791154581A0CEDB327C5B40677683BDD30E9273D5C319E3A80F1A80D3E8B93C4EF9C32CD3543EF6965B13C70F26EECB58035D197571BBD7A5841D36BB3CE852A15E74F75E31AD82BBDCDE9E1AC92D273E9A9C8C40FD82D2B2BBB58D0245904A56BFA2FAFAA26D45459276572AD9345519EF099E943C80469538B3DB8F3DA789D4C4C75A88CF92FA6878718281BA054423B882EAE3FF147CBD47D4D16DB30BD2391C9985C2D7ECD2C1FD7DC858F9E57C667E5E39D53FEAE0AA56BE0B6FC05418451C327037BA279121D7FB6BD295E836C0EB30078610799FE510DCCC06870C4E3A58EA3624C40D89960E64C2A827C34918FD1E346048DEEB3902212348E577B48B402870E84CEC107ACA9920142894DFD19ED94E207188C6F34B8BA4C371AA85F4927D7863F610209166CCD99505178A56FE6B151B498D5BA4268B532518045E0CEEDA68074B6DF3C0F844E20B15B2F9CAEC2D5815435C3664571231904F3E0864C75DF4302528733C394C41AC06928312F498E90F8719C88B5BD283A7E727B80D40DF5793439E99E5B925CBF3CBD7F61CF8EC989AC0CA309E888AB4DB1306DAA7C429368C4F5FB1A7EFC02C398315065E10071D7137242E48C01116A148B81C3A05867E11F7D813B31323521286129728776BFFC769F4ACFE3DF575DBC2A1230F0B7B55FF4777ABA9BD0B7B8529BD1B77875F4C8F23642B2F425774F5607E7269718FF657D8ED8BCF91F77589712442C1EBB7C15363E3BEB7F6ED6B6C1C0C698448868DC6BF857D3890687CDD9D081BE9B11FD83441C8FD5B48DE58B10D1C5808B470D47A71E04E7CE2950677F0A9DB1E67AFCA2F5F9E5FB26C2D3F29BF24BF3CB7829C4D2AA453D11198158C920214880C0D6470E61A3397A1EFD64E516E8CB72C068B018A1C3A66B643D2B996413AAA1B54F4D715BFA11133D530CF917371D0359C89945CE45A6A45E5B6FA065CB74D6EAB953EB564AB2750A6B1D58A8453C26CF5F4D83AD3C68806201463A44F9A6F65EA8989CA2AE7A79696E4AF967E6BAB249F9CEF2ECD2F2EC21BAA6EC936B07E7B2272BB3B6036669158316ED3044616A7223772A13E617258829A1DB403F981BCAC01AF8387F90E3932B5CF57B5777A52283764303D2EECBF2544838B1A4D830039D89F9B6BEBF12FB64B077BF29E0712C0DC7E90753F70E021A722F6FCE7B661FF05DD91D7F88A8AA265DDC14BD4C701F81A6AE066CC3563F1166353DC4B59096159B880FB039473327DEE34FA2A863139826F01C118372ACB5E50B929D1423F60365B364791A3B26BE66AE7CDC83E93B685A827FC233FC90987BAACF4CCFCC7AE2EB22DF4A748DD76F27B982E49386D2E22D0A87C5CE4290798A000084039FDF64B45E9C8462D718BF65DB77DEAC04C868D29D8BD6A5FC13F57EDFEB9C0ED787FD9EB2BB7EB517C914F0451B7C3BD1F4957C01C5F12C11C5E429C6AEC1A183AC44A447A8C6CB021ED202E71222452F706AC87B41D1D83C869BE12E4767A90477B600055B23ABFFC41C2AE6B8368040F5D5E9F93D8FA44429C4CFECB77386441014CF8F44CCD3D46B3A6BF12B130A8A4937CD459EF3914CCB70E356E9AC9D49956ED745663B04CDC9F1511E3C8C1C528D8226D1CD4073DDD7A49879172AAF1B688D24BD82DAE0D943FB6040F0BB748C8D30F8BB8A57B422572CE85C634F8DE52FAE5B8EE17103A97401DA969B3DCE08E7407FD003DC32942FB8D2E6C9574F3748782A87C3045F4BB77652B4AD9207C888EE8F66D82A6BE37A002E62671337974D375B06EFA1EC8D6DD8CF8EB34DAA6F51EE8F6D87B46E9EE1D04A255AB0DBAF39A5EBC107CEFA90CDAD2C08EF909993C680D8976978137A8642653445C9CDD68518A82CBD680E116EB75772253E20ECD76E8A0851E70D4E6B5E8733F1DD54F710F25EC0043F496AC6D5495BB8916EC9D119582B99B68E45E107A432A92BDD57E221116740C7A4E4348580E5A8E036BA2E4498748EF2190A52ABAED922240BF11A529782121A172D353E5EC8044C7C307FC27D74FE0D85076A4EA4C9CEC9A3B251030185240708432E791B1503F45C72D39B03EC5307C04DDB3988D96D0F870F3021CEA31CA0DF7A339E589529725C3C1AF96B68D5618026D0F68CA0ECD5DC2289DA94F0BBCE9F2873F1BAF2C39F361D3F71F8CFBC10B179B3E806AFF30CFB90FABFDF1C7ABA25B060CFDEA3239461E0B92A7CDE05A6C9291027AECE3A2AF64643DF62F91BEC570695EA1F5AED8CCA0450BFA47AF7443428619A5ABF24BF8E96B4A8A7A42E6405CD6263B6A971FDD65EEE2B71C6EBBC2FE8AFDF90189D94F508775B4E6703094F92F875C92EC3008A39316CA574644D78744D16A2D1B24BF3D78B44E778666C88AE32172AE143926067352669F2BD99044574F19EE2389CE0F71D2E9166164FA390808EEA48A2AD679452518FAE71717E796773B7A9901D3D7868F5200869037BEE4CDEFC48484848517F61F22C172A8EEDED433DF844AAFBADD76E645B404E71D1CE1C7BEBF9AA16FC03C2A7C349966B441E83B5E9D198E6BB2D1574EC4C751695184BCC4BAB9FA49E2475FADC30E9A4BF7AE85D401D2606C53B1AC101DECCAFC724263AA0814C1F816A2C9F914DA2CBB76E2E38F274F7E646321D1A22AE204855E0F7C4DF7FBC9252A46E920DFDDAF4829686CFC4B665A5053153FB32A84AA05B65BC629480C7E2A07E84F46BB6F7F8080D25848EC266010AE4068C4F182CF42EFF25E844691C19893E7E714E6E775F38A7C21324B1CEE6F8CDD9D15472EF2EBA09B6CA8097A0E24B2BC6EA0C6E06B4718F3D512F2C2191F4D2FD68C4D1D79AF44E1A5EA65927AD30463EEC420B453573E1C22A59B30A0A7F4C4A3B293B7EE76F209F1EECF0B6562ECD573FEDAED994D0848C7D91013F9FDE686273ACD91C1B34D462BB31A3C82C4C85F3A0CD4A7B9B76FF2489C3561DBA2FAE847BAF5ADF27FCE6280BCA926AFAA25C695B6E1F6A6043D618AA1F45A58221F1708B2C1A0A2933BA66D1BBEF09D605CC885EA93C77DFA539C0FFF507302F3037A5E286EF45387A3C78CEAFED4CE1D5828C07EC77332219F0D82EFD0D920497B9398E0414F5689FCF4C47DE37F0D649C71474EDD383878E672A51BABDE274CBE20CDC69853889CE4EA161C8E50D3D3041955480AC9AD40BEEA798A845E75D474F66E480EBEE9FB8D604041A12A08D5D2BB0DCAE0BD5E28F41C0DF7047986EEB7191BC69314DA606F987BE29E411FDC76C8337704F6BBEDEF653F020F2DA13A5B4E904EFE03E1C5983F8E9A41356D9092F4AD380009CFEDBDE86CBB7DCBDCBE95EDA0F134E1458A13A1698FEF246DB73BB07DFB7F5E4A1B787163CC6472913745819DF654C35D87445D18F550DE094DFBC1F38781904CC4247C40047DA79981E240E66B25194703352DCDADD27BEDE08673921FA50DE247DE8CBBB086C48E4B4B1F943EC97127ED82AED52F6E3BF1A920BE5B392AAC4E0F75CE31D257A8C315C5CF4B58BE458F2A5057C586BD2EF0900263489B664AC259D07D2E28E9C7EEA7DE39C8CFAC59BC0621156F77CFA71632F3739715126E24A7B79004E478D2004C62166C49102D1B6CD6CCDAAF6B1756A765EA184EA98F19537373D80C370842963B805EBD9CF990BE6D95C94342FA8C29FD6EECA8546A07759478A3C0EE2414E1EFCAD037409FC88E3ACF5D6BB713BF8FAD95FCBFDF40912A303705D299F302C4F7B61FB1AFADED1A9971DCBECA6B6DE4CAAC6E6C2C1936EC0DFA52187D249609F5BA5398473E5A6F809F1D21904875FBC7DFFFF3CC77E7F605D252C966DDABEA1F193092CF5B30767BF0CC926CA7D873C0497724A81879EAF67BA89E099568585AD98D5056F739CE382467D34C6103F99165E8C145177013471417F7BD430FAD0E05E232F90F833EBD3FEFA530184B9A16F52989A092ADEEE71F6B39E60FB51CB91C0B550AB6E5AFF91F5815C6B7971F5A90D732750DFF73CB3BF71FEEB87F497C75D23D39A9A372F6580CEBFC7C8ACC3F304599AA98B3E7D8A595B1D687A2A06FDFEAF882D275C6796BAE7E75F5B236F4A8DF94CE248ECE69BDFC73E2F81C3AAE75CC990F5B1EABC4C7B562DACC9D933A32BFB01A6307145E4E0D9BB3C7C2B53C5079F1D0967971E3733EF8E4C307AE86939F57BD5A165F36F4834F2EEF9CC47564A6A6E7F8595E997A68EE9EC3FCAA8848BE6F75BB681C57787C495E75BB6094171E5E92779160F14953F59E1FC2563DF4D5079F9CB9FC3329F9E213CB004DBB23DB911DC876F44ACFDC7B32EB3F32D766E5C04359FBB3B21998F0B35F3613263C3E69793940E99441F7C17498907CDFF1E92F4C6FCC1B3F9D9933744E5574FBB4E17362C8B9D1BFEF3475D550E795259960714E5DA5730C8349AB36F79F48A268D3D2404091337BCEE4ACAAD8C95971E969E986531F28841627C48A2279D49EFAE0ABAF2E9CF0DBF82F769EFA186B4F2892B0F6C289E61AFE46F324BEA909033BDADF3261084653656BCBE92F578FFC434A12F9F1ECE973A6A42BF75AB29AE7F3ECCEA666DB65DEDA3CD9C2C5029C69D91248E74F9D20C32B536E3247A1E31F174EE8636B0329133F39F3D0AD03EA748565C24E93D0121DB0F4BF98AE6FBA55CDB573332F783E5386F25DB77673CD35E9826767D3992ABFDE12E3D7A6AB2C11644C6BCBA7018B26F6F1C0852665BCB5AB7ACF2717B1AB7252BBD9D1A0542AD3267D48A6BE5C7DEA587CBA0DDB5EFCE403FE9374FE1187A17DA7E9A452C6C86B542CA7D3AA436B549A90CB2B06C1AD665989851982839C9987A30C98E626E3B4AC9C36EE937D56D988471CF16B5B1E9A36EF56B5AC5DBF611E45131BFCE3D4C7EB4E353F7CEAF8FA532D179B4E9D202B7C3BB8DA0B27DA9926E277A038C1FF02A4C790DD]]>
      </FileEmbedded>
    </File>
    <Group Comment="shader render" DesignDisable="255">
      <Children>
        <ZExpression Expression="MemSampler.ValueArrayRef=mem;"/>
        <UseMaterial Material="SpeccyMaterial"/>
        <RenderTransformGroup Scale="8 8 1">
          <Children>
            <RenderSprite/>
          </Children>
        </RenderTransformGroup>
        <ZExpression Expression="MemSampler.ValueArrayRef=null;"/>
        <Material Name="SpeccyMaterial" Shader="SpeccyShader"/>
        <Shader Name="SpeccyShader" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D mem;

void main()
{
  vec4 color;

  float specX=gl_TexCoord[0].s * 256.0;
  float specY=gl_TexCoord[0].t * 192.0;

  float index=0 + specY*32 + specX/8;
  float u=index / 65536.0;

  vec2 uv = vec2(u ,0.0);

  color.r=texture2D(mem, uv).r*8388607.0;

/*  int pixelbyte=int(texture2D(mem, uv).r);
  if(pixelbyte) & (1<<int(specX)&7) )
    color.r=1;
  else
    color.r=0;*/

//  if(color.r!=0)
//    color.g=1.0;
  color.b=0.3;
  color.a=1.0;

  gl_FragColor = color;
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable Name="MemSampler" VariableName="mem"/>
          </UniformVariables>
        </Shader>
      </Children>
    </Group>
    <Group Comment="gl raster render" DesignDisable="1">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[byte[6144] video;
//for(int i=0; i<video.SizeDim1; i++)
//  video[i]=mem[16384+i];//rnd()*255;

for(int addr=16384; addr<(16384+192*32); ) {
  int y = ((addr&0x00e0)>>2) +
       ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}

/*glMatrixMode(GL_PROJECTION_MATRIX);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW_MATRIX);
glLoadIdentity();*/
glRasterPos2f(-1,-2);
glBitmap(256,192,0,0,0,0,video[0]);]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
    <KeyPress Name="KeyTester" CharCode="17">
      <OnPressed>
        <ZExpression Expression="KeyTesterResult=1;"/>
      </OnPressed>
    </KeyPress>
    <Variable Name="KeyTesterResult" Type="1"/>
  </Content>
</ZApplication>
